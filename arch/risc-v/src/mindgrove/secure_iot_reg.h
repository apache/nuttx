/*
 * Copyright (c) 2009-2019 ARM Limited. All rights reserved.
 * 
 * SPDX-License-Identifier: Apache-2.0
 * 
 * Licensed under the Apache License, Version 2.0 (the License); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @file     /home/sir-kapil-shyam/WORK/Mindgrove_Github/secure-iot-soc/svd_out//Secure_IoT.h
 * @brief    CMSIS HeaderFile
 * @version  1.0.0
 * @date     Fri Jan 10 10:21:01 2025
 * @note     Generated by SVDConv V3.3.47+p61-g36cc80e9
 *           from File '/home/sir-kapil-shyam/WORK/Mindgrove_Github/secure-iot-soc/Secure_IoT.svd',
 *           last modified on Fri Jan 10 10:20:07 2025
 */


/** @addtogroup Mindgrove Technologies Private Limited
  * @{
  */


/** @addtogroup Secure_IoT
  * @{
  */


#ifndef SECURE_IOT_H
#define SECURE_IOT_H

#ifdef __cplusplus
extern "C" {
#endif
#include"stdint.h"

/** @addtogroup Configuration_of_CMSIS
  * @{
  */



/* =========================================================================================================================== */
/* ================                                Interrupt Number Definition                                ================ */
/* =========================================================================================================================== */

typedef enum {
/* =======================================  Shakti C-Class Specific Interrupt Numbers  ======================================= */
/* =========================================  Secure_IoT Specific Interrupt Numbers  ========================================= */
  GPIO0_IRQn                =   1,              /*!< 1  GPIO0                                                                  */
  GPIO1_IRQn                =   2,              /*!< 2  GPIO1                                                                  */
  GPIO2_IRQn                =   3,              /*!< 3  GPIO2                                                                  */
  GPIO3_IRQn                =   4,              /*!< 4  GPIO3                                                                  */
  GPIO4_IRQn                =   5,              /*!< 5  GPIO4                                                                  */
  GPIO5_IRQn                =   6,              /*!< 6  GPIO5                                                                  */
  GPIO6_IRQn                =   7,              /*!< 7  GPIO6                                                                  */
  GPIO7_IRQn                =   8,              /*!< 8  GPIO7                                                                  */
  GPIO8_IRQn                =   9,              /*!< 9  GPIO8                                                                  */
  GPIO9_IRQn                =  10,              /*!< 10 GPIO9                                                                  */
  GPIO10_IRQn               =  11,              /*!< 11 GPIO10                                                                 */
  GPIO11_IRQn               =  12,              /*!< 12 GPIO11                                                                 */
  GPIO12_IRQn               =  13,              /*!< 13 GPIO12                                                                 */
  GPIO13_IRQn               =  14,              /*!< 14 GPIO13                                                                 */
  GPIO14_IRQn               =  15,              /*!< 15 GPIO14                                                                 */
  GPIO15_IRQn               =  16,              /*!< 16 GPIO15                                                                 */
  GPIO16_IRQn               =  17,              /*!< 17 GPIO16                                                                 */
  GPIO17_IRQn               =  18,              /*!< 18 GPIO17                                                                 */
  GPIO18_IRQn               =  19,              /*!< 19 GPIO18                                                                 */
  GPIO19_IRQn               =  20,              /*!< 20 GPIO19                                                                 */
  GPIO20_IRQn               =  21,              /*!< 21 GPIO20                                                                 */
  GPIO21_IRQn               =  22,              /*!< 22 GPIO21                                                                 */
  GPIO22_IRQn               =  23,              /*!< 23 GPIO22                                                                 */
  GPIO23_IRQn               =  24,              /*!< 24 GPIO23                                                                 */
  GPIO24_IRQn               =  25,              /*!< 25 GPIO24                                                                 */
  GPIO25_IRQn               =  26,              /*!< 26 GPIO25                                                                 */
  GPIO26_IRQn               =  27,              /*!< 27 GPIO26                                                                 */
  GPIO27_IRQn               =  28,              /*!< 28 GPIO27                                                                 */
  GPIO28_IRQn               =  29,              /*!< 29 GPIO28                                                                 */
  GPIO29_IRQn               =  30,              /*!< 30 GPIO29                                                                 */
  GPIO30_IRQn               =  31,              /*!< 31 GPIO30                                                                 */
  GPIO31_IRQn               =  32,              /*!< 32 GPIO31                                                                 */
  PWM0_IRQn                 =  33,              /*!< 33 PWM0                                                                   */
  PWM1_IRQn                 =  34,              /*!< 34 PWM1                                                                   */
  PWM2_IRQn                 =  35,              /*!< 35 PWM2                                                                   */
  PWM3_IRQn                 =  36,              /*!< 36 PWM3                                                                   */
  PWM4_IRQn                 =  37,              /*!< 37 PWM4                                                                   */
  PWM5_IRQn                 =  38,              /*!< 38 PWM5                                                                   */
  PWM6_IRQn                 =  39,              /*!< 39 PWM6                                                                   */
  PWM7_IRQn                 =  40,              /*!< 40 PWM7                                                                   */
  PWM8_IRQn                 =  41,              /*!< 41 PWM8                                                                   */
  PWM9_IRQn                 =  42,              /*!< 42 PWM9                                                                   */
  PWM10_IRQn                =  43,              /*!< 43 PWM10                                                                  */
  PWM11_IRQn                =  44,              /*!< 44 PWM11                                                                  */
  PWM12_IRQn                =  45,              /*!< 45 PWM12                                                                  */
  PWM13_IRQn                =  46,              /*!< 46 PWM13                                                                  */
  GPTIMER0_IRQn             =  47,              /*!< 47 GPTIMER0                                                               */
  GPTIMER1_IRQn             =  48,              /*!< 48 GPTIMER1                                                               */
  GPTIMER2_IRQn             =  49,              /*!< 49 GPTIMER2                                                               */
  GPTIMER3_IRQn             =  50,              /*!< 50 GPTIMER3                                                               */
  I2C0_IRQn                 =  51,              /*!< 51 I2C0                                                                   */
  I2C1_IRQn                 =  52,              /*!< 52 I2C1                                                                   */
  UART0_IRQn                =  53,              /*!< 53 UART0                                                                  */
  UART1_IRQn                =  54,              /*!< 54 UART1                                                                  */
  UART2_IRQn                =  55,              /*!< 55 UART2                                                                  */
  UART3_IRQn                =  56,              /*!< 56 UART3                                                                  */
  UART4_IRQn                =  57,              /*!< 57 UART4                                                                  */
  QUADSPI0_IRQn             =  58,              /*!< 58 QUADSPI0                                                               */
  QUADSPI0_READY_IRQn       =  59,              /*!< 59 QUADSPI0_READY                                                         */
  QUADSPI1_IRQn             =  60,              /*!< 60 QUADSPI1                                                               */
  QUADSPI1_READY_IRQn       =  61,              /*!< 61 QUADSPI1_READY                                                         */
  SPI0_IRQn                 =  62,              /*!< 62 SPI0                                                                   */
  SPI1_IRQn                 =  63,              /*!< 63 SPI1                                                                   */
  SPI2_IRQn                 =  64,              /*!< 64 SPI2                                                                   */
  SPI3_IRQn                 =  65,              /*!< 65 SPI3                                                                   */
  ADC_INTR_IRQn             =  66,              /*!< 66 ADC_INTR                                                               */
  ITRACE_INTR_IRQn          =  67,              /*!< 67 ITRACE_INTR                                                            */
  DMA_INTR_IRQn             =  68,              /*!< 68 DMA_INTR                                                               */
  GPIOP0_IRQn               =  69,              /*!< 69 GPIOP0                                                                 */
  GPIOP1_IRQn               =  70,              /*!< 70 GPIOP1                                                                 */
  GPIOP2_IRQn               =  71,              /*!< 71 GPIOP2                                                                 */
  GPIOP3_IRQn               =  72,              /*!< 72 GPIOP3                                                                 */
  GPIOP4_IRQn               =  73,              /*!< 73 GPIOP4                                                                 */
  GPIOP5_IRQn               =  74,              /*!< 74 GPIOP5                                                                 */
  GPIOP6_IRQn               =  75,              /*!< 75 GPIOP6                                                                 */
  GPIOP7_IRQn               =  76,              /*!< 76 GPIOP7                                                                 */
  GPIOP8_IRQn               =  77,              /*!< 77 GPIOP8                                                                 */
  GPIOP9_IRQn               =  78,              /*!< 78 GPIOP9                                                                 */
  GPIOP10_IRQn              =  79,              /*!< 79 GPIOP10                                                                */
  GPIOP11_IRQn              =  80,              /*!< 80 GPIOP11                                                                */
  GPIOP12_IRQn              =  81               /*!< 81 GPIOP12                                                                */
} IRQn_Type;



/* =========================================================================================================================== */
/* ================                           Processor and Core Peripheral Section                           ================ */
/* =========================================================================================================================== */

/* ==========================  Configuration of the Shakti C-Class Processor and Core Peripherals  =========================== */
#define __VAJRA_REV                 0x0109U     /*!< VAJRA Core Revision                                                       */
#define __NVIC_PRIO_BITS               7        /*!< Number of Bits used for Priority Levels                                   */
#define __Vendor_SysTickConfig         0        /*!< Set to 1 if different SysTick Config is used                              */
#define __MPU_PRESENT                  1        /*!< MPU present                                                               */
#define __FPU_PRESENT                  1        /*!< FPU present                                                               */
#define __FPU_DP                       1        /*!< Double Precision FPU                                                      */
#define __DSP_PRESENT                  0        /*!< DSP extension present                                                     */
#define __ICACHE_PRESENT               1        /*!< Instruction Cache present                                                 */
#define __DCACHE_PRESENT               1        /*!< Data Cache present                                                        */


/** @} */ /* End of group Configuration_of_CMSIS */

// #include "core_vajra.h"                         /*!< Shakti C-Class processor and core peripherals                             */
// #include "system_Secure_IoT.h"                  /*!< Secure_IoT System                                                         */

#define __IO volatile
#define __O volatile
#define __I volatile const

#ifndef __IM                                    /*!< Fallback for older CMSIS versions                                         */
  #define __IM   __I
#endif
#ifndef __OM                                    /*!< Fallback for older CMSIS versions                                         */
  #define __OM   __O
#endif
#ifndef __IOM                                   /*!< Fallback for older CMSIS versions                                         */
  #define __IOM  __IO
#endif


/* ========================================  Start of section using anonymous unions  ======================================== */
#if defined (__CC_ARM)
  #pragma push
  #pragma anon_unions
#elif defined (__ICCARM__)
  #pragma language=extended
#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wc11-extensions"
  #pragma clang diagnostic ignored "-Wreserved-id-macro"
  #pragma clang diagnostic ignored "-Wgnu-anonymous-struct"
  #pragma clang diagnostic ignored "-Wnested-anon-types"
#elif defined (__GNUC__)
  /* anonymous unions are enabled by default */
#elif defined (__TMS470__)
  /* anonymous unions are enabled by default */
#elif defined (__TASKING__)
  #pragma warning 586
#elif defined (__CSMC__)
  /* anonymous unions are enabled by default */
#else
  #warning Not supported compiler type
#endif


typedef union{
  uint64_t data_64;
  uint32_t data_32;
  uint16_t data_16;
  uint8_t data_8;
} QSPI_Data;

typedef union{
  uint32_t data_32;
  uint16_t data_16;
  uint8_t data_8;
} Data;

typedef union{
  uint32_t data_32;
  uint16_t data_16;
} Buf_4_8_Data;


/* =========================================================================================================================== */
/* ================                            Device Specific Peripheral Section                             ================ */
/* =========================================================================================================================== */


/** @addtogroup Device_Peripheral_peripherals
  * @{
  */



/* =========================================================================================================================== */
/* ================                                            DMA                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Direct Memory Access controller. (DMA)
  */

typedef struct {                                /*!< DMA Structure                                                             */
  
  union {
    __IOM uint32_t DMA_CCR0;                    /*!< Channel configuration regisster of channel0                               */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< To enable the channel                                                     */
      __IOM uint32_t TCIE       : 1;            /*!< Transfer complete interrupt enable                                        */
      __IOM uint32_t HTIE       : 1;            /*!< Half transfer interrupt enable                                            */
      __IOM uint32_t TEIE       : 1;            /*!< Transfer error interrupt enable                                           */
      __IOM uint32_t DIR        : 1;            /*!< Data transfer direction                                                   */
            uint32_t            : 1;
      __IOM uint32_t PINC       : 2;            /*!< Periheral increment mode                                                  */
      __IOM uint32_t MINC       : 2;            /*!< Memory increment mode                                                     */
      __IOM uint32_t PSIZE      : 2;            /*!< Data size of each DMA transfer to the peripheral                          */
      __IOM uint32_t MSIZE      : 2;            /*!< Data size of each DMA transfer to the memory                              */
      __IOM uint32_t PL         : 2;            /*!< Priority level                                                            */
      __IOM uint32_t MEM2MEM    : 1;            /*!< Memory to memory mode                                                     */
            uint32_t            : 1;
      __IOM uint32_t P2P        : 1;            /*!< Periheral to peripheral mode                                              */
            uint32_t            : 13;
    } DMA_CCR0_b;
  } ;
  __IM  uint32_t  RESERVED;
  
  union {
    __IOM uint16_t DMA_CNDTR0;                  /*!< Channel0 number of data to transfer                                       */
    
    struct {
      __IOM uint16_t NDT        : 16;           /*!< This register has the value of total number of data to transfer
                                                     channel0                                                                  */
    } DMA_CNDTR0_b;
  } ;
  __IM  uint16_t  RESERVED1;
  __IM  uint32_t  RESERVED2;
  
  union {
    __IOM uint32_t DMA_CPAR0;                   /*!< Channel0 peripheral address register                                      */
    
    struct {
      __IOM uint32_t PA         : 32;           /*!< It consists the base address of peripheral data register depends
                                                     on the direction bit it can be source or destination address              */
    } DMA_CPAR0_b;
  } ;
  __IM  uint32_t  RESERVED3;
  
  union {
    __IOM uint32_t DMA_CMAR0;                   /*!< Channel0 memory address register                                          */
    
    struct {
      __IOM uint32_t PA         : 32;           /*!< It consists the base address of peripheral data register depends
                                                     on the direction bit it can be source or destination address              */
    } DMA_CMAR0_b;
  } ;
  __IM  uint32_t  RESERVED4;
  
  union {
    __IOM uint16_t DMA_CSELR0;                  /*!< Channel0 selection register                                               */
    
    struct {
      __IOM uint16_t CS         : 10;           /*!< This register is used to the DMA channel0                                 */
            uint16_t            : 6;
    } DMA_CSELR0_b;
  } ;
  __IM  uint16_t  RESERVED5;
  __IM  uint32_t  RESERVED6;
  
  union {
    __IOM uint32_t DMA_CCR1;                    /*!< Channel configuration regisster of channel1                               */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< To enable the channel                                                     */
      __IOM uint32_t TCIE       : 1;            /*!< Transfer complete interrupt enable                                        */
      __IOM uint32_t HTIE       : 1;            /*!< Half transfer interrupt enable                                            */
      __IOM uint32_t TEIE       : 1;            /*!< Transfer error interrupt enable                                           */
      __IOM uint32_t DIR        : 1;            /*!< Data transfer direction                                                   */
            uint32_t            : 1;
      __IOM uint32_t PINC       : 2;            /*!< Periheral increment mode                                                  */
      __IOM uint32_t MINC       : 2;            /*!< Memory increment mode                                                     */
      __IOM uint32_t PSIZE      : 2;            /*!< Data size of each DMA transfer to the peripheral                          */
      __IOM uint32_t MSIZE      : 2;            /*!< Data size of each DMA transfer to the memory                              */
      __IOM uint32_t PL         : 2;            /*!< Priority level                                                            */
      __IOM uint32_t MEM2MEM    : 1;            /*!< Memory to memory mode                                                     */
            uint32_t            : 1;
      __IOM uint32_t P2P        : 1;            /*!< Periheral to peripheral mode                                              */
            uint32_t            : 13;
    } DMA_CCR1_b;
  } ;
  __IM  uint32_t  RESERVED7;
  
  union {
    __IOM uint16_t DMA_CNDTR1;                  /*!< Channel1 number of data to transfer                                       */
    
    struct {
      __IOM uint16_t NDT        : 16;           /*!< This register has the value of total number of data to transfer
                                                     channel1                                                                  */
    } DMA_CNDTR1_b;
  } ;
  __IM  uint16_t  RESERVED8;
  __IM  uint32_t  RESERVED9;
  
  union {
    __IOM uint32_t DMA_CPAR1;                   /*!< Channel1 peripheral address register                                      */
    
    struct {
      __IOM uint32_t PA         : 32;           /*!< It consists the base address of peripheral data register depends
                                                     on the direction bit it can be source or destination address              */
    } DMA_CPAR1_b;
  } ;
  __IM  uint32_t  RESERVED10;
  
  union {
    __IOM uint32_t DMA_CMAR1;                   /*!< Channel1 memory address register                                          */
    
    struct {
      __IOM uint32_t PA         : 32;           /*!< It consists the base address of peripheral data register depends
                                                     on the direction bit it can be source or destination address              */
    } DMA_CMAR1_b;
  } ;
  __IM  uint32_t  RESERVED11;
  
  union {
    __IOM uint16_t DMA_CSELR1;                  /*!< Channel1 selection register                                               */
    
    struct {
      __IOM uint16_t CS         : 10;           /*!< This register is used to the DMA channel1                                 */
            uint16_t            : 6;
    } DMA_CSELR1_b;
  } ;
  __IM  uint16_t  RESERVED12;
  __IM  uint32_t  RESERVED13;
  
  union {
    __IOM uint32_t DMA_CCR2;                    /*!< Channel configuration regisster of channel2                               */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< To enable the channel                                                     */
      __IOM uint32_t TCIE       : 1;            /*!< Transfer complete interrupt enable                                        */
      __IOM uint32_t HTIE       : 1;            /*!< Half transfer interrupt enable                                            */
      __IOM uint32_t TEIE       : 1;            /*!< Transfer error interrupt enable                                           */
      __IOM uint32_t DIR        : 1;            /*!< Data transfer direction                                                   */
            uint32_t            : 1;
      __IOM uint32_t PINC       : 2;            /*!< Periheral increment mode                                                  */
      __IOM uint32_t MINC       : 2;            /*!< Memory increment mode                                                     */
      __IOM uint32_t PSIZE      : 2;            /*!< Data size of each DMA transfer to the peripheral                          */
      __IOM uint32_t MSIZE      : 2;            /*!< Data size of each DMA transfer to the memory                              */
      __IOM uint32_t PL         : 2;            /*!< Priority level                                                            */
      __IOM uint32_t MEM2MEM    : 1;            /*!< Memory to memory mode                                                     */
            uint32_t            : 1;
      __IOM uint32_t P2P        : 1;            /*!< Periheral to peripheral mode                                              */
            uint32_t            : 13;
    } DMA_CCR2_b;
  } ;
  __IM  uint32_t  RESERVED14;
  
  union {
    __IOM uint16_t DMA_CNDTR2;                  /*!< Channel2 number of data to transfer                                       */
    
    struct {
      __IOM uint16_t NDT        : 16;           /*!< This register has the value of total number of data to transfer
                                                     channel2                                                                  */
    } DMA_CNDTR2_b;
  } ;
  __IM  uint16_t  RESERVED15;
  __IM  uint32_t  RESERVED16;
  
  union {
    __IOM uint32_t DMA_CPAR2;                   /*!< Channel2 peripheral address register                                      */
    
    struct {
      __IOM uint32_t PA         : 32;           /*!< It consists the base address of peripheral data register depends
                                                     on the direction bit it can be source or destination address              */
    } DMA_CPAR2_b;
  } ;
  __IM  uint32_t  RESERVED17;
  
  union {
    __IOM uint32_t DMA_CMAR2;                   /*!< Channel2 memory address register                                          */
    
    struct {
      __IOM uint32_t PA         : 32;           /*!< It consists the base address of peripheral data register depends
                                                     on the direction bit it can be source or destination address              */
    } DMA_CMAR2_b;
  } ;
  __IM  uint32_t  RESERVED18;
  
  union {
    __IOM uint16_t DMA_CSELR2;                  /*!< Channel2 selection register                                               */
    
    struct {
      __IOM uint16_t CS         : 10;           /*!< This register is used to the DMA channel2                                 */
            uint16_t            : 6;
    } DMA_CSELR2_b;
  } ;
  __IM  uint16_t  RESERVED19;
  __IM  uint32_t  RESERVED20;
  
  union {
    __IOM uint32_t DMA_CCR3;                    /*!< Channel configuration regisster of channel3`                              */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< To enable the channel                                                     */
      __IOM uint32_t TCIE       : 1;            /*!< Transfer complete interrupt enable                                        */
      __IOM uint32_t HTIE       : 1;            /*!< Half transfer interrupt enable                                            */
      __IOM uint32_t TEIE       : 1;            /*!< Transfer error interrupt enable                                           */
      __IOM uint32_t DIR        : 1;            /*!< Data transfer direction                                                   */
            uint32_t            : 1;
      __IOM uint32_t PINC       : 2;            /*!< Periheral increment mode                                                  */
      __IOM uint32_t MINC       : 2;            /*!< Memory increment mode                                                     */
      __IOM uint32_t PSIZE      : 2;            /*!< Data size of each DMA transfer to the peripheral                          */
      __IOM uint32_t MSIZE      : 2;            /*!< Data size of each DMA transfer to the memory                              */
      __IOM uint32_t PL         : 2;            /*!< Priority level                                                            */
      __IOM uint32_t MEM2MEM    : 1;            /*!< Memory to memory mode                                                     */
            uint32_t            : 1;
      __IOM uint32_t P2P        : 1;            /*!< Periheral to peripheral mode                                              */
            uint32_t            : 13;
    } DMA_CCR3_b;
  } ;
  __IM  uint32_t  RESERVED21;
  
  union {
    __IOM uint16_t DMA_CNDTR3;                  /*!< Channel3 number of data to transfer                                       */
    
    struct {
      __IOM uint16_t NDT        : 16;           /*!< This register has the value of total number of data to transfer
                                                     channel3                                                                  */
    } DMA_CNDTR3_b;
  } ;
  __IM  uint16_t  RESERVED22;
  __IM  uint32_t  RESERVED23;
  
  union {
    __IOM uint32_t DMA_CPAR3;                   /*!< Channel3 peripheral address register                                      */
    
    struct {
      __IOM uint32_t PA         : 32;           /*!< It consists the base address of peripheral data register depends
                                                     on the direction bit it can be source or destination address              */
    } DMA_CPAR3_b;
  } ;
  __IM  uint32_t  RESERVED24;
  
  union {
    __IOM uint32_t DMA_CMAR3;                   /*!< Channel3 memory address register                                          */
    
    struct {
      __IOM uint32_t PA         : 32;           /*!< It consists the base address of peripheral data register depends
                                                     on the direction bit it can be source or destination address              */
    } DMA_CMAR3_b;
  } ;
  __IM  uint32_t  RESERVED25;
  
  union {
    __IOM uint16_t DMA_CSELR3;                  /*!< Channel3 selection register                                               */
    
    struct {
      __IOM uint16_t CS         : 10;           /*!< This register is used to the DMA channel3                                 */
            uint16_t            : 6;
    } DMA_CSELR3_b;
  } ;
  __IM  uint16_t  RESERVED26;
  __IM  uint32_t  RESERVED27;
  
  union {
    __IOM uint32_t DMA_CCR4;                    /*!< Channel configuration regisster of channel4                               */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< To enable the channel                                                     */
      __IOM uint32_t TCIE       : 1;            /*!< Transfer complete interrupt enable                                        */
      __IOM uint32_t HTIE       : 1;            /*!< Half transfer interrupt enable                                            */
      __IOM uint32_t TEIE       : 1;            /*!< Transfer error interrupt enable                                           */
      __IOM uint32_t DIR        : 1;            /*!< Data transfer direction                                                   */
            uint32_t            : 1;
      __IOM uint32_t PINC       : 2;            /*!< Periheral increment mode                                                  */
      __IOM uint32_t MINC       : 2;            /*!< Memory increment mode                                                     */
      __IOM uint32_t PSIZE      : 2;            /*!< Data size of each DMA transfer to the peripheral                          */
      __IOM uint32_t MSIZE      : 2;            /*!< Data size of each DMA transfer to the memory                              */
      __IOM uint32_t PL         : 2;            /*!< Priority level                                                            */
      __IOM uint32_t MEM2MEM    : 1;            /*!< Memory to memory mode                                                     */
            uint32_t            : 1;
      __IOM uint32_t P2P        : 1;            /*!< Periheral to peripheral mode                                              */
            uint32_t            : 13;
    } DMA_CCR4_b;
  } ;
  __IM  uint32_t  RESERVED28;
  
  union {
    __IOM uint16_t DMA_CNDTR4;                  /*!< Channel4 number of data to transfer                                       */
    
    struct {
      __IOM uint16_t NDT        : 16;           /*!< This register has the value of total number of data to transfer
                                                     channel4                                                                  */
    } DMA_CNDTR4_b;
  } ;
  __IM  uint16_t  RESERVED29;
  __IM  uint32_t  RESERVED30;
  
  union {
    __IOM uint32_t DMA_CPAR4;                   /*!< Channel4 peripheral address register                                      */
    
    struct {
      __IOM uint32_t PA         : 32;           /*!< It consists the base address of peripheral data register depends
                                                     on the direction bit it can be source or destination address              */
    } DMA_CPAR4_b;
  } ;
  __IM  uint32_t  RESERVED31;
  
  union {
    __IOM uint32_t DMA_CMAR4;                   /*!< Channel4 memory address register                                          */
    
    struct {
      __IOM uint32_t PA         : 32;           /*!< It consists the base address of peripheral data register depends
                                                     on the direction bit it can be source or destination address              */
    } DMA_CMAR4_b;
  } ;
  __IM  uint32_t  RESERVED32;
  
  union {
    __IOM uint16_t DMA_CSELR4;                  /*!< Channel4 selection register                                               */
    
    struct {
      __IOM uint16_t CS         : 10;           /*!< This register is used to the DMA channel4                                 */
            uint16_t            : 6;
    } DMA_CSELR4_b;
  } ;
  __IM  uint16_t  RESERVED33;
  __IM  uint32_t  RESERVED34;
  
  union {
    __IOM uint32_t DMA_CCR5;                    /*!< Channel configuration regisster of channel5                               */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< To enable the channel                                                     */
      __IOM uint32_t TCIE       : 1;            /*!< Transfer complete interrupt enable                                        */
      __IOM uint32_t HTIE       : 1;            /*!< Half transfer interrupt enable                                            */
      __IOM uint32_t TEIE       : 1;            /*!< Transfer error interrupt enable                                           */
      __IOM uint32_t DIR        : 1;            /*!< Data transfer direction                                                   */
            uint32_t            : 1;
      __IOM uint32_t PINC       : 2;            /*!< Periheral increment mode                                                  */
      __IOM uint32_t MINC       : 2;            /*!< Memory increment mode                                                     */
      __IOM uint32_t PSIZE      : 2;            /*!< Data size of each DMA transfer to the peripheral                          */
      __IOM uint32_t MSIZE      : 2;            /*!< Data size of each DMA transfer to the memory                              */
      __IOM uint32_t PL         : 2;            /*!< Priority level                                                            */
      __IOM uint32_t MEM2MEM    : 1;            /*!< Memory to memory mode                                                     */
            uint32_t            : 1;
      __IOM uint32_t P2P        : 1;            /*!< Periheral to peripheral mode                                              */
            uint32_t            : 13;
    } DMA_CCR5_b;
  } ;
  __IM  uint32_t  RESERVED35;
  
  union {
    __IOM uint16_t DMA_CNDTR5;                  /*!< Channel5 number of data to transfer                                       */
    
    struct {
      __IOM uint16_t NDT        : 16;           /*!< This register has the value of total number of data to transfer
                                                     channel5                                                                  */
    } DMA_CNDTR5_b;
  } ;
  __IM  uint16_t  RESERVED36;
  __IM  uint32_t  RESERVED37;
  
  union {
    __IOM uint32_t DMA_CPAR5;                   /*!< Channel5 peripheral address register                                      */
    
    struct {
      __IOM uint32_t PA         : 32;           /*!< It consists the base address of peripheral data register depends
                                                     on the direction bit it can be source or destination address              */
    } DMA_CPAR5_b;
  } ;
  __IM  uint32_t  RESERVED38;
  
  union {
    __IOM uint32_t DMA_CMAR5;                   /*!< Channel5 memory address register                                          */
    
    struct {
      __IOM uint32_t PA         : 32;           /*!< It consists the base address of peripheral data register depends
                                                     on the direction bit it can be source or destination address              */
    } DMA_CMAR5_b;
  } ;
  __IM  uint32_t  RESERVED39;
  
  union {
    __IOM uint16_t DMA_CSELR5;                  /*!< Channel5 selection register                                               */
    
    struct {
      __IOM uint16_t CS         : 10;           /*!< This register is used to the DMA channel5                                 */
            uint16_t            : 6;
    } DMA_CSELR5_b;
  } ;
  __IM  uint16_t  RESERVED40;
  __IM  uint32_t  RESERVED41;
  
  union {
    __IOM uint32_t DMA_CCR6;                    /*!< Channel configuration regisster of channel6                               */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< To enable the channel                                                     */
      __IOM uint32_t TCIE       : 1;            /*!< Transfer complete interrupt enable                                        */
      __IOM uint32_t HTIE       : 1;            /*!< Half transfer interrupt enable                                            */
      __IOM uint32_t TEIE       : 1;            /*!< Transfer error interrupt enable                                           */
      __IOM uint32_t DIR        : 1;            /*!< Data transfer direction                                                   */
            uint32_t            : 1;
      __IOM uint32_t PINC       : 2;            /*!< Periheral increment mode                                                  */
      __IOM uint32_t MINC       : 2;            /*!< Memory increment mode                                                     */
      __IOM uint32_t PSIZE      : 2;            /*!< Data size of each DMA transfer to the peripheral                          */
      __IOM uint32_t MSIZE      : 2;            /*!< Data size of each DMA transfer to the memory                              */
      __IOM uint32_t PL         : 2;            /*!< Priority level                                                            */
      __IOM uint32_t MEM2MEM    : 1;            /*!< Memory to memory mode                                                     */
            uint32_t            : 1;
      __IOM uint32_t P2P        : 1;            /*!< Periheral to peripheral mode                                              */
            uint32_t            : 13;
    } DMA_CCR6_b;
  } ;
  __IM  uint32_t  RESERVED42;
  
  union {
    __IOM uint16_t DMA_CNDTR6;                  /*!< Channel6 number of data to transfer                                       */
    
    struct {
      __IOM uint16_t NDT        : 16;           /*!< This register has the value of total number of data to transfer
                                                     channel6                                                                  */
    } DMA_CNDTR6_b;
  } ;
  __IM  uint16_t  RESERVED43;
  __IM  uint32_t  RESERVED44;
  
  union {
    __IOM uint32_t DMA_CPAR6;                   /*!< Channel6 peripheral address register                                      */
    
    struct {
      __IOM uint32_t PA         : 32;           /*!< It consists the base address of peripheral data register depends
                                                     on the direction bit it can be source or destination address              */
    } DMA_CPAR6_b;
  } ;
  __IM  uint32_t  RESERVED45;
  
  union {
    __IOM uint32_t DMA_CMAR6;                   /*!< Channel6 memory address register                                          */
    
    struct {
      __IOM uint32_t PA         : 32;           /*!< It consists the base address of peripheral data register depends
                                                     on the direction bit it can be source or destination address              */
    } DMA_CMAR6_b;
  } ;
  __IM  uint32_t  RESERVED46;
  
  union {
    __IOM uint16_t DMA_CSELR6;                  /*!< Channel6 selection register                                               */
    
    struct {
      __IOM uint16_t CS         : 10;           /*!< This register is used to the DMA channel6                                 */
            uint16_t            : 6;
    } DMA_CSELR6_b;
  } ;
  __IM  uint16_t  RESERVED47;
  __IM  uint32_t  RESERVED48;
  
  union {
    __IOM uint32_t DMA_CCR7;                    /*!< Channel configuration regisster of channel7                               */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< To enable the channel                                                     */
      __IOM uint32_t TCIE       : 1;            /*!< Transfer complete interrupt enable                                        */
      __IOM uint32_t HTIE       : 1;            /*!< Half transfer interrupt enable                                            */
      __IOM uint32_t TEIE       : 1;            /*!< Transfer error interrupt enable                                           */
      __IOM uint32_t DIR        : 1;            /*!< Data transfer direction                                                   */
            uint32_t            : 1;
      __IOM uint32_t PINC       : 2;            /*!< Periheral increment mode                                                  */
      __IOM uint32_t MINC       : 2;            /*!< Memory increment mode                                                     */
      __IOM uint32_t PSIZE      : 2;            /*!< Data size of each DMA transfer to the peripheral                          */
      __IOM uint32_t MSIZE      : 2;            /*!< Data size of each DMA transfer to the memory                              */
      __IOM uint32_t PL         : 2;            /*!< Priority level                                                            */
      __IOM uint32_t MEM2MEM    : 1;            /*!< Memory to memory mode                                                     */
            uint32_t            : 1;
      __IOM uint32_t P2P        : 1;            /*!< Periheral to peripheral mode                                              */
            uint32_t            : 13;
    } DMA_CCR7_b;
  } ;
  __IM  uint32_t  RESERVED49;
  
  union {
    __IOM uint16_t DMA_CNDTR7;                  /*!< Channel7 number of data to transfer                                       */
    
    struct {
      __IOM uint16_t NDT        : 16;           /*!< This register has the value of total number of data to transfer
                                                     channel7                                                                  */
    } DMA_CNDTR7_b;
  } ;
  __IM  uint16_t  RESERVED50;
  __IM  uint32_t  RESERVED51;
  
  union {
    __IOM uint32_t DMA_CPAR7;                   /*!< Channel7 peripheral address register                                      */
    
    struct {
      __IOM uint32_t PA         : 32;           /*!< It consists the base address of peripheral data register depends
                                                     on the direction bit it can be source or destination address              */
    } DMA_CPAR7_b;
  } ;
  __IM  uint32_t  RESERVED52;
  
  union {
    __IOM uint32_t DMA_CMAR7;                   /*!< Channel7 memory address register                                          */
    
    struct {
      __IOM uint32_t PA         : 32;           /*!< It consists the base address of peripheral data register depends
                                                     on the direction bit it can be source or destination address              */
    } DMA_CMAR7_b;
  } ;
  __IM  uint32_t  RESERVED53;
  
  union {
    __IOM uint16_t DMA_CSELR7;                  /*!< Channel7 selection register                                               */
    
    struct {
      __IOM uint16_t CS         : 10;           /*!< This register is used to the DMA channel7                                 */
            uint16_t            : 6;
    } DMA_CSELR7_b;
  } ;
  __IM  uint16_t  RESERVED54;
  __IM  uint32_t  RESERVED55;
  
  union {
    __IOM uint32_t DMA_ISR;                     /*!< Interrupt status register                                                 */
    
    struct {
      __IOM uint32_t GIF0       : 1;            /*!< global interrupt flag for channel0                                        */
      __IOM uint32_t TCIF0      : 1;            /*!< Transfer completion flag for channel0                                     */
      __IOM uint32_t HTIF0      : 1;            /*!< Half transfer flag for channel0                                           */
      __IOM uint32_t TEIF0      : 1;            /*!< Transfer error flag channel0                                              */
      __IOM uint32_t GIF1       : 1;            /*!< global interrupt flag for channel1                                        */
      __IOM uint32_t TCIF1      : 1;            /*!< Transfer completion flag for channel1                                     */
      __IOM uint32_t HTIF1      : 1;            /*!< Half transfer flag for channel1                                           */
      __IOM uint32_t TEIF1      : 1;            /*!< Transfer error flag channel1                                              */
      __IOM uint32_t GIF2       : 1;            /*!< global interrupt flag for channel2                                        */
      __IOM uint32_t TCIF2      : 1;            /*!< Transfer completion flag for channel2                                     */
      __IOM uint32_t HTIF2      : 1;            /*!< Half transfer flag for channel2                                           */
      __IOM uint32_t TEIF2      : 1;            /*!< Transfer error flag channel2                                              */
      __IOM uint32_t GIF3       : 1;            /*!< global interrupt flag for channel3                                        */
      __IOM uint32_t TCIF3      : 1;            /*!< Transfer completion flag for channel3                                     */
      __IOM uint32_t HTIF3      : 1;            /*!< Half transfer flag for channel3                                           */
      __IOM uint32_t TEIF3      : 1;            /*!< Transfer error flag channel3                                              */
      __IOM uint32_t GIF4       : 1;            /*!< global interrupt flag for channel4                                        */
      __IOM uint32_t TCIF4      : 1;            /*!< Transfer completion flag for channel4                                     */
      __IOM uint32_t HTIF4      : 1;            /*!< Half transfer flag for channel4                                           */
      __IOM uint32_t TEIF4      : 1;            /*!< Transfer error flag channel4                                              */
      __IOM uint32_t GIF5       : 1;            /*!< global interrupt flag for channel5                                        */
      __IOM uint32_t TCIF5      : 1;            /*!< Transfer completion flag for channel5                                     */
      __IOM uint32_t HTIF5      : 1;            /*!< Half transfer flag for channel5                                           */
      __IOM uint32_t TEIF5      : 1;            /*!< Transfer error flag channel5                                              */
      __IOM uint32_t GIF6       : 1;            /*!< global interrupt flag for channel6                                        */
      __IOM uint32_t TCIF6      : 1;            /*!< Transfer completion flag for channel6                                     */
      __IOM uint32_t HTIF6      : 1;            /*!< Half transfer flag for channel6                                           */
      __IOM uint32_t TEIF6      : 1;            /*!< Transfer error flag channel6                                              */
      __IOM uint32_t GIF7       : 1;            /*!< global interrupt flag for channel7                                        */
      __IOM uint32_t TCIF7      : 1;            /*!< Transfer completion flag for channel7                                     */
      __IOM uint32_t HTIF7      : 1;            /*!< Half transfer flag for channel7                                           */
      __IOM uint32_t TEIF7      : 1;            /*!< Transfer error flag channel7                                              */
    } DMA_ISR_b;
  } ;
  __IM  uint32_t  RESERVED56;
  
  union {
    __IOM uint32_t DMA_IFCR;                    /*!< Interrupt flag clear register                                             */
    
    struct {
      __IOM uint32_t CGIF0      : 1;            /*!< global interrupt flag clear for channel0                                  */
      __IOM uint32_t CTCIF0     : 1;            /*!< Transfer completion flag clear channel0                                   */
      __IOM uint32_t CHTIF0     : 1;            /*!< Half transfer flag clear channel0                                         */
      __IOM uint32_t CTEIF0     : 1;            /*!< Transfer errorclear channel0                                              */
      __IOM uint32_t CGIF1      : 1;            /*!< global interrupt flag clear for channel1                                  */
      __IOM uint32_t CTCIF1     : 1;            /*!< Transfer completion flag clear channel1                                   */
      __IOM uint32_t CHTIF1     : 1;            /*!< Half transfer flag clear channel1                                         */
      __IOM uint32_t CTEIF1     : 1;            /*!< Transfer error clear channel1                                             */
      __IOM uint32_t CGIF2      : 1;            /*!< global interrupt flag clear for channel0                                  */
      __IOM uint32_t CTCIF2     : 1;            /*!< Transfer completion flag clear channel0                                   */
      __IOM uint32_t CHTIF2     : 1;            /*!< Half transfer flag clear channel2                                         */
      __IOM uint32_t CTEIF2     : 1;            /*!< Transfer errorclear channel2                                              */
      __IOM uint32_t CGIF3      : 1;            /*!< global interrupt flag clear for channel3                                  */
      __IOM uint32_t CTCIF3     : 1;            /*!< Transfer completion flag clear channel3                                   */
      __IOM uint32_t CHTIF3     : 1;            /*!< Half transfer flag clear channel3                                         */
      __IOM uint32_t CTEIF3     : 1;            /*!< Transfer errorclear channel3                                              */
      __IOM uint32_t CGIF4      : 1;            /*!< global interrupt flag clear for channel4                                  */
      __IOM uint32_t CTCIF4     : 1;            /*!< Transfer completion flag clear channel4                                   */
      __IOM uint32_t CHTIF4     : 1;            /*!< Half transfer flag clear channel4                                         */
      __IOM uint32_t CTEIF4     : 1;            /*!< Transfer errorclear channel4                                              */
      __IOM uint32_t CGIF5      : 1;            /*!< global interrupt flag clear for channel5                                  */
      __IOM uint32_t CTCIF5     : 1;            /*!< Transfer completion flag clear channel5                                   */
      __IOM uint32_t CHTIF5     : 1;            /*!< Half transfer flag clear channel5                                         */
      __IOM uint32_t CTEIF5     : 1;            /*!< Transfer errorclear channel5                                              */
      __IOM uint32_t CGIF6      : 1;            /*!< global interrupt flag clear for channel6                                  */
      __IOM uint32_t CTCIF06    : 1;            /*!< Transfer completion flag clear channel6                                   */
      __IOM uint32_t CHTIF6     : 1;            /*!< Half transfer flag clear channel6                                         */
      __IOM uint32_t CTEIF6     : 1;            /*!< Transfer errorclear channel6                                              */
      __IOM uint32_t CGIF7      : 1;            /*!< global interrupt flag clear for channel7                                  */
      __IOM uint32_t CTCIF7     : 1;            /*!< Transfer completion flag clear channel7                                   */
      __IOM uint32_t CHTIF7     : 1;            /*!< Half transfer flag clear channel7                                         */
      __IOM uint32_t CTEIF7     : 1;            /*!< Transfer errorclear channel7                                              */
    } DMA_IFCR_b;
  } ;
} DMA_Type;                                     /*!< Size = 332 (0x14c)                                                        */



/* =========================================================================================================================== */
/* ================                                            ADC                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Analog to Digital Converter. (ADC)
  */

typedef struct {                                /*!< ADC Structure                                                             */
  
  union {
    __IOM uint16_t CTRL;                        /*!< ADC Control register                                                      */
    
    struct {
            uint16_t            : 1;
      __IOM uint16_t INIT       : 1;            /*!< To Initialise the ADC                                                     */
      __IOM uint16_t CHANNEL_SELECT : 3;        /*!< To select the input channel                                               */
      __IOM uint16_t SOC        : 1;            /*!< Start of Conversion                                                       */
      __IOM uint16_t SELRES     : 2;            /*!< ADC resolution                                                            */
      __IOM uint16_t FREE_RUN   : 1;            /*!< To enable free running of reading data from channel.                      */
      __IOM uint16_t INTR_EN    : 1;            /*!< Enable the interrupt                                                      */
      __IOM uint16_t ENCTR      : 3;            /*!< Test pins                                                                 */
      __IOM uint16_t SELBG      : 1;            /*!< Enable external band gap generator                                        */
      __IOM uint16_t SELREF     : 1;            /*!< Enable external refernce voltage                                          */
            uint16_t            : 1;
    } CTRL_b;
  } ;
} ADC_Type;                                     /*!< Size = 2 (0x2)                                                            */



/* =========================================================================================================================== */
/* ================                                            PLL                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Phase Locked Loop - Clock generator (PLL)
  */

typedef struct {                                /*!< PLL Structure                                                             */
  __IOM uint8_t   PLL_axi_lock_enable;          /*!< Writing 1 makes the pll one time configurable                             */
  __IM  uint8_t   RESERVED;
  __IOM uint8_t   PLL_clock_select;             /*!< 2 bit register used to choose one of the 4 available clock frequencies    */
} PLL_Type;                                     /*!< Size = 3 (0x3)                                                            */



/* =========================================================================================================================== */
/* ================                                           PWM                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Pulse-width modulation number 0 (PWM0)
  */

typedef struct {                                /*!< PWM0 Structure                                                            */
  
  union {
    __IOM uint16_t CLOCK_CTRL;                  /*!< Clock prescalar register                                                  */
    
    struct {
      __IOM uint16_t CLK_SRC    : 1;            /*!< PWM clock select bit                                                      */
      __IOM uint16_t CLK_PRESCALAR : 15;        /*!< PWM prescalar value                                                       */
    } CLOCK_CTRL_b;
  } ;
  __IM  uint16_t  RESERVED;
  
  union {
    __IOM uint16_t CTRL;                        /*!< PWM Control register                                                      */
    
    struct {
      __IOM uint16_t CTRL_EN    : 1;            /*!< PWM controller enable flag                                                */
      __IOM uint16_t CTRL_START : 1;            /*!< PWM signal generation start flag                                          */
      __IOM uint16_t CTRL_OUTPUT_EN : 1;        /*!< PWM output enable flag                                                    */
      __IOM uint16_t CTRL_OUTPUT_POLARITY : 1;  /*!< PWM output polarity select flag                                           */
      __IOM uint16_t CTRL_COUNTER_RESET : 1;    /*!< Resets the counter in PWM                                                 */
      __IOM uint16_t CTRL_COMP_OUT_ENABLE : 1;  /*!< PWM Complementary Output                                                  */
      __IOM uint16_t CTRL_HALFPERIOD_INTR_EN : 1;/*!< PWM halfperiod interrupt enable                                          */
      __IOM uint16_t CTRL_FALL_INTR_EN : 1;     /*!< PWM fall interrupt enable                                                 */
      __IOM uint16_t CTRL_RISE_INTR_EN : 1;     /*!< PWM rise interrupt enable                                                 */
      __IOM uint16_t CTRL_HALFPERIOD_INTR : 1;  /*!< PWM halfperiod interrupt bit                                              */
      __IOM uint16_t CTRL_FALL_INTR : 1;        /*!< PWM fall interrupt bit                                                    */
      __IOM uint16_t CTRL_RISE_INTR : 1;        /*!< PWM rise interrupt bit                                                    */
      __IOM uint16_t CTRL_UPDATE_EN : 1;        /*!< When this bit is set, the new values of period and duty cycle
                                                     will be applied                                                           */
            uint16_t            : 3;
    } CTRL_b;
  } ;
  __IM  uint16_t  RESERVED1;
  __IOM uint32_t  PERIOD;                       /*!< PWM period register                                                       */
  __IOM uint32_t  DUTY_CYCLE;                   /*!< PWM Duty_Cycle register                                                   */
  __IOM uint16_t  DEADBAND_DELAY;               /*!< PWM Deadband delay register                                               */
  __IM  uint16_t  RESERVED2;
} PWM_Type;                                    /*!< Size = 20 (0x14)                                                          */



/* =========================================================================================================================== */
/* ================                                           PWM1                                            ================ */
/* =========================================================================================================================== */


// /**
//   * @brief Pulse Width Modulator (PWM1)
//   */

// typedef struct {                                /*!< PWM1 Structure                                                            */
  
//   union {
//     __IOM uint16_t CLOCK_CTRL;                  /*!< Clock prescalar register                                                  */
    
//     struct {
//       __IOM uint16_t CLK_SRC    : 1;            /*!< PWM clock select bit                                                      */
//       __IOM uint16_t CLK_PRESCALAR : 15;        /*!< PWM prescalar value                                                       */
//     } CLOCK_CTRL_b;
//   } ;
//   __IM  uint16_t  RESERVED;
  
//   union {
//     __IOM uint16_t CTRL;                        /*!< PWM Control register                                                      */
    
//     struct {
//       __IOM uint16_t CTRL_EN    : 1;            /*!< PWM controller enable flag                                                */
//       __IOM uint16_t CTRL_START : 1;            /*!< PWM signal generation start flag                                          */
//       __IOM uint16_t CTRL_OUTPUT_EN : 1;        /*!< PWM output enable flag                                                    */
//       __IOM uint16_t CTRL_OUTPUT_POLARITY : 1;  /*!< PWM output polarity select flag                                           */
//       __IOM uint16_t CTRL_COUNTER_RESET : 1;    /*!< Resets the counter in PWM                                                 */
//       __IOM uint16_t CTRL_COMP_OUT_ENABLE : 1;  /*!< PWM Complementary Output                                                  */
//       __IOM uint16_t CTRL_HALFPERIOD_INTR_EN : 1;/*!< PWM halfperiod interrupt enable                                          */
//       __IOM uint16_t CTRL_FALL_INTR_EN : 1;     /*!< PWM fall interrupt enable                                                 */
//       __IOM uint16_t CTRL_RISE_INTR_EN : 1;     /*!< PWM rise interrupt enable                                                 */
//       __IOM uint16_t CTRL_HALFPERIOD_INTR : 1;  /*!< PWM halfperiod interrupt bit                                              */
//       __IOM uint16_t CTRL_FALL_INTR : 1;        /*!< PWM fall interrupt bit                                                    */
//       __IOM uint16_t CTRL_RISE_INTR : 1;        /*!< PWM rise interrupt bit                                                    */
//       __IOM uint16_t CTRL_UPDATE_EN : 1;        /*!< When this bit is set, the new values of period and duty cycle
//                                                      will be applied                                                           */
//             uint16_t            : 3;
//     } CTRL_b;
//   } ;
//   __IM  uint16_t  RESERVED1;
//   __IOM uint32_t  PERIOD;                       /*!< PWM period register                                                       */
//   __IOM uint32_t  DUTY_CYCLE;                   /*!< PWM Duty_Cycle register                                                   */
//   __IOM uint16_t  DEADBAND_DELAY;               /*!< PWM Deadband delay register                                               */
//   __IM  uint16_t  RESERVED2;
// } PWM1_Type;                                    /*!< Size = 20 (0x14)                                                          */



/* =========================================================================================================================== */
/* ================                                           PWM2                                            ================ */
/* =========================================================================================================================== */


// /**
//   * @brief Pulse Width Modulator (PWM2)
//   */

// typedef struct {                                /*!< PWM2 Structure                                                            */
  
//   union {
//     __IOM uint16_t CLOCK_CTRL;                  /*!< Clock prescalar register                                                  */
    
//     struct {
//       __IOM uint16_t CLK_SRC    : 1;            /*!< PWM clock select bit                                                      */
//       __IOM uint16_t CLK_PRESCALAR : 15;        /*!< PWM prescalar value                                                       */
//     } CLOCK_CTRL_b;
//   } ;
//   __IM  uint16_t  RESERVED;
  
//   union {
//     __IOM uint16_t CTRL;                        /*!< PWM Control register                                                      */
    
//     struct {
//       __IOM uint16_t CTRL_EN    : 1;            /*!< PWM controller enable flag                                                */
//       __IOM uint16_t CTRL_START : 1;            /*!< PWM signal generation start flag                                          */
//       __IOM uint16_t CTRL_OUTPUT_EN : 1;        /*!< PWM output enable flag                                                    */
//       __IOM uint16_t CTRL_OUTPUT_POLARITY : 1;  /*!< PWM output polarity select flag                                           */
//       __IOM uint16_t CTRL_COUNTER_RESET : 1;    /*!< Resets the counter in PWM                                                 */
//       __IOM uint16_t CTRL_COMP_OUT_ENABLE : 1;  /*!< PWM Complementary Output                                                  */
//       __IOM uint16_t CTRL_HALFPERIOD_INTR_EN : 1;/*!< PWM halfperiod interrupt enable                                          */
//       __IOM uint16_t CTRL_FALL_INTR_EN : 1;     /*!< PWM fall interrupt enable                                                 */
//       __IOM uint16_t CTRL_RISE_INTR_EN : 1;     /*!< PWM rise interrupt enable                                                 */
//       __IOM uint16_t CTRL_HALFPERIOD_INTR : 1;  /*!< PWM halfperiod interrupt bit                                              */
//       __IOM uint16_t CTRL_FALL_INTR : 1;        /*!< PWM fall interrupt bit                                                    */
//       __IOM uint16_t CTRL_RISE_INTR : 1;        /*!< PWM rise interrupt bit                                                    */
//       __IOM uint16_t CTRL_UPDATE_EN : 1;        /*!< When this bit is set, the new values of period and duty cycle
//                                                      will be applied                                                           */
//             uint16_t            : 3;
//     } CTRL_b;
//   } ;
//   __IM  uint16_t  RESERVED1;
//   __IOM uint32_t  PERIOD;                       /*!< PWM period register                                                       */
//   __IOM uint32_t  DUTY_CYCLE;                   /*!< PWM Duty_Cycle register                                                   */
//   __IOM uint16_t  DEADBAND_DELAY;               /*!< PWM Deadband delay register                                               */
//   __IM  uint16_t  RESERVED2;
// } PWM2_Type;                                    /*!< Size = 20 (0x14)                                                          */



/* =========================================================================================================================== */
/* ================                                           PWM3                                            ================ */
/* =========================================================================================================================== */


// /**
//   * @brief Pulse Width Modulator (PWM3)
//   */

// typedef struct {                                /*!< PWM3 Structure                                                            */
  
//   union {
//     __IOM uint16_t CLOCK_CTRL;                  /*!< Clock prescalar register                                                  */
    
//     struct {
//       __IOM uint16_t CLK_SRC    : 1;            /*!< PWM clock select bit                                                      */
//       __IOM uint16_t CLK_PRESCALAR : 15;        /*!< PWM prescalar value                                                       */
//     } CLOCK_CTRL_b;
//   } ;
//   __IM  uint16_t  RESERVED;
  
//   union {
//     __IOM uint16_t CTRL;                        /*!< PWM Control register                                                      */
    
//     struct {
//       __IOM uint16_t CTRL_EN    : 1;            /*!< PWM controller enable flag                                                */
//       __IOM uint16_t CTRL_START : 1;            /*!< PWM signal generation start flag                                          */
//       __IOM uint16_t CTRL_OUTPUT_EN : 1;        /*!< PWM output enable flag                                                    */
//       __IOM uint16_t CTRL_OUTPUT_POLARITY : 1;  /*!< PWM output polarity select flag                                           */
//       __IOM uint16_t CTRL_COUNTER_RESET : 1;    /*!< Resets the counter in PWM                                                 */
//       __IOM uint16_t CTRL_COMP_OUT_ENABLE : 1;  /*!< PWM Complementary Output                                                  */
//       __IOM uint16_t CTRL_HALFPERIOD_INTR_EN : 1;/*!< PWM halfperiod interrupt enable                                          */
//       __IOM uint16_t CTRL_FALL_INTR_EN : 1;     /*!< PWM fall interrupt enable                                                 */
//       __IOM uint16_t CTRL_RISE_INTR_EN : 1;     /*!< PWM rise interrupt enable                                                 */
//       __IOM uint16_t CTRL_HALFPERIOD_INTR : 1;  /*!< PWM halfperiod interrupt bit                                              */
//       __IOM uint16_t CTRL_FALL_INTR : 1;        /*!< PWM fall interrupt bit                                                    */
//       __IOM uint16_t CTRL_RISE_INTR : 1;        /*!< PWM rise interrupt bit                                                    */
//       __IOM uint16_t CTRL_UPDATE_EN : 1;        /*!< When this bit is set, the new values of period and duty cycle
//                                                      will be applied                                                           */
//             uint16_t            : 3;
//     } CTRL_b;
//   } ;
//   __IM  uint16_t  RESERVED1;
//   __IOM uint32_t  PERIOD;                       /*!< PWM period register                                                       */
//   __IOM uint32_t  DUTY_CYCLE;                   /*!< PWM Duty_Cycle register                                                   */
//   __IOM uint16_t  DEADBAND_DELAY;               /*!< PWM Deadband delay register                                               */
//   __IM  uint16_t  RESERVED2;
// } PWM3_Type;                                    /*!< Size = 20 (0x14)                                                          */



/* =========================================================================================================================== */
/* ================                                           PWM4                                            ================ */
/* =========================================================================================================================== */


// /**
//   * @brief Pulse Width Modulator (PWM4)
//   */

// typedef struct {                                /*!< PWM4 Structure                                                            */
  
//   union {
//     __IOM uint16_t CLOCK_CTRL;                  /*!< Clock prescalar register                                                  */
    
//     struct {
//       __IOM uint16_t CLK_SRC    : 1;            /*!< PWM clock select bit                                                      */
//       __IOM uint16_t CLK_PRESCALAR : 15;        /*!< PWM prescalar value                                                       */
//     } CLOCK_CTRL_b;
//   } ;
//   __IM  uint16_t  RESERVED;
  
//   union {
//     __IOM uint16_t CTRL;                        /*!< PWM Control register                                                      */
    
//     struct {
//       __IOM uint16_t CTRL_EN    : 1;            /*!< PWM controller enable flag                                                */
//       __IOM uint16_t CTRL_START : 1;            /*!< PWM signal generation start flag                                          */
//       __IOM uint16_t CTRL_OUTPUT_EN : 1;        /*!< PWM output enable flag                                                    */
//       __IOM uint16_t CTRL_OUTPUT_POLARITY : 1;  /*!< PWM output polarity select flag                                           */
//       __IOM uint16_t CTRL_COUNTER_RESET : 1;    /*!< Resets the counter in PWM                                                 */
//       __IOM uint16_t CTRL_COMP_OUT_ENABLE : 1;  /*!< PWM Complementary Output                                                  */
//       __IOM uint16_t CTRL_HALFPERIOD_INTR_EN : 1;/*!< PWM halfperiod interrupt enable                                          */
//       __IOM uint16_t CTRL_FALL_INTR_EN : 1;     /*!< PWM fall interrupt enable                                                 */
//       __IOM uint16_t CTRL_RISE_INTR_EN : 1;     /*!< PWM rise interrupt enable                                                 */
//       __IOM uint16_t CTRL_HALFPERIOD_INTR : 1;  /*!< PWM halfperiod interrupt bit                                              */
//       __IOM uint16_t CTRL_FALL_INTR : 1;        /*!< PWM fall interrupt bit                                                    */
//       __IOM uint16_t CTRL_RISE_INTR : 1;        /*!< PWM rise interrupt bit                                                    */
//       __IOM uint16_t CTRL_UPDATE_EN : 1;        /*!< When this bit is set, the new values of period and duty cycle
//                                                      will be applied                                                           */
//             uint16_t            : 3;
//     } CTRL_b;
//   } ;
//   __IM  uint16_t  RESERVED1;
//   __IOM uint32_t  PERIOD;                       /*!< PWM period register                                                       */
//   __IOM uint32_t  DUTY_CYCLE;                   /*!< PWM Duty_Cycle register                                                   */
//   __IOM uint16_t  DEADBAND_DELAY;               /*!< PWM Deadband delay register                                               */
//   __IM  uint16_t  RESERVED2;
// } PWM4_Type;                                    /*!< Size = 20 (0x14)                                                          */



/* =========================================================================================================================== */
/* ================                                           PWM5                                            ================ */
/* =========================================================================================================================== */


// /**
//   * @brief Pulse Width Modulator (PWM5)
//   */

// typedef struct {                                /*!< PWM5 Structure                                                            */
  
//   union {
//     __IOM uint16_t CLOCK_CTRL;                  /*!< Clock prescalar register                                                  */
    
//     struct {
//       __IOM uint16_t CLK_SRC    : 1;            /*!< PWM clock select bit                                                      */
//       __IOM uint16_t CLK_PRESCALAR : 15;        /*!< PWM prescalar value                                                       */
//     } CLOCK_CTRL_b;
//   } ;
//   __IM  uint16_t  RESERVED;
  
//   union {
//     __IOM uint16_t CTRL;                        /*!< PWM Control register                                                      */
    
//     struct {
//       __IOM uint16_t CTRL_EN    : 1;            /*!< PWM controller enable flag                                                */
//       __IOM uint16_t CTRL_START : 1;            /*!< PWM signal generation start flag                                          */
//       __IOM uint16_t CTRL_OUTPUT_EN : 1;        /*!< PWM output enable flag                                                    */
//       __IOM uint16_t CTRL_OUTPUT_POLARITY : 1;  /*!< PWM output polarity select flag                                           */
//       __IOM uint16_t CTRL_COUNTER_RESET : 1;    /*!< Resets the counter in PWM                                                 */
//       __IOM uint16_t CTRL_COMP_OUT_ENABLE : 1;  /*!< PWM Complementary Output                                                  */
//       __IOM uint16_t CTRL_HALFPERIOD_INTR_EN : 1;/*!< PWM halfperiod interrupt enable                                          */
//       __IOM uint16_t CTRL_FALL_INTR_EN : 1;     /*!< PWM fall interrupt enable                                                 */
//       __IOM uint16_t CTRL_RISE_INTR_EN : 1;     /*!< PWM rise interrupt enable                                                 */
//       __IOM uint16_t CTRL_HALFPERIOD_INTR : 1;  /*!< PWM halfperiod interrupt bit                                              */
//       __IOM uint16_t CTRL_FALL_INTR : 1;        /*!< PWM fall interrupt bit                                                    */
//       __IOM uint16_t CTRL_RISE_INTR : 1;        /*!< PWM rise interrupt bit                                                    */
//       __IOM uint16_t CTRL_UPDATE_EN : 1;        /*!< When this bit is set, the new values of period and duty cycle
//                                                      will be applied                                                           */
//             uint16_t            : 3;
//     } CTRL_b;
//   } ;
//   __IM  uint16_t  RESERVED1;
//   __IOM uint32_t  PERIOD;                       /*!< PWM period register                                                       */
//   __IOM uint32_t  DUTY_CYCLE;                   /*!< PWM Duty_Cycle register                                                   */
//   __IOM uint16_t  DEADBAND_DELAY;               /*!< PWM Deadband delay register                                               */
//   __IM  uint16_t  RESERVED2;
// } PWM5_Type;                                    /*!< Size = 20 (0x14)                                                          */



/* =========================================================================================================================== */
/* ================                                           PWM6                                            ================ */
/* =========================================================================================================================== */


// /**
//   * @brief Pulse Width Modulator (PWM6)
//   */

// typedef struct {                                /*!< PWM6 Structure                                                            */
  
//   union {
//     __IOM uint16_t CLOCK_CTRL;                  /*!< Clock prescalar register                                                  */
    
//     struct {
//       __IOM uint16_t CLK_SRC    : 1;            /*!< PWM clock select bit                                                      */
//       __IOM uint16_t CLK_PRESCALAR : 15;        /*!< PWM prescalar value                                                       */
//     } CLOCK_CTRL_b;
//   } ;
//   __IM  uint16_t  RESERVED;
  
//   union {
//     __IOM uint16_t CTRL;                        /*!< PWM Control register                                                      */
    
//     struct {
//       __IOM uint16_t CTRL_EN    : 1;            /*!< PWM controller enable flag                                                */
//       __IOM uint16_t CTRL_START : 1;            /*!< PWM signal generation start flag                                          */
//       __IOM uint16_t CTRL_OUTPUT_EN : 1;        /*!< PWM output enable flag                                                    */
//       __IOM uint16_t CTRL_OUTPUT_POLARITY : 1;  /*!< PWM output polarity select flag                                           */
//       __IOM uint16_t CTRL_COUNTER_RESET : 1;    /*!< Resets the counter in PWM                                                 */
//       __IOM uint16_t CTRL_COMP_OUT_ENABLE : 1;  /*!< PWM Complementary Output                                                  */
//       __IOM uint16_t CTRL_HALFPERIOD_INTR_EN : 1;/*!< PWM halfperiod interrupt enable                                          */
//       __IOM uint16_t CTRL_FALL_INTR_EN : 1;     /*!< PWM fall interrupt enable                                                 */
//       __IOM uint16_t CTRL_RISE_INTR_EN : 1;     /*!< PWM rise interrupt enable                                                 */
//       __IOM uint16_t CTRL_HALFPERIOD_INTR : 1;  /*!< PWM halfperiod interrupt bit                                              */
//       __IOM uint16_t CTRL_FALL_INTR : 1;        /*!< PWM fall interrupt bit                                                    */
//       __IOM uint16_t CTRL_RISE_INTR : 1;        /*!< PWM rise interrupt bit                                                    */
//       __IOM uint16_t CTRL_UPDATE_EN : 1;        /*!< When this bit is set, the new values of period and duty cycle
//                                                      will be applied                                                           */
//             uint16_t            : 3;
//     } CTRL_b;
//   } ;
//   __IM  uint16_t  RESERVED1;
//   __IOM uint32_t  PERIOD;                       /*!< PWM period register                                                       */
//   __IOM uint32_t  DUTY_CYCLE;                   /*!< PWM Duty_Cycle register                                                   */
//   __IOM uint16_t  DEADBAND_DELAY;               /*!< PWM Deadband delay register                                               */
//   __IM  uint16_t  RESERVED2;
// } PWM6_Type;                                    /*!< Size = 20 (0x14)                                                          */



/* =========================================================================================================================== */
/* ================                                           PWM7                                            ================ */
/* =========================================================================================================================== */


// /**
//   * @brief Pulse Width Modulator (PWM7)
//   */

// typedef struct {                                /*!< PWM7 Structure                                                            */
  
//   union {
//     __IOM uint16_t CLOCK_CTRL;                  /*!< Clock prescalar register                                                  */
    
//     struct {
//       __IOM uint16_t CLK_SRC    : 1;            /*!< PWM clock select bit                                                      */
//       __IOM uint16_t CLK_PRESCALAR : 15;        /*!< PWM prescalar value                                                       */
//     } CLOCK_CTRL_b;
//   } ;
//   __IM  uint16_t  RESERVED;
  
//   union {
//     __IOM uint16_t CTRL;                        /*!< PWM Control register                                                      */
    
//     struct {
//       __IOM uint16_t CTRL_EN    : 1;            /*!< PWM controller enable flag                                                */
//       __IOM uint16_t CTRL_START : 1;            /*!< PWM signal generation start flag                                          */
//       __IOM uint16_t CTRL_OUTPUT_EN : 1;        /*!< PWM output enable flag                                                    */
//       __IOM uint16_t CTRL_OUTPUT_POLARITY : 1;  /*!< PWM output polarity select flag                                           */
//       __IOM uint16_t CTRL_COUNTER_RESET : 1;    /*!< Resets the counter in PWM                                                 */
//       __IOM uint16_t CTRL_COMP_OUT_ENABLE : 1;  /*!< PWM Complementary Output                                                  */
//       __IOM uint16_t CTRL_HALFPERIOD_INTR_EN : 1;/*!< PWM halfperiod interrupt enable                                          */
//       __IOM uint16_t CTRL_FALL_INTR_EN : 1;     /*!< PWM fall interrupt enable                                                 */
//       __IOM uint16_t CTRL_RISE_INTR_EN : 1;     /*!< PWM rise interrupt enable                                                 */
//       __IOM uint16_t CTRL_HALFPERIOD_INTR : 1;  /*!< PWM halfperiod interrupt bit                                              */
//       __IOM uint16_t CTRL_FALL_INTR : 1;        /*!< PWM fall interrupt bit                                                    */
//       __IOM uint16_t CTRL_RISE_INTR : 1;        /*!< PWM rise interrupt bit                                                    */
//       __IOM uint16_t CTRL_UPDATE_EN : 1;        /*!< When this bit is set, the new values of period and duty cycle
//                                                      will be applied                                                           */
//             uint16_t            : 3;
//     } CTRL_b;
//   } ;
//   __IM  uint16_t  RESERVED1;
//   __IOM uint32_t  PERIOD;                       /*!< PWM period register                                                       */
//   __IOM uint32_t  DUTY_CYCLE;                   /*!< PWM Duty_Cycle register                                                   */
//   __IOM uint16_t  DEADBAND_DELAY;               /*!< PWM Deadband delay register                                               */
//   __IM  uint16_t  RESERVED2;
// } PWM7_Type;                                    /*!< Size = 20 (0x14)                                                          */



/* =========================================================================================================================== */
/* ================                                           PWM8                                            ================ */
/* =========================================================================================================================== */


// /**
//   * @brief Pulse Width Modulator (PWM8)
//   */

// typedef struct {                                /*!< PWM8 Structure                                                            */
  
//   union {
//     __IOM uint16_t CLOCK_CTRL;                  /*!< Clock prescalar register                                                  */
    
//     struct {
//       __IOM uint16_t CLK_SRC    : 1;            /*!< PWM clock select bit                                                      */
//       __IOM uint16_t CLK_PRESCALAR : 15;        /*!< PWM prescalar value                                                       */
//     } CLOCK_CTRL_b;
//   } ;
//   __IM  uint16_t  RESERVED;
  
//   union {
//     __IOM uint16_t CTRL;                        /*!< PWM Control register                                                      */
    
//     struct {
//       __IOM uint16_t CTRL_EN    : 1;            /*!< PWM controller enable flag                                                */
//       __IOM uint16_t CTRL_START : 1;            /*!< PWM signal generation start flag                                          */
//       __IOM uint16_t CTRL_OUTPUT_EN : 1;        /*!< PWM output enable flag                                                    */
//       __IOM uint16_t CTRL_OUTPUT_POLARITY : 1;  /*!< PWM output polarity select flag                                           */
//       __IOM uint16_t CTRL_COUNTER_RESET : 1;    /*!< Resets the counter in PWM                                                 */
//       __IOM uint16_t CTRL_COMP_OUT_ENABLE : 1;  /*!< PWM Complementary Output                                                  */
//       __IOM uint16_t CTRL_HALFPERIOD_INTR_EN : 1;/*!< PWM halfperiod interrupt enable                                          */
//       __IOM uint16_t CTRL_FALL_INTR_EN : 1;     /*!< PWM fall interrupt enable                                                 */
//       __IOM uint16_t CTRL_RISE_INTR_EN : 1;     /*!< PWM rise interrupt enable                                                 */
//       __IOM uint16_t CTRL_HALFPERIOD_INTR : 1;  /*!< PWM halfperiod interrupt bit                                              */
//       __IOM uint16_t CTRL_FALL_INTR : 1;        /*!< PWM fall interrupt bit                                                    */
//       __IOM uint16_t CTRL_RISE_INTR : 1;        /*!< PWM rise interrupt bit                                                    */
//       __IOM uint16_t CTRL_UPDATE_EN : 1;        /*!< When this bit is set, the new values of period and duty cycle
//                                                      will be applied                                                           */
//             uint16_t            : 3;
//     } CTRL_b;
//   } ;
//   __IM  uint16_t  RESERVED1;
//   __IOM uint32_t  PERIOD;                       /*!< PWM period register                                                       */
//   __IOM uint32_t  DUTY_CYCLE;                   /*!< PWM Duty_Cycle register                                                   */
//   __IOM uint16_t  DEADBAND_DELAY;               /*!< PWM Deadband delay register                                               */
//   __IM  uint16_t  RESERVED2;
// } PWM8_Type;                                    /*!< Size = 20 (0x14)                                                          */



/* =========================================================================================================================== */
/* ================                                           PWM9                                            ================ */
/* =========================================================================================================================== */


// /**
//   * @brief Pulse Width Modulator (PWM9)
//   */

// typedef struct {                                /*!< PWM9 Structure                                                            */
  
//   union {
//     __IOM uint16_t CLOCK_CTRL;                  /*!< Clock prescalar register                                                  */
    
//     struct {
//       __IOM uint16_t CLK_SRC    : 1;            /*!< PWM clock select bit                                                      */
//       __IOM uint16_t CLK_PRESCALAR : 15;        /*!< PWM prescalar value                                                       */
//     } CLOCK_CTRL_b;
//   } ;
//   __IM  uint16_t  RESERVED;
  
//   union {
//     __IOM uint16_t CTRL;                        /*!< PWM Control register                                                      */
    
//     struct {
//       __IOM uint16_t CTRL_EN    : 1;            /*!< PWM controller enable flag                                                */
//       __IOM uint16_t CTRL_START : 1;            /*!< PWM signal generation start flag                                          */
//       __IOM uint16_t CTRL_OUTPUT_EN : 1;        /*!< PWM output enable flag                                                    */
//       __IOM uint16_t CTRL_OUTPUT_POLARITY : 1;  /*!< PWM output polarity select flag                                           */
//       __IOM uint16_t CTRL_COUNTER_RESET : 1;    /*!< Resets the counter in PWM                                                 */
//       __IOM uint16_t CTRL_COMP_OUT_ENABLE : 1;  /*!< PWM Complementary Output                                                  */
//       __IOM uint16_t CTRL_HALFPERIOD_INTR_EN : 1;/*!< PWM halfperiod interrupt enable                                          */
//       __IOM uint16_t CTRL_FALL_INTR_EN : 1;     /*!< PWM fall interrupt enable                                                 */
//       __IOM uint16_t CTRL_RISE_INTR_EN : 1;     /*!< PWM rise interrupt enable                                                 */
//       __IOM uint16_t CTRL_HALFPERIOD_INTR : 1;  /*!< PWM halfperiod interrupt bit                                              */
//       __IOM uint16_t CTRL_FALL_INTR : 1;        /*!< PWM fall interrupt bit                                                    */
//       __IOM uint16_t CTRL_RISE_INTR : 1;        /*!< PWM rise interrupt bit                                                    */
//       __IOM uint16_t CTRL_UPDATE_EN : 1;        /*!< When this bit is set, the new values of period and duty cycle
//                                                      will be applied                                                           */
//             uint16_t            : 3;
//     } CTRL_b;
//   } ;
//   __IM  uint16_t  RESERVED1;
//   __IOM uint32_t  PERIOD;                       /*!< PWM period register                                                       */
//   __IOM uint32_t  DUTY_CYCLE;                   /*!< PWM Duty_Cycle register                                                   */
//   __IOM uint16_t  DEADBAND_DELAY;               /*!< PWM Deadband delay register                                               */
//   __IM  uint16_t  RESERVED2;
// } PWM9_Type;                                    /*!< Size = 20 (0x14)                                                          */



/* =========================================================================================================================== */
/* ================                                           PWM10                                           ================ */
/* =========================================================================================================================== */


// /**
//   * @brief Pulse Width Modulator (PWM10)
//   */

// typedef struct {                                /*!< PWM10 Structure                                                           */
  
//   union {
//     __IOM uint16_t CLOCK_CTRL;                  /*!< Clock prescalar register                                                  */
    
//     struct {
//       __IOM uint16_t CLK_SRC    : 1;            /*!< PWM clock select bit                                                      */
//       __IOM uint16_t CLK_PRESCALAR : 15;        /*!< PWM prescalar value                                                       */
//     } CLOCK_CTRL_b;
//   } ;
//   __IM  uint16_t  RESERVED;
  
//   union {
//     __IOM uint16_t CTRL;                        /*!< PWM Control register                                                      */
    
//     struct {
//       __IOM uint16_t CTRL_EN    : 1;            /*!< PWM controller enable flag                                                */
//       __IOM uint16_t CTRL_START : 1;            /*!< PWM signal generation start flag                                          */
//       __IOM uint16_t CTRL_OUTPUT_EN : 1;        /*!< PWM output enable flag                                                    */
//       __IOM uint16_t CTRL_OUTPUT_POLARITY : 1;  /*!< PWM output polarity select flag                                           */
//       __IOM uint16_t CTRL_COUNTER_RESET : 1;    /*!< Resets the counter in PWM                                                 */
//       __IOM uint16_t CTRL_COMP_OUT_ENABLE : 1;  /*!< PWM Complementary Output                                                  */
//       __IOM uint16_t CTRL_HALFPERIOD_INTR_EN : 1;/*!< PWM halfperiod interrupt enable                                          */
//       __IOM uint16_t CTRL_FALL_INTR_EN : 1;     /*!< PWM fall interrupt enable                                                 */
//       __IOM uint16_t CTRL_RISE_INTR_EN : 1;     /*!< PWM rise interrupt enable                                                 */
//       __IOM uint16_t CTRL_HALFPERIOD_INTR : 1;  /*!< PWM halfperiod interrupt bit                                              */
//       __IOM uint16_t CTRL_FALL_INTR : 1;        /*!< PWM fall interrupt bit                                                    */
//       __IOM uint16_t CTRL_RISE_INTR : 1;        /*!< PWM rise interrupt bit                                                    */
//       __IOM uint16_t CTRL_UPDATE_EN : 1;        /*!< When this bit is set, the new values of period and duty cycle
//                                                      will be applied                                                           */
//             uint16_t            : 3;
//     } CTRL_b;
//   } ;
//   __IM  uint16_t  RESERVED1;
//   __IOM uint32_t  PERIOD;                       /*!< PWM period register                                                       */
//   __IOM uint32_t  DUTY_CYCLE;                   /*!< PWM Duty_Cycle register                                                   */
//   __IOM uint16_t  DEADBAND_DELAY;               /*!< PWM Deadband delay register                                               */
//   __IM  uint16_t  RESERVED2;
// } PWM10_Type;                                   /*!< Size = 20 (0x14)                                                          */



/* =========================================================================================================================== */
/* ================                                           PWM11                                           ================ */
/* =========================================================================================================================== */


// /**
//   * @brief Pulse Width Modulator (PWM11)
//   */

// typedef struct {                                /*!< PWM11 Structure                                                           */
  
//   union {
//     __IOM uint16_t CLOCK_CTRL;                  /*!< Clock prescalar register                                                  */
    
//     struct {
//       __IOM uint16_t CLK_SRC    : 1;            /*!< PWM clock select bit                                                      */
//       __IOM uint16_t CLK_PRESCALAR : 15;        /*!< PWM prescalar value                                                       */
//     } CLOCK_CTRL_b;
//   } ;
//   __IM  uint16_t  RESERVED;
  
//   union {
//     __IOM uint16_t CTRL;                        /*!< PWM Control register                                                      */
    
//     struct {
//       __IOM uint16_t CTRL_EN    : 1;            /*!< PWM controller enable flag                                                */
//       __IOM uint16_t CTRL_START : 1;            /*!< PWM signal generation start flag                                          */
//       __IOM uint16_t CTRL_OUTPUT_EN : 1;        /*!< PWM output enable flag                                                    */
//       __IOM uint16_t CTRL_OUTPUT_POLARITY : 1;  /*!< PWM output polarity select flag                                           */
//       __IOM uint16_t CTRL_COUNTER_RESET : 1;    /*!< Resets the counter in PWM                                                 */
//       __IOM uint16_t CTRL_COMP_OUT_ENABLE : 1;  /*!< PWM Complementary Output                                                  */
//       __IOM uint16_t CTRL_HALFPERIOD_INTR_EN : 1;/*!< PWM halfperiod interrupt enable                                          */
//       __IOM uint16_t CTRL_FALL_INTR_EN : 1;     /*!< PWM fall interrupt enable                                                 */
//       __IOM uint16_t CTRL_RISE_INTR_EN : 1;     /*!< PWM rise interrupt enable                                                 */
//       __IOM uint16_t CTRL_HALFPERIOD_INTR : 1;  /*!< PWM halfperiod interrupt bit                                              */
//       __IOM uint16_t CTRL_FALL_INTR : 1;        /*!< PWM fall interrupt bit                                                    */
//       __IOM uint16_t CTRL_RISE_INTR : 1;        /*!< PWM rise interrupt bit                                                    */
//       __IOM uint16_t CTRL_UPDATE_EN : 1;        /*!< When this bit is set, the new values of period and duty cycle
//                                                      will be applied                                                           */
//             uint16_t            : 3;
//     } CTRL_b;
//   } ;
//   __IM  uint16_t  RESERVED1;
//   __IOM uint32_t  PERIOD;                       /*!< PWM period register                                                       */
//   __IOM uint32_t  DUTY_CYCLE;                   /*!< PWM Duty_Cycle register                                                   */
//   __IOM uint16_t  DEADBAND_DELAY;               /*!< PWM Deadband delay register                                               */
//   __IM  uint16_t  RESERVED2;
// } PWM11_Type;                                   /*!< Size = 20 (0x14)                                                          */



/* =========================================================================================================================== */
/* ================                                           PWM12                                           ================ */
/* =========================================================================================================================== */


// /**
//   * @brief Pulse Width Modulator (PWM12)
//   */

// typedef struct {                                /*!< PWM12 Structure                                                           */
  
//   union {
//     __IOM uint16_t CLOCK_CTRL;                  /*!< Clock prescalar register                                                  */
    
//     struct {
//       __IOM uint16_t CLK_SRC    : 1;            /*!< PWM clock select bit                                                      */
//       __IOM uint16_t CLK_PRESCALAR : 15;        /*!< PWM prescalar value                                                       */
//     } CLOCK_CTRL_b;
//   } ;
//   __IM  uint16_t  RESERVED;
  
//   union {
//     __IOM uint16_t CTRL;                        /*!< PWM Control register                                                      */
    
//     struct {
//       __IOM uint16_t CTRL_EN    : 1;            /*!< PWM controller enable flag                                                */
//       __IOM uint16_t CTRL_START : 1;            /*!< PWM signal generation start flag                                          */
//       __IOM uint16_t CTRL_OUTPUT_EN : 1;        /*!< PWM output enable flag                                                    */
//       __IOM uint16_t CTRL_OUTPUT_POLARITY : 1;  /*!< PWM output polarity select flag                                           */
//       __IOM uint16_t CTRL_COUNTER_RESET : 1;    /*!< Resets the counter in PWM                                                 */
//       __IOM uint16_t CTRL_COMP_OUT_ENABLE : 1;  /*!< PWM Complementary Output                                                  */
//       __IOM uint16_t CTRL_HALFPERIOD_INTR_EN : 1;/*!< PWM halfperiod interrupt enable                                          */
//       __IOM uint16_t CTRL_FALL_INTR_EN : 1;     /*!< PWM fall interrupt enable                                                 */
//       __IOM uint16_t CTRL_RISE_INTR_EN : 1;     /*!< PWM rise interrupt enable                                                 */
//       __IOM uint16_t CTRL_HALFPERIOD_INTR : 1;  /*!< PWM halfperiod interrupt bit                                              */
//       __IOM uint16_t CTRL_FALL_INTR : 1;        /*!< PWM fall interrupt bit                                                    */
//       __IOM uint16_t CTRL_RISE_INTR : 1;        /*!< PWM rise interrupt bit                                                    */
//       __IOM uint16_t CTRL_UPDATE_EN : 1;        /*!< When this bit is set, the new values of period and duty cycle
//                                                      will be applied                                                           */
//             uint16_t            : 3;
//     } CTRL_b;
//   } ;
//   __IM  uint16_t  RESERVED1;
//   __IOM uint32_t  PERIOD;                       /*!< PWM period register                                                       */
//   __IOM uint32_t  DUTY_CYCLE;                   /*!< PWM Duty_Cycle register                                                   */
//   __IOM uint16_t  DEADBAND_DELAY;               /*!< PWM Deadband delay register                                               */
//   __IM  uint16_t  RESERVED2;
// } PWM12_Type;                                   /*!< Size = 20 (0x14)                                                          */



/* =========================================================================================================================== */
/* ================                                           PWM13                                           ================ */
/* =========================================================================================================================== */


// /**
//   * @brief Pulse Width Modulator (PWM13)
//   */

// typedef struct {                                /*!< PWM13 Structure                                                           */
  
//   union {
//     __IOM uint16_t CLOCK_CTRL;                  /*!< Clock prescalar register                                                  */
    
//     struct {
//       __IOM uint16_t CLK_SRC    : 1;            /*!< PWM clock select bit                                                      */
//       __IOM uint16_t CLK_PRESCALAR : 15;        /*!< PWM prescalar value                                                       */
//     } CLOCK_CTRL_b;
//   } ;
//   __IM  uint16_t  RESERVED;
  
//   union {
//     __IOM uint16_t CTRL;                        /*!< PWM Control register                                                      */
    
//     struct {
//       __IOM uint16_t CTRL_EN    : 1;            /*!< PWM controller enable flag                                                */
//       __IOM uint16_t CTRL_START : 1;            /*!< PWM signal generation start flag                                          */
//       __IOM uint16_t CTRL_OUTPUT_EN : 1;        /*!< PWM output enable flag                                                    */
//       __IOM uint16_t CTRL_OUTPUT_POLARITY : 1;  /*!< PWM output polarity select flag                                           */
//       __IOM uint16_t CTRL_COUNTER_RESET : 1;    /*!< Resets the counter in PWM                                                 */
//       __IOM uint16_t CTRL_COMP_OUT_ENABLE : 1;  /*!< PWM Complementary Output                                                  */
//       __IOM uint16_t CTRL_HALFPERIOD_INTR_EN : 1;/*!< PWM halfperiod interrupt enable                                          */
//       __IOM uint16_t CTRL_FALL_INTR_EN : 1;     /*!< PWM fall interrupt enable                                                 */
//       __IOM uint16_t CTRL_RISE_INTR_EN : 1;     /*!< PWM rise interrupt enable                                                 */
//       __IOM uint16_t CTRL_HALFPERIOD_INTR : 1;  /*!< PWM halfperiod interrupt bit                                              */
//       __IOM uint16_t CTRL_FALL_INTR : 1;        /*!< PWM fall interrupt bit                                                    */
//       __IOM uint16_t CTRL_RISE_INTR : 1;        /*!< PWM rise interrupt bit                                                    */
//       __IOM uint16_t CTRL_UPDATE_EN : 1;        /*!< When this bit is set, the new values of period and duty cycle
//                                                      will be applied                                                           */
//             uint16_t            : 3;
//     } CTRL_b;
//   } ;
//   __IM  uint16_t  RESERVED1;
//   __IOM uint32_t  PERIOD;                       /*!< PWM period register                                                       */
//   __IOM uint32_t  DUTY_CYCLE;                   /*!< PWM Duty_Cycle register                                                   */
//   __IOM uint16_t  DEADBAND_DELAY;               /*!< PWM Deadband delay register                                               */
//   __IM  uint16_t  RESERVED2;
// } PWM13_Type;                                   /*!< Size = 20 (0x14)                                                          */



/* =========================================================================================================================== */
/* ================                                         GPTIMER                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief General purpose timer (GPTIMER0)
  */

typedef struct {                                /*!< GPTIMER0 Structure                                                        */
  
  union {
    __IOM uint16_t CTRL;                        /*!< Control register                                                          */
    
    struct {
      __IOM uint16_t CTRL_EN    : 1;            /*!< Timer enable flag                                                         */
            uint16_t            : 1;
      __IOM uint16_t CTRL_MODE  : 2;            /*!< Timer mode select: 0=PWM, 1=Down, 2=Up, 3=UpDown                          */
      __IOM uint16_t CTRL_OUTPUT_EN : 1;        /*!< Timer output enable bit                                                   */
      __IOM uint16_t CTRL_COUNT_RESET : 1;      /*!< Timer counter reset bit                                                   */
      __IOM uint16_t CTRL_CNT_COUNT_EN : 1;     /*!< Timer continuous count enable                                             */
      __IOM uint16_t CTRL_PWM_FALL_INTR_EN : 1; /*!< PWM fall interupt enable                                                  */
      __IOM uint16_t CTRL_PWM_RISE_INTR_EN : 1; /*!< PWM rise interupt enable                                                  */
      __IOM uint16_t CTRL_OFLOW_INTR_EN : 1;    /*!< Counter overflow interrupt enable                                         */
      __IOM uint16_t CTRL_UFLOW_INTR_EN : 1;    /*!< Counter underflow interrupt enable                                        */
      __IM  uint16_t CTRL_PWM_FALL_INTR : 1;    /*!< PWM fall interupt bit                                                     */
      __IM  uint16_t CTRL_PWM_RISE_INTR : 1;    /*!< PWM rise interupt bit                                                     */
      __IM  uint16_t CTRL_OFLOW_INTR : 1;       /*!< Counter overflow interrupt bit                                            */
      __IM  uint16_t CTRL_UFLOW_INTR : 1;       /*!< Counter underflow interrupt bit                                           */
      __IOM uint16_t CTRL_CAPTURE_INP_EN : 1;   /*!< Counter capture input enable                                              */
    } CTRL_b;
  } ;
  __IM  uint16_t  RESERVED;
  
  union {
    __IOM uint32_t CLOCK_CTRL;                  /*!< Clock control register                                                    */
    
    struct {
      __IOM uint32_t CLK_SRC    : 1;            /*!< GPTIMER clock select bit                                                  */
      __IOM uint32_t CLK_PRESCALAR : 16;        /*!< GPTIMER prescalar value                                                   */
      __IOM uint32_t UPDATE_EN  : 1;            /*!< GPTIMER update enable                                                     */
            uint32_t            : 14;
    } CLOCK_CTRL_b;
  } ;
  __IM  uint32_t  COUNT;                        /*!< Counter register                                                          */
  __IM  uint32_t  RPTD_COUNT;                   /*!< Repeated count register                                                   */
  __IOM uint32_t  DUTY_CYCLE;                   /*!< PWM duty cycle register                                                   */
  __IOM uint32_t  PERIOD;                       /*!< PWM period register                                                       */
  __IOM uint32_t  CAPTURE_INP;                  /*!< Timer capture input register                                              */
} GPTIMER_Type;                                /*!< Size = 28 (0x1c)                                                          */



/* =========================================================================================================================== */
/* ================                                         GPTIMER1                                          ================ */
/* =========================================================================================================================== */


// /**
//   * @brief General Purpose Timer (GPTIMER1)
//   */

// typedef struct {                                /*!< GPTIMER1 Structure                                                        */
  
//   union {
//     __IOM uint16_t CTRL;                        /*!< Control register                                                          */
    
//     struct {
//       __IOM uint16_t CTRL_EN    : 1;            /*!< Timer enable flag                                                         */
//             uint16_t            : 1;
//       __IOM uint16_t CTRL_MODE  : 2;            /*!< Timer mode select: 0=PWM, 1=Down, 2=Up, 3=UpDown                          */
//       __IOM uint16_t CTRL_OUTPUT_EN : 1;        /*!< Timer output enable bit                                                   */
//       __IOM uint16_t CTRL_COUNT_RESET : 1;      /*!< Timer counter reset bit                                                   */
//       __IOM uint16_t CTRL_CNT_COUNT_EN : 1;     /*!< Timer continuous count enable                                             */
//       __IOM uint16_t CTRL_PWM_FALL_INTR_EN : 1; /*!< PWM fall interupt enable                                                  */
//       __IOM uint16_t CTRL_PWM_RISE_INTR_EN : 1; /*!< PWM rise interupt enable                                                  */
//       __IOM uint16_t CTRL_OFLOW_INTR_EN : 1;    /*!< Counter overflow interrupt enable                                         */
//       __IOM uint16_t CTRL_UFLOW_INTR_EN : 1;    /*!< Counter underflow interrupt enable                                        */
//       __IM  uint16_t CTRL_PWM_FALL_INTR : 1;    /*!< PWM fall interupt bit                                                     */
//       __IM  uint16_t CTRL_PWM_RISE_INTR : 1;    /*!< PWM rise interupt bit                                                     */
//       __IM  uint16_t CTRL_OFLOW_INTR : 1;       /*!< Counter overflow interrupt bit                                            */
//       __IM  uint16_t CTRL_UFLOW_INTR : 1;       /*!< Counter underflow interrupt bit                                           */
//       __IOM uint16_t CTRL_CAPTURE_INP_EN : 1;   /*!< Counter capture input enable                                              */
//     } CTRL_b;
//   } ;
//   __IM  uint16_t  RESERVED;
  
//   union {
//     __IOM uint32_t CLOCK_CTRL;                  /*!< Clock control register                                                    */
    
//     struct {
//       __IOM uint32_t CLK_SRC    : 1;            /*!< GPTIMER clock select bit                                                  */
//       __IOM uint32_t CLK_PRESCALAR : 16;        /*!< GPTIMER prescalar value                                                   */
//       __IOM uint32_t UPDATE_EN  : 1;            /*!< GPTIMER update enable                                                     */
//             uint32_t            : 14;
//     } CLOCK_CTRL_b;
//   } ;
//   __IM  uint32_t  COUNT;                        /*!< Counter register                                                          */
//   __IM  uint32_t  RPTD_COUNT;                   /*!< Repeated count register                                                   */
//   __IOM uint32_t  DUTY_CYCLE;                   /*!< PWM duty cycle register                                                   */
//   __IOM uint32_t  PERIOD;                       /*!< PWM period register                                                       */
//   __IOM uint32_t  CAPTURE_INP;                  /*!< Timer capture input register                                              */
// } GPTIMER1_Type;                                /*!< Size = 28 (0x1c)                                                          */



/* =========================================================================================================================== */
/* ================                                         GPTIMER2                                          ================ */
/* =========================================================================================================================== */


// /**
//   * @brief General Purpose Timer (GPTIMER2)
//   */

// typedef struct {                                /*!< GPTIMER2 Structure                                                        */
  
//   union {
//     __IOM uint16_t CTRL;                        /*!< Control register                                                          */
    
//     struct {
//       __IOM uint16_t CTRL_EN    : 1;            /*!< Timer enable flag                                                         */
//             uint16_t            : 1;
//       __IOM uint16_t CTRL_MODE  : 2;            /*!< Timer mode select: 0=PWM, 1=Down, 2=Up, 3=UpDown                          */
//       __IOM uint16_t CTRL_OUTPUT_EN : 1;        /*!< Timer output enable bit                                                   */
//       __IOM uint16_t CTRL_COUNT_RESET : 1;      /*!< Timer counter reset bit                                                   */
//       __IOM uint16_t CTRL_CNT_COUNT_EN : 1;     /*!< Timer continuous count enable                                             */
//       __IOM uint16_t CTRL_PWM_FALL_INTR_EN : 1; /*!< PWM fall interupt enable                                                  */
//       __IOM uint16_t CTRL_PWM_RISE_INTR_EN : 1; /*!< PWM rise interupt enable                                                  */
//       __IOM uint16_t CTRL_OFLOW_INTR_EN : 1;    /*!< Counter overflow interrupt enable                                         */
//       __IOM uint16_t CTRL_UFLOW_INTR_EN : 1;    /*!< Counter underflow interrupt enable                                        */
//       __IM  uint16_t CTRL_PWM_FALL_INTR : 1;    /*!< PWM fall interupt bit                                                     */
//       __IM  uint16_t CTRL_PWM_RISE_INTR : 1;    /*!< PWM rise interupt bit                                                     */
//       __IM  uint16_t CTRL_OFLOW_INTR : 1;       /*!< Counter overflow interrupt bit                                            */
//       __IM  uint16_t CTRL_UFLOW_INTR : 1;       /*!< Counter underflow interrupt bit                                           */
//       __IOM uint16_t CTRL_CAPTURE_INP_EN : 1;   /*!< Counter capture input enable                                              */
//     } CTRL_b;
//   } ;
//   __IM  uint16_t  RESERVED;
  
//   union {
//     __IOM uint32_t CLOCK_CTRL;                  /*!< Clock control register                                                    */
    
//     struct {
//       __IOM uint32_t CLK_SRC    : 1;            /*!< GPTIMER clock select bit                                                  */
//       __IOM uint32_t CLK_PRESCALAR : 16;        /*!< GPTIMER prescalar value                                                   */
//       __IOM uint32_t UPDATE_EN  : 1;            /*!< GPTIMER update enable                                                     */
//             uint32_t            : 14;
//     } CLOCK_CTRL_b;
//   } ;
//   __IM  uint32_t  COUNT;                        /*!< Counter register                                                          */
//   __IM  uint32_t  RPTD_COUNT;                   /*!< Repeated count register                                                   */
//   __IOM uint32_t  DUTY_CYCLE;                   /*!< PWM duty cycle register                                                   */
//   __IOM uint32_t  PERIOD;                       /*!< PWM period register                                                       */
//   __IOM uint32_t  CAPTURE_INP;                  /*!< Timer capture input register                                              */
// } GPTIMER2_Type;                                /*!< Size = 28 (0x1c)                                                          */



/* =========================================================================================================================== */
/* ================                                         GPTIMER3                                          ================ */
/* =========================================================================================================================== */


// /**
//   * @brief General Purpose Timer (GPTIMER3)
//   */

// typedef struct {                                /*!< GPTIMER3 Structure                                                        */
  
//   union {
//     __IOM uint16_t CTRL;                        /*!< Control register                                                          */
    
//     struct {
//       __IOM uint16_t CTRL_EN    : 1;            /*!< Timer enable flag                                                         */
//             uint16_t            : 1;
//       __IOM uint16_t CTRL_MODE  : 2;            /*!< Timer mode select: 0=PWM, 1=Down, 2=Up, 3=UpDown                          */
//       __IOM uint16_t CTRL_OUTPUT_EN : 1;        /*!< Timer output enable bit                                                   */
//       __IOM uint16_t CTRL_COUNT_RESET : 1;      /*!< Timer counter reset bit                                                   */
//       __IOM uint16_t CTRL_CNT_COUNT_EN : 1;     /*!< Timer continuous count enable                                             */
//       __IOM uint16_t CTRL_PWM_FALL_INTR_EN : 1; /*!< PWM fall interupt enable                                                  */
//       __IOM uint16_t CTRL_PWM_RISE_INTR_EN : 1; /*!< PWM rise interupt enable                                                  */
//       __IOM uint16_t CTRL_OFLOW_INTR_EN : 1;    /*!< Counter overflow interrupt enable                                         */
//       __IOM uint16_t CTRL_UFLOW_INTR_EN : 1;    /*!< Counter underflow interrupt enable                                        */
//       __IM  uint16_t CTRL_PWM_FALL_INTR : 1;    /*!< PWM fall interupt bit                                                     */
//       __IM  uint16_t CTRL_PWM_RISE_INTR : 1;    /*!< PWM rise interupt bit                                                     */
//       __IM  uint16_t CTRL_OFLOW_INTR : 1;       /*!< Counter overflow interrupt bit                                            */
//       __IM  uint16_t CTRL_UFLOW_INTR : 1;       /*!< Counter underflow interrupt bit                                           */
//       __IOM uint16_t CTRL_CAPTURE_INP_EN : 1;   /*!< Counter capture input enable                                              */
//     } CTRL_b;
//   } ;
//   __IM  uint16_t  RESERVED;
  
//   union {
//     __IOM uint32_t CLOCK_CTRL;                  /*!< Clock control register                                                    */
    
//     struct {
//       __IOM uint32_t CLK_SRC    : 1;            /*!< GPTIMER clock select bit                                                  */
//       __IOM uint32_t CLK_PRESCALAR : 16;        /*!< GPTIMER prescalar value                                                   */
//       __IOM uint32_t UPDATE_EN  : 1;            /*!< GPTIMER update enable                                                     */
//             uint32_t            : 14;
//     } CLOCK_CTRL_b;
//   } ;
//   __IM  uint32_t  COUNT;                        /*!< Counter register                                                          */
//   __IM  uint32_t  RPTD_COUNT;                   /*!< Repeated count register                                                   */
//   __IOM uint32_t  DUTY_CYCLE;                   /*!< PWM duty cycle register                                                   */
//   __IOM uint32_t  PERIOD;                       /*!< PWM period register                                                       */
//   __IOM uint32_t  CAPTURE_INP;                  /*!< Timer capture input register                                              */
// } GPTIMER3_Type;                                /*!< Size = 28 (0x1c)                                                          */



/* =========================================================================================================================== */
/* ================                                          CLINT0                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Core Local Interrupt Controller (CLINT0)
  */

typedef struct {                                /*!< CLINT0 Structure                                                          */
} CLINT0_Type;                                  /*!< Size = 0 (0x0)                                                            */



/* =========================================================================================================================== */
/* ================                                           UART                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Universal asynchronous receiver and transmitter (UART0)
  */

typedef struct {                                /*!< UART0 Structure                                                           */
  __IOM uint16_t  BAUD_REG;                     /*!< Baud register                                                             */
  __IM  uint16_t  RESERVED;
  
  __IOM Data  TX_REG;                       /*!< TX data register                                                          */
  __IOM Data  RX_REG;                       /*!< RX data register                                                          */
  
  union {
    __IOM uint16_t STATUS_REG;                  /*!< UART Status register                                                      */
    
    struct {
      __IOM uint16_t STATUS_TX_EMPTY : 1;       /*!< Transmittor register empty flag                                           */
      __IOM uint16_t STATUS_TX_FULL : 1;        /*!< Transmittor register full flag                                            */
      __IOM uint16_t STATUS_RX_NOT_EMPTY : 1;   /*!< Receiver register not empty flag                                          */
      __IOM uint16_t STATUS_RX_FULL : 1;        /*!< Receiver register full flag                                               */
      __IOM uint16_t STATUS_PARITY_ERR : 1;     /*!< Parity error in received data flag                                        */
      __IOM uint16_t STATUS_OVERRUN_ERR : 1;    /*!< Overrun error flag                                                        */
      __IOM uint16_t STATUS_FRAME_ERR : 1;      /*!< Frame error flag                                                          */
      __IOM uint16_t STATUS_BREAK_ERR : 1;      /*!< Break error flag                                                          */
      __IOM uint16_t STATUS_RX_ALMOST_FULL : 1; /*!< Indicates that the RXFIFO is almost full depending on RX_threshold
                                                     register                                                                  */
      __IOM uint16_t STATUS_OUTP_READY : 1;     /*!< Output ready flag                                                         */
      __IOM uint16_t STATUS_CAN_TAKE_INPUT : 1; /*!< Can take input flag                                                       */
            uint16_t            : 5;
    } STATUS_REG_b;
  } ;
  __IM  uint16_t  RESERVED1;
  __IOM uint16_t  DELAY_REG;                    /*!< Stores the delay to have before Tranmission                               */
  __IM  uint16_t  RESERVED2;
  
  union {
    __IOM uint16_t CTRL;                        /*!< Control register                                                          */
    
    struct {
            uint16_t            : 1;
      __IOM uint16_t CTRL_STOP_BITS : 2;        /*!< To select the number of stop bits. 00 - 1 Stop bits, 01 - 1.5
                                                     Stop bits, 10 - 2 Stop bits                                               */
      __IOM uint16_t CTRL_PARITY : 2;           /*!< To select the type of parity. 00 - None, 01 - Odd, 10 - Even              */
      __IOM uint16_t CHAR_SIZE  : 2;            /*!< Selects the transmission data size 00 - 8 bits, 01 - 7 bits,
                                                     10 - 6 bits, 11 - 5 bits                                                  */
      __IOM uint16_t CTRL_TX_THRESH : 3;        /*!< Select the total number of bits in single transcation 000 -
                                                     None, 001 - 8 bits, 010 - 16 bits, 011 - 32 bits, 110 -
                                                     64 bits                                                                   */
      __IOM uint16_t CTRL_RX_THRESH : 3;        /*!< Select the total number of bits in single receive 000 - None,
                                                     001 - 8 bits, 010 - 16 bits, 011 - 32 bits, 110 - 64 bits                 */
      __IOM uint16_t CTRL_PULLUP_EN : 1;        /*!< Pullup enable                                                             */
            uint16_t            : 2;
    } CTRL_b;
  } ;
  __IM  uint16_t  RESERVED3;
  
  union {
    __IOM uint16_t INTR_EN;                     /*!< Interrupts enable register                                                */
    
    struct {
      __IOM uint16_t INTR_TX_EMPTY_EN : 1;      /*!< Enable for interrupt of transmission fifo empty                           */
      __IOM uint16_t INTR_TX_FULL_EN : 1;       /*!< Enable for interrupt of transmission fifo full                            */
      __IOM uint16_t INTR_RX_NOT_EMPTY_EN : 1;  /*!< Enable for interrupt of receiver fifo not empty                           */
      __IOM uint16_t INTR_RX_FULL_EN : 1;       /*!< Enable for interrupt of receiver fifo full                                */
      __IOM uint16_t INTR_PARITY_EN : 1;        /*!< Enable for interrupt of parity error                                      */
      __IOM uint16_t INTR_OVERRUN_EN : 1;       /*!< Enable for interrupt of overrun error                                     */
      __IOM uint16_t INTR_FRAME_EN : 1;         /*!< Enable for interrupt of frame error                                       */
      __IOM uint16_t INTR_BREAK_EN : 1;         /*!< Enable for interrupt of break error                                       */
      __IOM uint16_t INTR_RX_ALMOST_FULL : 1;   /*!< Enable for interrupt RX fifo almost full depending on the RX_threshold
                                                     register                                                                  */
            uint16_t            : 7;
    } INTR_EN_b;
  } ;
  __IM  uint16_t  RESERVED4;
  __IOM uint8_t   RX_THRESHOLD;                 /*!< The threshold value to indicate the RX FIFO almost full interrupt         */
  __IM  uint8_t   RESERVED5;
  __IM  uint16_t  RESERVED6;
} UART_Type;                                   /*!< Size = 32 (0x20)                                                          */



/* =========================================================================================================================== */
/* ================                                           UART1                                           ================ */
/* =========================================================================================================================== */


// /**
//   * @brief Universal asynchronous receiver and transmitter (UART1)
//   */

// typedef struct {                                /*!< UART1 Structure                                                           */
//   __IOM uint16_t  BAUD_REG;                     /*!< Baud register                                                             */
//   __IM  uint16_t  RESERVED;
//   __IOM uint32_t  TX_REG;                       /*!< TX data register                                                          */
//   __IOM uint32_t  RX_REG;                       /*!< RX data register                                                          */
  
//   union {
//     __IOM uint16_t STATUS_REG;                  /*!< UART Status register                                                      */
    
//     struct {
//       __IOM uint16_t STATUS_TX_EMPTY : 1;       /*!< Transmittor register empty flag                                           */
//       __IOM uint16_t STATUS_TX_FULL : 1;        /*!< Transmittor register full flag                                            */
//       __IOM uint16_t STATUS_RX_NOT_EMPTY : 1;   /*!< Receiver register not empty flag                                          */
//       __IOM uint16_t STATUS_RX_FULL : 1;        /*!< Receiver register full flag                                               */
//       __IOM uint16_t STATUS_PARITY_ERR : 1;     /*!< Parity error in received data flag                                        */
//       __IOM uint16_t STATUS_OVERRUN_ERR : 1;    /*!< Overrun error flag                                                        */
//       __IOM uint16_t STATUS_FRAME_ERR : 1;      /*!< Frame error flag                                                          */
//       __IOM uint16_t STATUS_BREAK_ERR : 1;      /*!< Break error flag                                                          */
//       __IOM uint16_t STATUS_RX_ALMOST_FULL : 1; /*!< Indicates that the RXFIFO is almost full depending on RX_threshold
//                                                      register                                                                  */
//       __IOM uint16_t STATUS_OUTP_READY : 1;     /*!< Output ready flag                                                         */
//       __IOM uint16_t STATUS_CAN_TAKE_INPUT : 1; /*!< Can take input flag                                                       */
//             uint16_t            : 5;
//     } STATUS_REG_b;
//   } ;
//   __IM  uint16_t  RESERVED1;
//   __IOM uint16_t  DELAY_REG;                    /*!< Stores the delay to have before Tranmission                               */
//   __IM  uint16_t  RESERVED2;
  
//   union {
//     __IOM uint16_t CTRL;                        /*!< Control register                                                          */
    
//     struct {
//             uint16_t            : 1;
//       __IOM uint16_t CTRL_STOP_BITS : 2;        /*!< To select the number of stop bits. 00 - 1 Stop bits, 01 - 1.5
//                                                      Stop bits, 10 - 2 Stop bits                                               */
//       __IOM uint16_t CTRL_PARITY : 2;           /*!< To select the type of parity. 00 - None, 01 - Odd, 10 - Even              */
//       __IOM uint16_t CHAR_SIZE  : 2;            /*!< Selects the transmission data size 00 - 8 bits, 01 - 7 bits,
//                                                      10 - 6 bits, 11 - 5 bits                                                  */
//       __IOM uint16_t CTRL_TX_THRESH : 3;        /*!< Select the total number of bits in single transcation 000 -
//                                                      None, 001 - 8 bits, 010 - 16 bits, 011 - 32 bits, 110 -
//                                                      64 bits                                                                   */
//       __IOM uint16_t CTRL_RX_THRESH : 3;        /*!< Select the total number of bits in single receive 000 - None,
//                                                      001 - 8 bits, 010 - 16 bits, 011 - 32 bits, 110 - 64 bits                 */
//       __IOM uint16_t CTRL_PULLUP_EN : 1;        /*!< Pullup enable                                                             */
//             uint16_t            : 2;
//     } CTRL_b;
//   } ;
//   __IM  uint16_t  RESERVED3;
  
//   union {
//     __IOM uint16_t INTR_EN;                     /*!< Interrupts enable register                                                */
    
//     struct {
//       __IOM uint16_t INTR_TX_EMPTY_EN : 1;      /*!< Enable for interrupt of transmission fifo empty                           */
//       __IOM uint16_t INTR_TX_FULL_EN : 1;       /*!< Enable for interrupt of transmission fifo full                            */
//       __IOM uint16_t INTR_RX_NOT_EMPTY_EN : 1;  /*!< Enable for interrupt of receiver fifo not empty                           */
//       __IOM uint16_t INTR_RX_FULL_EN : 1;       /*!< Enable for interrupt of receiver fifo full                                */
//       __IOM uint16_t INTR_PARITY_EN : 1;        /*!< Enable for interrupt of parity error                                      */
//       __IOM uint16_t INTR_OVERRUN_EN : 1;       /*!< Enable for interrupt of overrun error                                     */
//       __IOM uint16_t INTR_FRAME_EN : 1;         /*!< Enable for interrupt of frame error                                       */
//       __IOM uint16_t INTR_BREAK_EN : 1;         /*!< Enable for interrupt of break error                                       */
//       __IOM uint16_t INTR_RX_ALMOST_FULL : 1;   /*!< Enable for interrupt RX fifo almost full depending on the RX_threshold
//                                                      register                                                                  */
//             uint16_t            : 7;
//     } INTR_EN_b;
//   } ;
//   __IM  uint16_t  RESERVED4;
//   __IOM uint8_t   RX_THRESHOLD;                 /*!< The threshold value to indicate the RX FIFO almost full interrupt         */
//   __IM  uint8_t   RESERVED5;
//   __IM  uint16_t  RESERVED6;
// } UART1_Type;                                   /*!< Size = 32 (0x20)                                                          */



/* =========================================================================================================================== */
/* ================                                           UART2                                           ================ */
/* =========================================================================================================================== */


// /**
//   * @brief Universal asynchronous receiver and transmitter (UART2)
//   */

// typedef struct {                                /*!< UART2 Structure                                                           */
//   __IOM uint16_t  BAUD_REG;                     /*!< Baud register                                                             */
//   __IM  uint16_t  RESERVED;
//   __IOM uint32_t  TX_REG;                       /*!< TX data register                                                          */
//   __IOM uint32_t  RX_REG;                       /*!< RX data register                                                          */
  
//   union {
//     __IOM uint16_t STATUS_REG;                  /*!< UART Status register                                                      */
    
//     struct {
//       __IOM uint16_t STATUS_TX_EMPTY : 1;       /*!< Transmittor register empty flag                                           */
//       __IOM uint16_t STATUS_TX_FULL : 1;        /*!< Transmittor register full flag                                            */
//       __IOM uint16_t STATUS_RX_NOT_EMPTY : 1;   /*!< Receiver register not empty flag                                          */
//       __IOM uint16_t STATUS_RX_FULL : 1;        /*!< Receiver register full flag                                               */
//       __IOM uint16_t STATUS_PARITY_ERR : 1;     /*!< Parity error in received data flag                                        */
//       __IOM uint16_t STATUS_OVERRUN_ERR : 1;    /*!< Overrun error flag                                                        */
//       __IOM uint16_t STATUS_FRAME_ERR : 1;      /*!< Frame error flag                                                          */
//       __IOM uint16_t STATUS_BREAK_ERR : 1;      /*!< Break error flag                                                          */
//       __IOM uint16_t STATUS_RX_ALMOST_FULL : 1; /*!< Indicates that the RXFIFO is almost full depending on RX_threshold
//                                                      register                                                                  */
//       __IOM uint16_t STATUS_OUTP_READY : 1;     /*!< Output ready flag                                                         */
//       __IOM uint16_t STATUS_CAN_TAKE_INPUT : 1; /*!< Can take input flag                                                       */
//             uint16_t            : 5;
//     } STATUS_REG_b;
//   } ;
//   __IM  uint16_t  RESERVED1;
//   __IOM uint16_t  DELAY_REG;                    /*!< Stores the delay to have before Tranmission                               */
//   __IM  uint16_t  RESERVED2;
  
//   union {
//     __IOM uint16_t CTRL;                        /*!< Control register                                                          */
    
//     struct {
//             uint16_t            : 1;
//       __IOM uint16_t CTRL_STOP_BITS : 2;        /*!< To select the number of stop bits. 00 - 1 Stop bits, 01 - 1.5
//                                                      Stop bits, 10 - 2 Stop bits                                               */
//       __IOM uint16_t CTRL_PARITY : 2;           /*!< To select the type of parity. 00 - None, 01 - Odd, 10 - Even              */
//       __IOM uint16_t CHAR_SIZE  : 2;            /*!< Selects the transmission data size 00 - 8 bits, 01 - 7 bits,
//                                                      10 - 6 bits, 11 - 5 bits                                                  */
//       __IOM uint16_t CTRL_TX_THRESH : 3;        /*!< Select the total number of bits in single transcation 000 -
//                                                      None, 001 - 8 bits, 010 - 16 bits, 011 - 32 bits, 110 -
//                                                      64 bits                                                                   */
//       __IOM uint16_t CTRL_RX_THRESH : 3;        /*!< Select the total number of bits in single receive 000 - None,
//                                                      001 - 8 bits, 010 - 16 bits, 011 - 32 bits, 110 - 64 bits                 */
//       __IOM uint16_t CTRL_PULLUP_EN : 1;        /*!< Pullup enable                                                             */
//             uint16_t            : 2;
//     } CTRL_b;
//   } ;
//   __IM  uint16_t  RESERVED3;
  
//   union {
//     __IOM uint16_t INTR_EN;                     /*!< Interrupts enable register                                                */
    
//     struct {
//       __IOM uint16_t INTR_TX_EMPTY_EN : 1;      /*!< Enable for interrupt of transmission fifo empty                           */
//       __IOM uint16_t INTR_TX_FULL_EN : 1;       /*!< Enable for interrupt of transmission fifo full                            */
//       __IOM uint16_t INTR_RX_NOT_EMPTY_EN : 1;  /*!< Enable for interrupt of receiver fifo not empty                           */
//       __IOM uint16_t INTR_RX_FULL_EN : 1;       /*!< Enable for interrupt of receiver fifo full                                */
//       __IOM uint16_t INTR_PARITY_EN : 1;        /*!< Enable for interrupt of parity error                                      */
//       __IOM uint16_t INTR_OVERRUN_EN : 1;       /*!< Enable for interrupt of overrun error                                     */
//       __IOM uint16_t INTR_FRAME_EN : 1;         /*!< Enable for interrupt of frame error                                       */
//       __IOM uint16_t INTR_BREAK_EN : 1;         /*!< Enable for interrupt of break error                                       */
//       __IOM uint16_t INTR_RX_ALMOST_FULL : 1;   /*!< Enable for interrupt RX fifo almost full depending on the RX_threshold
//                                                      register                                                                  */
//             uint16_t            : 7;
//     } INTR_EN_b;
//   } ;
//   __IM  uint16_t  RESERVED4;
//   __IOM uint8_t   RX_THRESHOLD;                 /*!< The threshold value to indicate the RX FIFO almost full interrupt         */
//   __IM  uint8_t   RESERVED5;
//   __IM  uint16_t  RESERVED6;
// } UART2_Type;                                   /*!< Size = 32 (0x20)                                                          */



/* =========================================================================================================================== */
/* ================                                           UART3                                           ================ */
/* =========================================================================================================================== */


// /**
//   * @brief Universal asynchronous receiver and transmitter (UART3)
//   */

// typedef struct {                                /*!< UART3 Structure                                                           */
//   __IOM uint16_t  BAUD_REG;                     /*!< Baud register                                                             */
//   __IM  uint16_t  RESERVED;
//   __IOM uint32_t  TX_REG;                       /*!< TX data register                                                          */
//   __IOM uint32_t  RX_REG;                       /*!< RX data register                                                          */
  
//   union {
//     __IOM uint16_t STATUS_REG;                  /*!< UART Status register                                                      */
    
//     struct {
//       __IOM uint16_t STATUS_TX_EMPTY : 1;       /*!< Transmittor register empty flag                                           */
//       __IOM uint16_t STATUS_TX_FULL : 1;        /*!< Transmittor register full flag                                            */
//       __IOM uint16_t STATUS_RX_NOT_EMPTY : 1;   /*!< Receiver register not empty flag                                          */
//       __IOM uint16_t STATUS_RX_FULL : 1;        /*!< Receiver register full flag                                               */
//       __IOM uint16_t STATUS_PARITY_ERR : 1;     /*!< Parity error in received data flag                                        */
//       __IOM uint16_t STATUS_OVERRUN_ERR : 1;    /*!< Overrun error flag                                                        */
//       __IOM uint16_t STATUS_FRAME_ERR : 1;      /*!< Frame error flag                                                          */
//       __IOM uint16_t STATUS_BREAK_ERR : 1;      /*!< Break error flag                                                          */
//       __IOM uint16_t STATUS_RX_ALMOST_FULL : 1; /*!< Indicates that the RXFIFO is almost full depending on RX_threshold
//                                                      register                                                                  */
//       __IOM uint16_t STATUS_OUTP_READY : 1;     /*!< Output ready flag                                                         */
//       __IOM uint16_t STATUS_CAN_TAKE_INPUT : 1; /*!< Can take input flag                                                       */
//             uint16_t            : 5;
//     } STATUS_REG_b;
//   } ;
//   __IM  uint16_t  RESERVED1;
//   __IOM uint16_t  DELAY_REG;                    /*!< Stores the delay to have before Tranmission                               */
//   __IM  uint16_t  RESERVED2;
  
//   union {
//     __IOM uint16_t CTRL;                        /*!< Control register                                                          */
    
//     struct {
//             uint16_t            : 1;
//       __IOM uint16_t CTRL_STOP_BITS : 2;        /*!< To select the number of stop bits. 00 - 1 Stop bits, 01 - 1.5
//                                                      Stop bits, 10 - 2 Stop bits                                               */
//       __IOM uint16_t CTRL_PARITY : 2;           /*!< To select the type of parity. 00 - None, 01 - Odd, 10 - Even              */
//       __IOM uint16_t CHAR_SIZE  : 2;            /*!< Selects the transmission data size 00 - 8 bits, 01 - 7 bits,
//                                                      10 - 6 bits, 11 - 5 bits                                                  */
//       __IOM uint16_t CTRL_TX_THRESH : 3;        /*!< Select the total number of bits in single transcation 000 -
//                                                      None, 001 - 8 bits, 010 - 16 bits, 011 - 32 bits, 110 -
//                                                      64 bits                                                                   */
//       __IOM uint16_t CTRL_RX_THRESH : 3;        /*!< Select the total number of bits in single receive 000 - None,
//                                                      001 - 8 bits, 010 - 16 bits, 011 - 32 bits, 110 - 64 bits                 */
//       __IOM uint16_t CTRL_PULLUP_EN : 1;        /*!< Pullup enable                                                             */
//             uint16_t            : 2;
//     } CTRL_b;
//   } ;
//   __IM  uint16_t  RESERVED3;
  
//   union {
//     __IOM uint16_t INTR_EN;                     /*!< Interrupts enable register                                                */
    
//     struct {
//       __IOM uint16_t INTR_TX_EMPTY_EN : 1;      /*!< Enable for interrupt of transmission fifo empty                           */
//       __IOM uint16_t INTR_TX_FULL_EN : 1;       /*!< Enable for interrupt of transmission fifo full                            */
//       __IOM uint16_t INTR_RX_NOT_EMPTY_EN : 1;  /*!< Enable for interrupt of receiver fifo not empty                           */
//       __IOM uint16_t INTR_RX_FULL_EN : 1;       /*!< Enable for interrupt of receiver fifo full                                */
//       __IOM uint16_t INTR_PARITY_EN : 1;        /*!< Enable for interrupt of parity error                                      */
//       __IOM uint16_t INTR_OVERRUN_EN : 1;       /*!< Enable for interrupt of overrun error                                     */
//       __IOM uint16_t INTR_FRAME_EN : 1;         /*!< Enable for interrupt of frame error                                       */
//       __IOM uint16_t INTR_BREAK_EN : 1;         /*!< Enable for interrupt of break error                                       */
//       __IOM uint16_t INTR_RX_ALMOST_FULL : 1;   /*!< Enable for interrupt RX fifo almost full depending on the RX_threshold
//                                                      register                                                                  */
//             uint16_t            : 7;
//     } INTR_EN_b;
//   } ;
//   __IM  uint16_t  RESERVED4;
//   __IOM uint8_t   RX_THRESHOLD;                 /*!< The threshold value to indicate the RX FIFO almost full interrupt         */
//   __IM  uint8_t   RESERVED5;
//   __IM  uint16_t  RESERVED6;
// } UART3_Type;                                   /*!< Size = 32 (0x20)                                                          */



/* =========================================================================================================================== */
/* ================                                           UART4                                           ================ */
/* =========================================================================================================================== */


// /**
//   * @brief Universal asynchronous receiver and transmitter (UART4)
//   */

// typedef struct {                                /*!< UART4 Structure                                                           */
//   __IOM uint16_t  BAUD_REG;                     /*!< Baud register                                                             */
//   __IM  uint16_t  RESERVED;
//   __IOM uint32_t  TX_REG;                       /*!< TX data register                                                          */
//   __IOM uint32_t  RX_REG;                       /*!< RX data register                                                          */
  
//   union {
//     __IOM uint16_t STATUS_REG;                  /*!< UART Status register                                                      */
    
//     struct {
//       __IOM uint16_t STATUS_TX_EMPTY : 1;       /*!< Transmittor register empty flag                                           */
//       __IOM uint16_t STATUS_TX_FULL : 1;        /*!< Transmittor register full flag                                            */
//       __IOM uint16_t STATUS_RX_NOT_EMPTY : 1;   /*!< Receiver register not empty flag                                          */
//       __IOM uint16_t STATUS_RX_FULL : 1;        /*!< Receiver register full flag                                               */
//       __IOM uint16_t STATUS_PARITY_ERR : 1;     /*!< Parity error in received data flag                                        */
//       __IOM uint16_t STATUS_OVERRUN_ERR : 1;    /*!< Overrun error flag                                                        */
//       __IOM uint16_t STATUS_FRAME_ERR : 1;      /*!< Frame error flag                                                          */
//       __IOM uint16_t STATUS_BREAK_ERR : 1;      /*!< Break error flag                                                          */
//       __IOM uint16_t STATUS_RX_ALMOST_FULL : 1; /*!< Indicates that the RXFIFO is almost full depending on RX_threshold
//                                                      register                                                                  */
//       __IOM uint16_t STATUS_OUTP_READY : 1;     /*!< Output ready flag                                                         */
//       __IOM uint16_t STATUS_CAN_TAKE_INPUT : 1; /*!< Can take input flag                                                       */
//             uint16_t            : 5;
//     } STATUS_REG_b;
//   } ;
//   __IM  uint16_t  RESERVED1;
//   __IOM uint16_t  DELAY_REG;                    /*!< Stores the delay to have before Tranmission                               */
//   __IM  uint16_t  RESERVED2;
  
//   union {
//     __IOM uint16_t CTRL;                        /*!< Control register                                                          */
    
//     struct {
//             uint16_t            : 1;
//       __IOM uint16_t CTRL_STOP_BITS : 2;        /*!< To select the number of stop bits. 00 - 1 Stop bits, 01 - 1.5
//                                                      Stop bits, 10 - 2 Stop bits                                               */
//       __IOM uint16_t CTRL_PARITY : 2;           /*!< To select the type of parity. 00 - None, 01 - Odd, 10 - Even              */
//       __IOM uint16_t CHAR_SIZE  : 2;            /*!< Selects the transmission data size 00 - 8 bits, 01 - 7 bits,
//                                                      10 - 6 bits, 11 - 5 bits                                                  */
//       __IOM uint16_t CTRL_TX_THRESH : 3;        /*!< Select the total number of bits in single transcation 000 -
//                                                      None, 001 - 8 bits, 010 - 16 bits, 011 - 32 bits, 110 -
//                                                      64 bits                                                                   */
//       __IOM uint16_t CTRL_RX_THRESH : 3;        /*!< Select the total number of bits in single receive 000 - None,
//                                                      001 - 8 bits, 010 - 16 bits, 011 - 32 bits, 110 - 64 bits                 */
//       __IOM uint16_t CTRL_PULLUP_EN : 1;        /*!< Pullup enable                                                             */
//             uint16_t            : 2;
//     } CTRL_b;
//   } ;
//   __IM  uint16_t  RESERVED3;
  
//   union {
//     __IOM uint16_t INTR_EN;                     /*!< Interrupts enable register                                                */
    
//     struct {
//       __IOM uint16_t INTR_TX_EMPTY_EN : 1;      /*!< Enable for interrupt of transmission fifo empty                           */
//       __IOM uint16_t INTR_TX_FULL_EN : 1;       /*!< Enable for interrupt of transmission fifo full                            */
//       __IOM uint16_t INTR_RX_NOT_EMPTY_EN : 1;  /*!< Enable for interrupt of receiver fifo not empty                           */
//       __IOM uint16_t INTR_RX_FULL_EN : 1;       /*!< Enable for interrupt of receiver fifo full                                */
//       __IOM uint16_t INTR_PARITY_EN : 1;        /*!< Enable for interrupt of parity error                                      */
//       __IOM uint16_t INTR_OVERRUN_EN : 1;       /*!< Enable for interrupt of overrun error                                     */
//       __IOM uint16_t INTR_FRAME_EN : 1;         /*!< Enable for interrupt of frame error                                       */
//       __IOM uint16_t INTR_BREAK_EN : 1;         /*!< Enable for interrupt of break error                                       */
//       __IOM uint16_t INTR_RX_ALMOST_FULL : 1;   /*!< Enable for interrupt RX fifo almost full depending on the RX_threshold
//                                                      register                                                                  */
//             uint16_t            : 7;
//     } INTR_EN_b;
//   } ;
//   __IM  uint16_t  RESERVED4;
//   __IOM uint8_t   RX_THRESHOLD;                 /*!< The threshold value to indicate the RX FIFO almost full interrupt         */
//   __IM  uint8_t   RESERVED5;
//   __IM  uint16_t  RESERVED6;
// } UART4_Type;                                   /*!< Size = 32 (0x20)                                                          */



/* =========================================================================================================================== */
/* ================                                           I2C                                             ================ */
/* =========================================================================================================================== */


/**
  * @brief I2C communication peripheral (I2C0)
  */

typedef struct {                                /*!< I2C0 Structure                                                            */
  __IOM uint8_t   S2;                           /*!< Prescalar register                                                        */
  __IM  uint8_t   RESERVED;
  __IM  uint16_t  RESERVED1;
  __IM  uint32_t  RESERVED2;
  
  union {
    __IOM uint8_t CTRL;                         /*!< Control register                                                          */
    
    struct {
      __IOM uint8_t CTRL_ACK    : 1;            /*!< Sends the acknoledge bit                                                  */
      __IOM uint8_t CTRL_STO    : 1;            /*!< Sends the stop bit                                                        */
      __IOM uint8_t CTRL_STA    : 1;            /*!< Sends the start bit                                                       */
      __IOM uint8_t CTRL_ENI    : 1;            /*!< Enables the external interrupt output                                     */
            uint8_t             : 2;
      __IOM uint8_t CTRL_ESO    : 1;            /*!< Enable Serial Output. ESO = 0 - Registers can be initialized.
                                                     ESO = 1 - I2C Serial Transmission                                         */
      __IOM uint8_t CTRL_PIN    : 1;            /*!< Used as a software reset. If pin is 1 all status bits are reset.Used
                                                     as transmission complete status in polled applications                    */
    } CTRL_b;
  } ;
  __IM  uint8_t   RESERVED3;
  __IM  uint16_t  RESERVED4;
  __IM  uint32_t  RESERVED5;
  __IOM uint8_t   S0;                           /*!< Data Transmission register                                                */
  __IM  uint8_t   RESERVED6;
  __IM  uint16_t  RESERVED7;
  __IM  uint32_t  RESERVED8;
  
  union {
    __IOM uint8_t STATUS;                       /*!< Status register                                                           */
    
    struct {
      __IOM uint8_t STATUS_BB   : 1;            /*!< Bus Busy bit - Indicates that the bus is busy(0 = busy). Also
                                                     used in multi master systems only. 0 = busy                               */
      __IOM uint8_t STATUS_LAB  : 1;            /*!< Lost Arbitration bit - Used in Multiple Master systems only
                                                     to denote that the master lost the arbitration                            */
      __IOM uint8_t STATUS_AAS  : 1;            /*!< Addressed as slave - Used in Slave Receiver mode                          */
      __IOM uint8_t STATUS_AD0_LRB : 1;         /*!< LRB - holds the last received bit through I2C bus. AD0 - Generall
                                                     Call bit used for broadcast. Valid only while PIN=0                       */
      __IOM uint8_t STATUS_BER  : 1;            /*!< Bus Error - Set to 1 when there is a misplaced START, STOP bit            */
            uint8_t             : 2;
      __IOM uint8_t STATUS_STS  : 1;            /*!< Read the PIN bit of control register                                      */
    } STATUS_b;
  } ;
  __IM  uint8_t   RESERVED9;
  __IM  uint16_t  RESERVED10;
  __IM  uint32_t  RESERVED11;
  __IOM uint32_t  S01;                          /*!< I2C Own Address Slave Register                                            */
  __IM  uint32_t  RESERVED12;
  __IOM uint32_t  S3;                           /*!< Interrupt vector register                                                 */
  __IM  uint32_t  RESERVED13;
  
  union {
    __IOM uint32_t TIME;                        /*!< I2C timeout calculation and interrupt register                            */
    
    struct {
      __IOM uint32_t TIMEOUT    : 14;           /*!< The transmission timeout value                                            */
      __IOM uint32_t TIMEOUT_EN : 1;            /*!< Enable the transmission timeout calculation and interrupt generation      */
      __IOM uint32_t TIMEOUT_INTR : 1;          /*!< Interrupt output for transmission timeout                                 */
            uint32_t            : 16;
    } TIME_b;
  } ;
  __IM  uint32_t  RESERVED14;
  __IOM uint32_t  SCL;                          /*!< Clock period register                                                     */
} I2C_Type;                                    /*!< Size = 60 (0x3c)                                                          */



/* =========================================================================================================================== */
/* ================                                           I2C1                                            ================ */
/* =========================================================================================================================== */


// /**
//   * @brief I2C communication peripheral (I2C1)
//   */

// typedef struct {                                /*!< I2C1 Structure                                                            */
//   __IOM uint8_t   S2;                           /*!< Prescalar register                                                        */
//   __IM  uint8_t   RESERVED;
//   __IM  uint16_t  RESERVED1;
//   __IM  uint32_t  RESERVED2;
  
//   union {
//     __IOM uint8_t CTRL;                         /*!< Control register                                                          */
    
//     struct {
//       __IOM uint8_t CTRL_ACK    : 1;            /*!< Sends the acknoledge bit                                                  */
//       __IOM uint8_t CTRL_STO    : 1;            /*!< Sends the stop bit                                                        */
//       __IOM uint8_t CTRL_STA    : 1;            /*!< Sends the start bit                                                       */
//       __IOM uint8_t CTRL_ENI    : 1;            /*!< Enables the external interrupt output                                     */
//             uint8_t             : 2;
//       __IOM uint8_t CTRL_ESO    : 1;            /*!< Enable Serial Output. ESO = 0 - Registers can be initialized.
//                                                      ESO = 1 - I2C Serial Transmission                                         */
//       __IOM uint8_t CTRL_PIN    : 1;            /*!< Used as a software reset. If pin is 1 all status bits are reset.Used
//                                                      as transmission complete status in polled applications                    */
//     } CTRL_b;
//   } ;
//   __IM  uint8_t   RESERVED3;
//   __IM  uint16_t  RESERVED4;
//   __IM  uint32_t  RESERVED5;
//   __IOM uint8_t   S0;                           /*!< Data Transmission register                                                */
//   __IM  uint8_t   RESERVED6;
//   __IM  uint16_t  RESERVED7;
//   __IM  uint32_t  RESERVED8;
  
//   union {
//     __IOM uint8_t STATUS;                       /*!< Status register                                                           */
    
//     struct {
//       __IOM uint8_t STATUS_BB   : 1;            /*!< Bus Busy bit - Indicates that the bus is busy(0 = busy). Also
//                                                      used in multi master systems only. 0 = busy                               */
//       __IOM uint8_t STATUS_LAB  : 1;            /*!< Lost Arbitration bit - Used in Multiple Master systems only
//                                                      to denote that the master lost the arbitration                            */
//       __IOM uint8_t STATUS_AAS  : 1;            /*!< Addressed as slave - Used in Slave Receiver mode                          */
//       __IOM uint8_t STATUS_AD0_LRB : 1;         /*!< LRB - holds the last received bit through I2C bus. AD0 - Generall
//                                                      Call bit used for broadcast. Valid only while PIN=0                       */
//       __IOM uint8_t STATUS_BER  : 1;            /*!< Bus Error - Set to 1 when there is a misplaced START, STOP bit            */
//             uint8_t             : 2;
//       __IOM uint8_t STATUS_STS  : 1;            /*!< Read the PIN bit of control register                                      */
//     } STATUS_b;
//   } ;
//   __IM  uint8_t   RESERVED9;
//   __IM  uint16_t  RESERVED10;
//   __IM  uint32_t  RESERVED11;
//   __IOM uint32_t  S01;                          /*!< I2C Own Address Slave Register                                            */
//   __IM  uint32_t  RESERVED12;
//   __IOM uint32_t  S3;                           /*!< Interrupt vector register                                                 */
//   __IM  uint32_t  RESERVED13;
  
//   union {
//     __IOM uint32_t TIME;                        /*!< I2C timeout calculation and interrupt register                            */
    
//     struct {
//       __IOM uint32_t TIMEOUT    : 14;           /*!< The transmission timeout value                                            */
//       __IOM uint32_t TIMEOUT_EN : 1;            /*!< Enable the transmission timeout calculation and interrupt generation      */
//       __IOM uint32_t TIMEOUT_INTR : 1;          /*!< Interrupt output for transmission timeout                                 */
//             uint32_t            : 16;
//     } TIME_b;
//   } ;
//   __IM  uint32_t  RESERVED14;
//   __IOM uint32_t  SCL;                          /*!< Clock period register                                                     */
// } I2C1_Type;                                    /*!< Size = 60 (0x3c)                                                          */



/* =========================================================================================================================== */
/* ================                                            WDT                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Watchdog Timer (WDT)
  */

typedef struct {                                /*!< WDT Structure                                                             */
  __IOM uint32_t  WDT_CYCLES;                   /*!< The number of cycles to count down for reset generation                   */
  __IM  uint32_t  RESERVED;
  
  union {
    __IOM uint16_t WDT_CTRL;                    /*!< Control register                                                          */
    
    struct {
      __IOM uint16_t WDT_CTRL_EN : 1;           /*!< Enable the watchdog timer                                                 */
      __IOM uint16_t WDT_CTRL_MODE : 1;         /*!< Mode of watchdog timer. 0 - Interrupt, 1 - Reset                          */
      __IOM uint16_t WDT_CTRL_SOFT : 1;         /*!< Software reset                                                            */
            uint16_t            : 13;
    } WDT_CTRL_b;
  } ;
  __IM  uint16_t  RESERVED1;
  __IM  uint32_t  RESERVED2;
  __IOM uint16_t  WDT_RESET_CYCLES;             /*!< The number of cycles for which the interrupt needs to be held             */
  __IM  uint16_t  RESERVED3;
  __IM  uint32_t  RESERVED4;
  __IOM uint32_t  WDT_ACTIVE;                   /*!< Update the internal WD counter with the WD_CYCLES register                */
} WDT_Type;                                     /*!< Size = 28 (0x1c)                                                          */



/* =========================================================================================================================== */
/* ================                                          PINMUX0                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief Pinmux which selects between GPIO and PWM. (PINMUX0)
  */

typedef struct {                                /*!< PINMUX0 Structure                                                         */
  __IOM uint32_t  MUX0;                         /*!< Select between GPIO0 and PWM0. 0 - GPIO, 1 - PWM                          */
  __IOM uint32_t  MUX1;                         /*!< Select between GPIO1 and PWM1. 0 - GPIO, 1 - PWM                          */
  __IOM uint32_t  MUX2;                         /*!< Select between GPIO2 and PWM2. 0 - GPIO, 1 - PWM                          */
  __IOM uint32_t  MUX3;                         /*!< Select between GPIO3 and PWM3. 0 - GPIO, 1 - PWM                          */
  __IOM uint32_t  MUX4;                         /*!< Select between GPIO4 and PWM4. 0 - GPIO, 1 - PWM                          */
  __IOM uint32_t  MUX5;                         /*!< Select between GPIO5 and PWM5. 0 - GPIO, 1 - PWM                          */
  __IOM uint32_t  MUX6;                         /*!< Select between GPIO6 and PWM6. 0 - GPIO, 1 - PWM                          */
  __IOM uint32_t  MUX7;                         /*!< Select between GPIO7 and PWM7. 0 - GPIO, 1 - PWM                          */
  __IOM uint32_t  MUX8;                         /*!< Select between GPIO17 and PWM8. 0 - GPIO, 1 - PWM                         */
  __IOM uint32_t  MUX9;                         /*!< Select between GPIO18 and PWM9. 0 - GPIO, 1 - PWM                         */
  __IOM uint32_t  MUX10;                        /*!< Select between GPIO19 and PWM10. 0 - GPIO, 1 - PWM                        */
  __IOM uint32_t  MUX11;                        /*!< Select between GPIO20 and PWM11. 0 - GPIO, 1 - PWM                        */
  __IOM uint32_t  MUX12;                        /*!< Select between GPIO21 and PWM12. 0 - GPIO, 1 - PWM                        */
  __IOM uint32_t  MUX13;                        /*!< Select between GPIO22 and PWM13. 0 - GPIO, 1 - PWM                        */
  __IOM uint32_t  MUX14;                        /*!< Select between GPIOP0 and SPI2 MOSI. 1 - GPIO, 0 - SPI2 MOSI              */
  __IOM uint32_t  MUX15;                        /*!< Select between GPIOP1 and SPI2 MISO. 1 - GPIO, 0 - SPI2 MISO              */
  __IOM uint32_t  MUX16;                        /*!< Select between GPIOP2 and SPI2 SCLK. 1 - GPIO, 0 - SPI2 SCLK              */
  __IOM uint32_t  MUX17;                        /*!< Select between GPIOP4 and SPI2 NCS. 1 - GPIO, 0 - SPI2 NCS                */
  __IOM uint32_t  MUX18;                        /*!< Select between GPIOP5 and SPI3 MOSI. 1 - GPIO, 0 - SPI3 MOSI              */
  __IOM uint32_t  MUX19;                        /*!< Select between GPIOP6 and SPI3 MISO. 1 - GPIO, 0 - SPI3 MISO              */
  __IOM uint32_t  MUX20;                        /*!< Select between GPIOP7 and SPI3 SCLK. 1 - GPIO, 0 - SPI3 SCLK              */
  __IOM uint32_t  MUX21;                        /*!< Select between GPIOP8 and SPI3 NCS. 1 - GPIO, 0 - SPI3 NCS                */
  __IOM uint32_t  MUX22;                        /*!< Select between GPIOP9 and JTAG TDO. 1 - GPIO, 0 - JTAG TDO                */
  __IOM uint32_t  MUX23;                        /*!< Select between GPIOP10 and JTAG TDI. 1 - GPIO, 0 - JTAG TDI               */
  __IOM uint32_t  MUX24;                        /*!< Select between GPIOP11 and JTAG TMS. 1 - GPIO, 0 - JTAG TMS               */
  __IOM uint32_t  MUX25;                        /*!< Select between GPIOP12 and JTAG TCLK. 1 - GPIO, 0 - JTAG TCLK             */
  __IOM uint32_t  MUX26;                        /*!< Select between GPIOP13 and JTAG TRST. 1 - GPIO, 0 - JTAG TRST             */
  __IOM uint32_t  MUX27;                        /*!< Select between GPIO8 and UART3 TX. 1 - GPIO, 0 - UART3 TX                 */
  __IOM uint32_t  MUX28;                        /*!< Select between GPIO9 and UART3 RX. 1 - GPIO, 0 - UART3 RX                 */
  __IOM uint32_t  MUX29;                        /*!< Select between GPIO11 and UART4 TX. 1 - GPIO, 0 - UART4 TX                */
  __IOM uint32_t  MUX30;                        /*!< Select between GPIO15 and UART4 TX. 1 - GPIO, 0 - UART4 RX                */
} PINMUX_Type;                                 /*!< Size = 124 (0x7c)                                                         */



/* =========================================================================================================================== */
/* ================                                           GPIO                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief General purpose IO. 32 GPIOs are available (GPIO)
  */

typedef struct {                                /*!< GPIO Structure                                                            */
  __IOM uint32_t  GPIO_DIRECTION;               /*!< Select the direction of the GPIOs. Each bit position corresponds
                                                     to the respective GPIO pin. 0 - Output, 1 - Input                         */
  __IM  uint32_t  RESERVED;
  __IOM uint32_t  GPIO_DATA;                    /*!< Contains the data to be sent out if the GPIO pin is configured
                                                     as output and the data recieved when configured as input.
                                                     Each bit position corresponds to the respective GPIO pin.                 */
  __IM  uint32_t  RESERVED1;
  __IOM uint32_t  GPIO_SET;                     /*!< To set the respective GPIO pins                                           */
  __IM  uint32_t  RESERVED2;
  __IOM uint32_t  GPIO_CLEAR;                   /*!< To clear the respective GPIO pins                                         */
  __IM  uint32_t  RESERVED3;
  __IOM uint32_t  GPIO_TOGGLE;                  /*!< To invert the respective GPIO pins                                        */
  __IM  uint32_t  RESERVED4[3];
  __IOM uint32_t  GPIO_INTR;                    /*!< To enable the interrupt of respective GPIO pins                           */
  __IM  uint32_t  RESERVED5;
  __IOM uint32_t  GPIO_PULLUP_CONFIG;           /*!< To enable the interrupt of respective GPIO pins                           */
  __IM  uint32_t  RESERVED6;
  
  union {
    __IOM uint32_t GPIO_BUFFER_CONTROL;         /*!< To control and change the gpio buffer parameters                          */
    
    struct {
      __IOM uint32_t Buffer_2_Enable : 1;       /*!< 1 : 2 Bit buffer enabled ; 0 : 2 Bit buffer disabled                      */
      __IOM uint32_t Buffer_4_Enable : 1;       /*!< 1 : 4 Bit buffer enabled ; 0 : 4 Bit buffer disabled                      */
      __IOM uint32_t Buffer_8_Enable : 1;       /*!< 1 : 8 Bit buffer enabled ; 0 : 8 Bit buffer disabled                      */
      __IOM uint32_t Buffer_2_clock_Select : 1; /*!< 0 : Buffer 2 operates on internal clock ; 1 : Buffer 2 operates
                                                     on external clock received through gpio pin 5                             */
      __IOM uint32_t Buffer_4_clock_Select : 1; /*!< 0 : Buffer 4 operates on internal clock ; 1 : Buffer 4 operates
                                                     on external clock received through gpio pin 6                             */
      __IOM uint32_t Buffer_8_clock_Select : 1; /*!< 0 : Buffer 8 operates on internal clock ; 1 : Buffer 8 operates
                                                     on external clock received through gpio pin 7                             */
      __IOM uint32_t Buffer_2_Clock_Edge_Select : 1;/*!< 0 : Buffer 2 enqueues and dequeues on positive edge of selected
                                                     clock ; 1 : Buffer 2 enqueues and dequeues on negative
                                                     edge of selected clock                                                    */
      __IOM uint32_t Buffer_4_Clock_Edge_Select : 1;/*!< 0 : Buffer 4 enqueues and dequeues on positive edge of selected
                                                     clock ; 1 : Buffer 4 enqueues and dequeues on negative
                                                     edge of selected clock                                                    */
      __IOM uint32_t Buffer_8_Clock_Edge_Select : 1;/*!< 0 : Buffer 8 enqueues and dequeues on positive edge of selected
                                                     clock ; 1 : Buffer 8 enqueues and dequeues on negative
                                                     edge of selected clock                                                    */
      __IOM uint32_t Buffer_2_direction : 1;    /*!< When 0 : buffer 2 enqueue from GPIO is enabled ; 1 : buffer
                                                     2 dequeue to GPIO enabled                                                 */
      __IOM uint32_t Buffer_4_direction : 1;    /*!< When 0 : buffer 4 enqueue from GPIO is enabled ; 1 : buffer
                                                     4 dequeue to GPIO enabled                                                 */
      __IOM uint32_t Buffer_8_direction : 1;    /*!< When 0 : buffer 8 enqueue from GPIO is enabled ; 1 : buffer
                                                     8 dequeue to GPIO enabled                                                 */
      __IOM uint32_t Buffer_2_clear : 1;        /*!< clears buffer 2 data and makes the buffer empty                           */
      __IOM uint32_t Buffer_4_clear : 1;        /*!< clears buffer 4 data and makes the buffer empty                           */
      __IOM uint32_t Buffer_8_clear : 1;        /*!< clears buffer 8 data and makes the buffer empty                           */
      __IOM uint32_t Buffer_2_data_check : 1;   /*!< Size for data availability check in buffer 2 ; 00 : not checking
                                                     for any data ; 01 : checking for 8 bits send or receive
                                                     ; 10 : checking for 16 bits send or receive ; 11 : checking
                                                     for 32 bits send or receive                                               */
      __IOM uint32_t Buffer_4_data_check : 1;   /*!< Size for data availability check in buffer 4 ; 00 : not checking
                                                     for any data ; 01 : checking for 8 bits send or receive
                                                     ; 10 : checking for 16 bits send or receive ; 11 : checking
                                                     for 32 bits send or receive                                               */
      __IOM uint32_t Buffer_8_data_check : 1;   /*!< Size for data availability check in buffer 8 ; 00 : not checking
                                                     for any data ; 01 : checking for 8 bits send or receive
                                                     ; 10 : checking for 16 bits send or receive ; 11 : checking
                                                     for 32 bits send or receive                                               */
      __IOM uint32_t Buffer_12_data_check : 1;  /*!< Size for data availability check in buffer 4 and 8 combined
                                                     as one ; 00 : not checking for any data ; 01 : checking
                                                     for 8 bits send or receive ; 10 : checking for 16 bits
                                                     send or receive ; 11 : checking for 32 bits send or receive               */
            uint32_t            : 13;
    } GPIO_BUFFER_CONTROL_b;
  } ;
  __IM  uint32_t  RESERVED7;
  
  union {
    __IOM uint32_t GPIO_BUFFER_STATUS;          /*!< To read the status of the buffers                                         */
    
    struct {
      __IOM uint32_t Buffer_2_Not_Full : 1;     /*!< Stores 1 if there is space in buffer 2 for an enqueue ; 0 if
                                                     buffer 2 is full                                                          */
      __IOM uint32_t Buffer_2_Not_Empty : 1;    /*!< stores 1 if there is an element to dequeue in buffer 2 ; 0 if
                                                     buffer 2 is empty                                                         */
      __IOM uint32_t Buffer_4_Not_Full : 1;     /*!< Stores 1 if there is space in buffer 4 for an enqueue ; 0 if
                                                     buffer 4 is full                                                          */
      __IOM uint32_t Buffer_4_Not_Empty : 1;    /*!< stores 1 if there is an element to dequeue in buffer 4 ; 0 if
                                                     buffer 4 is empty                                                         */
      __IOM uint32_t Buffer_8_Not_Full : 1;     /*!< Stores 1 if there is space in buffer 8 for an enqueue ; 0 if
                                                     buffer 8 is full                                                          */
      __IOM uint32_t Buffer_8_Not_Empty : 1;    /*!< Stores 1 if there is an element to dequeue in buffer 8 ; 0 if
                                                     buffer 8 is empty                                                         */
      __IOM uint32_t Buffer_2_can_take_input_for_dma : 1;/*!< Stores 1 if there is space available in buffer 2 for the size
                                                     requested by dma, else stores 0                                           */
      __IOM uint32_t Buffer_2_output_ready_for_dma : 1;/*!< Stores 1 if there is data available in buffer 2 for the size
                                                     requested by dma, else stores 0                                           */
      __IOM uint32_t Buffer_4_can_take_input_for_dma : 1;/*!< Stores 1 if there is space available in buffer 4 for the size
                                                     requested by dma, else stores 0                                           */
      __IOM uint32_t Buffer_4_output_ready_for_dma : 1;/*!< Stores 1 if there is data available in buffer 4 for the size
                                                     requested by dma, else stores 0                                           */
      __IOM uint32_t Buffer_8_can_take_input_for_dma : 1;/*!< Stores 1 if there is space available in buffer 8 for the size
                                                     requested by dma, else stores 0                                           */
      __IOM uint32_t Buffer_8_output_ready_for_dma : 1;/*!< Stores 1 if there is data available in buffer 8 for the size
                                                     requested by dma, else stores 0                                           */
      __IOM uint32_t Buffer_12_can_take_input_for_dma : 1;/*!< Stores 1 if there is space available in buffer 4 and 8 combined
                                                     for the size requested by dma, else stores 0                              */
      __IOM uint32_t Buffer_12_output_ready_for_dma : 1;/*!< Stores 1 if there is data available in buffer 4 and 8 combined
                                                     for the size requested by dma, else stores 0                              */
            uint32_t            : 18;
    } GPIO_BUFFER_STATUS_b;
  } ;
  __IM  uint32_t  RESERVED8;
  __IOM uint32_t  GPIO_BUFFER_2_CLOCK_PRESCALAR;/*!< To set the prescalar for buffer 2 internal clock                          */
  __IM  uint32_t  RESERVED9;
  __IOM uint32_t  GPIO_BUFFER_4_CLOCK_PRESCALAR;/*!< To set the prescalar for buffer 4 internal clock                          */
  __IM  uint32_t  RESERVED10;
  __IOM uint32_t  GPIO_BUFFER_8_CLOCK_PRESCALAR;/*!< To set the prescalar for buffer 8 internal clock                          */
  __IM  uint32_t  RESERVED11;
  __IOM uint32_t  GPIO_BUFFER_4_8_CLOCK_PRESCALAR;/*!< To set the prescalar for buffer 12 internal clock                       */
  __IM  uint32_t  RESERVED12;
  __IOM Data  GPIO_BUFFER_2_DATA;           /*!< To read the data from buffer 2                                            */
  __IM  uint32_t  RESERVED13;
  __IOM Data  GPIO_BUFFER_4_DATA;           /*!< To read the data from buffer 4                                            */
  __IM  uint32_t  RESERVED14;
  __IOM Data GPIO_BUFFER_8_DATA;           /*!< To read the data from buffer 8                                            */
  __IM  uint32_t  RESERVED15;
  __IOM Buf_4_8_Data  GPIO_BUFFER_4_8_DATA;         /*!< To read the data from buffer 12                                           */
} GPIO_Type;                                    /*!< Size = 140 (0x8c)                                                         */



/* =========================================================================================================================== */
/* ================                                        GPIO_PINMUX                                        ================ */
/* =========================================================================================================================== */


/**
  * @brief General purpose IO. 13 GPIOs are pinmuxed with secondary level enable (GPIO_PINMUX)
  */

typedef struct {                                /*!< GPIO_PINMUX Structure                                                     */
  __IOM uint32_t  GPIO_DIRECTION;               /*!< Select the direction of the GPIOs. Each bit position corresponds
                                                     to the respective GPIO pin. 0 - Output, 1 - Input                         */
  __IM  uint32_t  RESERVED;
  __IOM uint32_t  GPIO_DATA;                    /*!< Contains the data to be sent out if the GPIO pin is configured
                                                     as output and the data recieved when configured as input.
                                                     Each bit position corresponds to the respective GPIO pin.                 */
  __IM  uint32_t  RESERVED1;
  __IOM uint32_t  GPIO_SET;                     /*!< To set the respective GPIO pins                                           */
  __IM  uint32_t  RESERVED2;
  __IOM uint32_t  GPIO_CLEAR;                   /*!< To clear the respective GPIO pins                                         */
  __IM  uint32_t  RESERVED3;
  __IOM uint32_t  GPIO_TOGGLE;                  /*!< To invert the respective GPIO pins                                        */
  __IM  uint32_t  RESERVED4[3];
  __IOM uint32_t  GPIO_INTR;                    /*!< To enable the interrupt of respective GPIO pins                           */
  __IM  uint32_t  RESERVED5;
  __IOM uint32_t  GPIO_PULLUP_CONFIG;           /*!< To enable the interrupt of respective GPIO pins                           */
} GPIO_PINMUX_Type;                             /*!< Size = 60 (0x3c)                                                          */



/* =========================================================================================================================== */
/* ================                                            AES                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief AES algorithm accelerator (AES)
  */

typedef struct {                                /*!< AES Structure                                                             */
  // __IM  uint32_t  RESERVED[24];
  __IOM uint64_t AES_INPUT;                     /*!<Input text register. Input is given 64 bits at a time.                     */
  
  __IOM uint64_t RESERVED1;                     
  __IOM uint64_t RESERVED2;                     
  __IOM uint64_t RESERVED3;                     
    
  __IOM uint64_t AES_KEY;                       /*!<Key data register. Key is given 64 bits at a time and needs to 
                                                    be written depending on the keylen select                                  */
  
  __IOM uint64_t RESERVED4;                     
  __IOM uint64_t RESERVED5;                     
  __IOM uint64_t RESERVED6;
 
  __IOM uint64_t AES_OUTPUT;                    /*!<Output register. Output is read 64 bits at a time.                         */
  
  __IOM uint64_t RESERVED7;                     
  __IOM uint64_t RESERVED8;                     
  __IOM uint64_t RESERVED9;
  
  __IOM uint64_t AES_IV;                        /*!<Initialization vector register. IV is given 64 bits at a time.             */
  __IOM uint64_t RESERVED10;
  
  union {
    __IOM uint8_t AES_CTRL;                     /*!< Control register                                                          */
    
    struct {
      __IOM uint8_t AES_CTRL_ENCDEC : 1;        /*!< 0 - Encrypt, 1 - Decrypt                                                  */
      __IOM uint8_t AES_CTRL_KEYLEN : 2;        /*!< To select the lenght of key. 0 - 128 bits, 1 - 192 bits, 2 -
                                                     256 bits                                                                  */
      __IOM uint8_t AES_CTRL_MODE : 3;          /*!< 0-ECB, 1-CBC, 2-CFB, 3-OFB, 4-CTR                                         */
      __IOM uint8_t AES_CTRL_END : 1;           /*!< To specify end of message                                                 */
            uint8_t             : 1;
    } AES_CTRL_b;
  } ;
  
  union {
    __IOM uint8_t AES_STATUS;                   /*!< To check the status.                                                      */
    
    struct {
      __IOM uint8_t AES_STATUS_CAN_TAKE_INPUT : 1;/*!< AES is ready to take the input                                          */
      __IOM uint8_t AES_STATUS_OUTP_READY : 1;  /*!< Becomes 1 when the accelerator has computed the output                    */
            uint8_t             : 6;
    } AES_STATUS_b;
  } ;
  
  __IM  uint16_t  RESERVED11;
} AES_Type;                                     /*!< Size = 100 (0x64)                                                         */



/* =========================================================================================================================== */
/* ================                                          SHA256                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief SHA256 algorithm accelerator (SHA256)
  */

typedef struct {                                /*!< SHA256 Structure                                                          */
  // __IM  uint32_t  RESERVED[48];
  __IOM uint64_t SHA_INPUT;                     /*!< Input text register. Input is given 64 bits at a time.                    */
  
  __IOM uint64_t RESERVED1;
  __IOM uint64_t RESERVED2;
  __IOM uint64_t RESERVED3;
  __IOM uint64_t RESERVED4;
  __IOM uint64_t RESERVED5;
  __IOM uint64_t RESERVED6;
  __IOM uint64_t RESERVED7;
  __IOM uint64_t RESERVED8;
  __IOM uint64_t RESERVED9;
  __IOM uint64_t RESERVED10;
  __IOM uint64_t RESERVED11;
  __IOM uint64_t RESERVED12;
  __IOM uint64_t RESERVED13;
  __IOM uint64_t RESERVED14;
  __IOM uint64_t RESERVED15;
  
  __IOM uint64_t SHA_OUTPUT;                    /*!< Output text register. Input is given 64 bits at a time.                   */

  __IOM uint64_t RESERVED16;
  __IOM uint64_t RESERVED17;
  __IOM uint64_t RESERVED18;
  __IOM uint64_t RESERVED19;
  __IOM uint64_t RESERVED20;
  __IOM uint64_t RESERVED21;
  __IOM uint64_t RESERVED22;

  union {
    __IOM uint8_t SHA_CTRL;                     /*!< Control register                                                          */
    
    struct {
      __IOM uint8_t CONT_PREHASH : 1;           /*!< To continue the hash calculated from previous block to next
                                                     block or not. 1 - continue from previous block. 0 - Initial
                                                     prehash                                                                   */
            uint8_t             : 7;
    } SHA_CTRL_b;
  } ;
  
  union {
    __IM  uint8_t SHA_STATUS;                   /*!< To read the status register                                               */
    
    struct {
      __IM  uint8_t SHA_STATUS_READY : 1;       /*!< Sha is ready to take another input                                        */
      __IM  uint8_t SHA_STATUS_OUT_READY : 1;   /*!< The output of the SHA is ready                                            */
            uint8_t             : 6;
    } SHA_STATUS_b;
  } ;
  
  __IM  uint16_t  RESERVED23;
} SHA256_Type;                                  /*!< Size = 196 (0xc4)                                                         */



/* =========================================================================================================================== */
/* ================                                            RSA                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief RSA crypto accelerator (RSA)
  */

typedef struct {                                /*!< RSA Structure                                                             */
  // __IM  uint32_t  RESERVED[48];
  __IOM uint64_t RSA_INPUT;                     /*!< RSA input register                                                        */
  
  __IOM uint64_t RESERVED1;                     
  __IOM uint64_t RESERVED2;                     
  __IOM uint64_t RESERVED3;

  __IOM uint64_t RSA_EXP;                       /*!< RSA exponent register                                                     */

  __IOM uint64_t RESERVED4;                     
  __IOM uint64_t RESERVED5;                     
  __IOM uint64_t RESERVED6;
  
  __IOM uint64_t RSA_MOD;                       /*!< RSA modulus register                                                      */
  
  __IOM uint64_t RESERVED7;                     
  __IOM uint64_t RESERVED8;                     
  __IOM uint64_t RESERVED9;

  __IOM uint64_t RSA_RSqrMODN;                  /*!< RSA modulus register                                                      */
  
  __IOM uint64_t RESERVED10;                     
  __IOM uint64_t RESERVED11;                     
  __IOM uint64_t RESERVED12;

  __IOM uint64_t RSA_OUTPUT;                  /*!< RSA modulus register                                                      */

  __IOM uint64_t RESERVED13;                     
  __IOM uint64_t RESERVED14;                     
  __IOM uint64_t RESERVED15;
  __IOM uint64_t RESERVED16;
  __IOM uint64_t RESERVED17;
  __IOM uint64_t RESERVED18;

  union {
    __IM  uint8_t RSA_STATUS;                   /*!< RSA status register                                                       */
    
    struct {
      __IM  uint8_t RSA_OUTP_READY : 1;         /*!< RSA can give output                                                       */
      __IM  uint8_t RSA_STATUS_READY : 1;       /*!< RSA is ready to take input                                                */
            uint8_t             : 6;
    } RSA_STATUS_b;
  } ;

  __IM  uint8_t   RESERVED19;
  __IM  uint16_t  RESERVED20;
} RSA_Type;                                     /*!< Size = 196 (0xc4)                                                         */



/* =========================================================================================================================== */
/* ================                                           SPI                                             ================ */
/* =========================================================================================================================== */


/**
  * @brief SPI communication peripheral (SPI0)
  */

typedef struct {                                /*!< SPI0 Structure                                                            */
  
  union {
    __IOM uint32_t CTRL;                        /*!< SPI communication control register                                        */
    
    struct {
      __IOM uint32_t SLAVE_MODE : 1;            /*!< holds the spi slave mode. If set, spi will act as a slave device,
                                                     else it will be in master mode                                            */
      __IOM uint32_t EN         : 1;            /*!< holds the spi enable control. Once set, spi transaction will
                                                     start and it will be reset at the end of spi transaction                  */
      __IOM uint32_t LSBFIRST   : 1;            /*!< holds whether the spi transaction is LSB first. If set LSB first
                                                     else MSB first                                                            */
      __IOM uint32_t RX_FLUSH   : 1;            /*!< Flush the rx fifo                                                         */
      __IOM uint32_t COMM_MODE  : 2;            /*!< holds the communication mode of the spi transaction. 00 - only
                                                     transmit; 01 - only receive; 10 - transmit and immediate
                                                     receive; 11 - transmit and receive                                        */
      __IOM uint32_t TOTAL_BIT_TX : 8;          /*!< holds the total number of bits to be received in a spi transaction        */
      __IOM uint32_t TOTAL_BIT_RX : 8;          /*!< holds the total number of bits to be transmitted in a spi transaction     */
      __IOM uint32_t SCLK_OUTEN : 1;            /*!< holds the SCLK pin's output enable. If set, the controller generates
                                                     the sclk else sclk is expected from the spi device                        */
      __IOM uint32_t NCS_OUTEN  : 1;            /*!< holds the NCS pin's output enable. If set, the controller generates
                                                     the ncs else ncs is expected from the spi device                          */
      __IOM uint32_t MISO_OUTEN : 1;            /*!< holds the MISO pin's output enable. If set, output is transmitted
                                                     through this pin else input is read from this pin                         */
      __IOM uint32_t MOSI_OUTEN : 1;            /*!< holds the MOSI pin's output enable. If set, output is transmitted
                                                     through this pin else input is read from this pin                         */
      __IOM uint32_t TX_DMA_SIZE : 3;           /*!< holds the dma transmit transcation size in bytes                          */
      __IOM uint32_t RX_DMA_SIZE : 3;           /*!< holds the dma receive transcation size in bytes                           */
    } CTRL_b;
  } ;
  
  union {
    __IOM uint32_t CLK_CTRL;                    /*!< SPI clock generation control register                                     */
    
    struct {
      __IOM uint32_t CLK_POLARITY : 1;          /*!< holds the clock polarity                                                  */
      __IOM uint32_t CLK_PHASE  : 1;            /*!< holds the clock phase                                                     */
      __IOM uint32_t CLK_PRESCALAR : 14;        /*!< holds the prescaller value of the sclk                                    */
      __IOM uint32_t SETUP_DELAY : 8;           /*!< holds the setup delay                                                     */
      __IOM uint32_t HOLD_DELAY : 8;            /*!< holds the hold delay                                                      */
    } CLK_CTRL_b;
  } ;
  __IOM Data  TX;                           /*!< holds the tx data. This register is written by the AXI write
                                                     request and once written the data is transferred to TX
                                                     FIFO                                                                      */
  __IOM Data  RX;                           /*!< holds the tx data. This register is read by the AXI read request.
                                                     The data is written from the RX FIFO                                      */
  
  union {
    __IOM uint32_t INTR_EN;                     /*!< Spi interrupt enable register                                             */
    
    struct {
      __IOM uint32_t TX_FIFO_EMPTY_INTR_EN : 1; /*!< TX FIFO empty interrupt enable bit. This when set, interrupt
                                                     is sent to PLIC when TX FIFO is empty                                     */
      __IOM uint32_t TX_FIFO_DUAL_INTR_EN : 1;  /*!< TX FIFO full interrupt enable bit. This when set, interrupt
                                                     is sent to PLIC when TX FIFO is filled by 2 entries                       */
      __IOM uint32_t TX_FIFO_QUAD_INTR_EN : 1;  /*!< TX FIFO full interrupt enable bit. This when set, interrupt
                                                     is sent to PLIC when TX FIFO is filled by 4 entries                       */
      __IOM uint32_t TX_FIFO_OCTAL_INTR_EN : 1; /*!< TX FIFO full interrupt enable bit. This when set, interrupt
                                                     is sent to PLIC when TX FIFO is filled by 8 entries                       */
      __IOM uint32_t TX_FIFO_HALF_INTR_EN : 1;  /*!< TX FIFO full interrupt enable bit. This when set, interrupt
                                                     is sent to PLIC when TX FIFO is filled by 16 entries                      */
      __IOM uint32_t TX_FIFO_24_INTR_EN : 1;    /*!< TX FIFO full interrupt enable bit. This when set, interrupt
                                                     is sent to PLIC when TX FIFO is filled by 24 entries                      */
      __IOM uint32_t TX_FIFO_28_INTR_EN : 1;    /*!< TX FIFO full interrupt enable bit. This when set, interrupt
                                                     is sent to PLIC when TX FIFO is filled by 28 entries                      */
      __IOM uint32_t TX_FIFO_30_INTR_EN : 1;    /*!< TX FIFO full interrupt enable bit. This when set, interrupt
                                                     is sent to PLIC when TX FIFO is filled by 30 entries                      */
      __IOM uint32_t TX_FIFO_FULL_INTR_EN : 1;  /*!< TX FIFO full interrupt enable bit. This when set, interrupt
                                                     is sent to PLIC when TX FIFO is full - 32 entries                         */
      __IOM uint32_t RX_FIFO_EMPTY_INTR_EN : 1; /*!< RX FIFO empty interrupt enable bit. This when set, interrupt
                                                     is sent to PLIC when RX FIFO is empty                                     */
      __IOM uint32_t RX_FIFO_DUAL_INTR_EN : 1;  /*!< RX FIFO full interrupt enable bit. This when set, interrupt
                                                     is sent to PLIC when RX FIFO is filled by 2 entries                       */
      __IOM uint32_t RX_FIFO_QUAD_INTR_EN : 1;  /*!< RX FIFO full interrupt enable bit. This when set, interrupt
                                                     is sent to PLIC when RX FIFO is filled by 4 entries                       */
      __IOM uint32_t RX_FIFO_OCTAL_INTR_EN : 1; /*!< RX FIFO full interrupt enable bit. This when set, interrupt
                                                     is sent to PLIC when RX FIFO is filled by 8 entries                       */
      __IOM uint32_t RX_FIFO_HALF_INTR_EN : 1;  /*!< RX FIFO full interrupt enable bit. This when set, interrupt
                                                     is sent to PLIC when RX FIFO is filled by 16 entries                      */
      __IOM uint32_t RX_FIFO_24_INTR_EN : 1;    /*!< RX FIFO full interrupt enable bit. This when set, interrupt
                                                     is sent to PLIC when RX FIFO is filled by 24 entries                      */
      __IOM uint32_t RX_FIFO_28_INTR_EN : 1;    /*!< RX FIFO full interrupt enable bit. This when set, interrupt
                                                     is sent to PLIC when RX FIFO is filled by 28 entries                      */
      __IOM uint32_t RX_FIFO_30_INTR_EN : 1;    /*!< RX FIFO full interrupt enable bit. This when set, interrupt
                                                     is sent to PLIC when RX FIFO is filled by 30 entries                      */
      __IOM uint32_t RX_FIFO_FULL_INTR_EN : 1;  /*!< RX FIFO full interrupt enable bit. This when set, interrupt
                                                     is sent to PLIC when RX FIFO is full - 32 entries                         */
            uint32_t            : 14;
    } INTR_EN_b;
  } ;
  
  union {
    __IOM uint32_t FIFO_STATUS;                 /*!< Gives the status of TX/RX FIFO                                            */
    
    struct {
      __IOM uint32_t TX_FIFO_EMPTY : 1;         /*!< TX FIFO empty. TX FIFO is empty                                           */
      __IOM uint32_t TX_FIFO_DUAL : 1;          /*!< TX FIFO full. TX FIFO is filled by 2 entries                              */
      __IOM uint32_t TX_FIFO_QUAD : 1;          /*!< TX FIFO full. TX FIFO is filled by 4 entries                              */
      __IOM uint32_t TX_FIFO_OCTAL : 1;         /*!< TX FIFO full. TX FIFO is filled by 8 entries                              */
      __IOM uint32_t TX_FIFO_HALF : 1;          /*!< TX FIFO full. TX FIFO is filled by 16 entries                             */
      __IOM uint32_t TX_FIFO_24 : 1;            /*!< TX FIFO full. TX FIFO is filled by 24 entries                             */
      __IOM uint32_t TX_FIFO_28 : 1;            /*!< TX FIFO full. TX FIFO is filled by 28 entries                             */
      __IOM uint32_t TX_FIFO_30 : 1;            /*!< TX FIFO full. TX FIFO is filled by 30 entries                             */
      __IOM uint32_t TX_FIFO_FULL : 1;          /*!< TX FIFO full. TX FIFO is full - 32 entries                                */
      __IOM uint32_t RX_FIFO_EMPTY : 1;         /*!< RX FIFO empty. RX FIFO is empty                                           */
      __IOM uint32_t RX_FIFO_DUAL : 1;          /*!< RX FIFO full. RX FIFO is filled by 2 entries                              */
      __IOM uint32_t RX_FIFO_QUAD : 1;          /*!< RX FIFO full. RX FIFO is filled by 4 entries                              */
      __IOM uint32_t RX_FIFO_OCTAL : 1;         /*!< RX FIFO full. RX FIFO is filled by 8 entries                              */
      __IOM uint32_t RX_FIFO_HALF : 1;          /*!< RX FIFO full. RX FIFO is filled by 16 entries                             */
      __IOM uint32_t RX_FIFO_24 : 1;            /*!< RX FIFO full. RX FIFO is filled by 24 entries                             */
      __IOM uint32_t RX_FIFO_28 : 1;            /*!< RX FIFO full. RX FIFO is filled by 28 entries                             */
      __IOM uint32_t RX_FIFO_30 : 1;            /*!< RX FIFO full. RX FIFO is filled by 30 entries                             */
      __IOM uint32_t RX_FIFO_FULL : 1;          /*!< RX FIFO full. RX FIFO is full - 32 entries                                */
            uint32_t            : 14;
    } FIFO_STATUS_b;
  } ;
  
  union {
    __IOM uint16_t COMM_STATUS;                 /*!< Status of SPI communication                                               */
    
    struct {
      __IOM uint16_t BUSY       : 1;            /*!< SPI Busy bit. This will be set when NCS goes low and will be
                                                     reset when NCS goes high                                                  */
      __IOM uint16_t TX_STARTED : 1;            /*!< Transmit enable bit. This bit will be set when the transmit
                                                     operation starts and will be reset once the transmit operation
                                                     is complete                                                               */
      __IOM uint16_t RX_STARTED : 1;            /*!< Receive not enable bit. This bit will be reset when the receive
                                                     operation starts and will be set once the receive operation
                                                     is complete                                                               */
      __IOM uint16_t TX_DEPTH   : 3;            /*!< TX FIFO Threshold bits to know the number of entries in the
                                                     TX FIFO                                                                   */
      __IOM uint16_t RX_DEPTH   : 3;            /*!< RX FIFO Threshold bits to know the number of entries in the
                                                     RX FIFO.                                                                  */
      __IOM uint16_t OVERRUN    : 1;            /*!< Overrun bit. This will be set when there is an overrun during
                                                     receive operation                                                         */
            uint16_t            : 6;
    } COMM_STATUS_b;
  } ;
  __IM  uint16_t  RESERVED;
  
  union {
    __IOM uint8_t NCS_CTRL;                     /*!< SPI ncs control register                                                  */
    
    struct {
      __IOM uint8_t NCS_SELECT  : 1;            /*!< Used to select between the hardware ncs and the software ncs.
                                                     If set to high, then it selects the software controlled
                                                     ncs. Else , it selects the hardware ncs                                   */
      __IOM uint8_t NCS_SW      : 1;            /*!< holds the value of software controlled ncs                                */
            uint8_t             : 6;
    } NCS_CTRL_b;
  } ;
  __IM  uint8_t   RESERVED1;
  __IM  uint16_t  RESERVED2;
} SPI_Type;                                    /*!< Size = 32 (0x20)                                                          */



/* =========================================================================================================================== */
/* ================                                           SPI1                                            ================ */
/* =========================================================================================================================== */


// /**
//   * @brief SPI communication peripheral (SPI1)
//   */

// typedef struct {                                /*!< SPI1 Structure                                                            */
  
//   union {
//     __IOM uint32_t CTRL;                        /*!< SPI communication control register                                        */
    
//     struct {
//       __IOM uint32_t SLAVE_MODE : 1;            /*!< holds the spi slave mode. If set, spi will act as a slave device,
//                                                      else it will be in master mode                                            */
//       __IOM uint32_t EN         : 1;            /*!< holds the spi enable control. Once set, spi transaction will
//                                                      start and it will be reset at the end of spi transaction                  */
//       __IOM uint32_t LSBFIRST   : 1;            /*!< holds whether the spi transaction is LSB first. If set LSB first
//                                                      else MSB first                                                            */
//       __IOM uint32_t RX_FLUSH   : 1;            /*!< Flush the rx fifo                                                         */
//       __IOM uint32_t COMM_MODE  : 2;            /*!< holds the communication mode of the spi transaction. 00 - only
//                                                      transmit; 01 - only receive; 10 - transmit and immediate
//                                                      receive; 11 - transmit and receive                                        */
//       __IOM uint32_t TOTAL_BIT_TX : 8;          /*!< holds the total number of bits to be received in a spi transaction        */
//       __IOM uint32_t TOTAL_BIT_RX : 8;          /*!< holds the total number of bits to be transmitted in a spi transaction     */
//       __IOM uint32_t SCLK_OUTEN : 1;            /*!< holds the SCLK pin's output enable. If set, the controller generates
//                                                      the sclk else sclk is expected from the spi device                        */
//       __IOM uint32_t NCS_OUTEN  : 1;            /*!< holds the NCS pin's output enable. If set, the controller generates
//                                                      the ncs else ncs is expected from the spi device                          */
//       __IOM uint32_t MISO_OUTEN : 1;            /*!< holds the MISO pin's output enable. If set, output is transmitted
//                                                      through this pin else input is read from this pin                         */
//       __IOM uint32_t MOSI_OUTEN : 1;            /*!< holds the MOSI pin's output enable. If set, output is transmitted
//                                                      through this pin else input is read from this pin                         */
//       __IOM uint32_t TX_DMA_SIZE : 3;           /*!< holds the dma transmit transcation size in bytes                          */
//       __IOM uint32_t RX_DMA_SIZE : 3;           /*!< holds the dma receive transcation size in bytes                           */
//     } CTRL_b;
//   } ;
  
//   union {
//     __IOM uint32_t CLK_CTRL;                    /*!< SPI clock generation control register                                     */
    
//     struct {
//       __IOM uint32_t CLK_POLARITY : 1;          /*!< holds the clock polarity                                                  */
//       __IOM uint32_t CLK_PHASE  : 1;            /*!< holds the clock phase                                                     */
//       __IOM uint32_t CLK_PRESCALAR : 14;        /*!< holds the prescaller value of the sclk                                    */
//       __IOM uint32_t SETUP_DELAY : 8;           /*!< holds the setup delay                                                     */
//       __IOM uint32_t HOLD_DELAY : 8;            /*!< holds the hold delay                                                      */
//     } CLK_CTRL_b;
//   } ;
//   __IOM uint32_t  TX;                           /*!< holds the tx data. This register is written by the AXI write
//                                                      request and once written the data is transferred to TX
//                                                      FIFO                                                                      */
//   __IOM uint32_t  RX;                           /*!< holds the tx data. This register is read by the AXI read request.
//                                                      The data is written from the RX FIFO                                      */
  
//   union {
//     __IOM uint32_t INTR_EN;                     /*!< Spi interrupt enable register                                             */
    
//     struct {
//       __IOM uint32_t TX_FIFO_EMPTY_INTR_EN : 1; /*!< TX FIFO empty interrupt enable bit. This when set, interrupt
//                                                      is sent to PLIC when TX FIFO is empty                                     */
//       __IOM uint32_t TX_FIFO_DUAL_INTR_EN : 1;  /*!< TX FIFO full interrupt enable bit. This when set, interrupt
//                                                      is sent to PLIC when TX FIFO is filled by 2 entries                       */
//       __IOM uint32_t TX_FIFO_QUAD_INTR_EN : 1;  /*!< TX FIFO full interrupt enable bit. This when set, interrupt
//                                                      is sent to PLIC when TX FIFO is filled by 4 entries                       */
//       __IOM uint32_t TX_FIFO_OCTAL_INTR_EN : 1; /*!< TX FIFO full interrupt enable bit. This when set, interrupt
//                                                      is sent to PLIC when TX FIFO is filled by 8 entries                       */
//       __IOM uint32_t TX_FIFO_HALF_INTR_EN : 1;  /*!< TX FIFO full interrupt enable bit. This when set, interrupt
//                                                      is sent to PLIC when TX FIFO is filled by 16 entries                      */
//       __IOM uint32_t TX_FIFO_24_INTR_EN : 1;    /*!< TX FIFO full interrupt enable bit. This when set, interrupt
//                                                      is sent to PLIC when TX FIFO is filled by 24 entries                      */
//       __IOM uint32_t TX_FIFO_28_INTR_EN : 1;    /*!< TX FIFO full interrupt enable bit. This when set, interrupt
//                                                      is sent to PLIC when TX FIFO is filled by 28 entries                      */
//       __IOM uint32_t TX_FIFO_30_INTR_EN : 1;    /*!< TX FIFO full interrupt enable bit. This when set, interrupt
//                                                      is sent to PLIC when TX FIFO is filled by 30 entries                      */
//       __IOM uint32_t TX_FIFO_FULL_INTR_EN : 1;  /*!< TX FIFO full interrupt enable bit. This when set, interrupt
//                                                      is sent to PLIC when TX FIFO is full - 32 entries                         */
//       __IOM uint32_t RX_FIFO_EMPTY_INTR_EN : 1; /*!< RX FIFO empty interrupt enable bit. This when set, interrupt
//                                                      is sent to PLIC when RX FIFO is empty                                     */
//       __IOM uint32_t RX_FIFO_DUAL_INTR_EN : 1;  /*!< RX FIFO full interrupt enable bit. This when set, interrupt
//                                                      is sent to PLIC when RX FIFO is filled by 2 entries                       */
//       __IOM uint32_t RX_FIFO_QUAD_INTR_EN : 1;  /*!< RX FIFO full interrupt enable bit. This when set, interrupt
//                                                      is sent to PLIC when RX FIFO is filled by 4 entries                       */
//       __IOM uint32_t RX_FIFO_OCTAL_INTR_EN : 1; /*!< RX FIFO full interrupt enable bit. This when set, interrupt
//                                                      is sent to PLIC when RX FIFO is filled by 8 entries                       */
//       __IOM uint32_t RX_FIFO_HALF_INTR_EN : 1;  /*!< RX FIFO full interrupt enable bit. This when set, interrupt
//                                                      is sent to PLIC when RX FIFO is filled by 16 entries                      */
//       __IOM uint32_t RX_FIFO_24_INTR_EN : 1;    /*!< RX FIFO full interrupt enable bit. This when set, interrupt
//                                                      is sent to PLIC when RX FIFO is filled by 24 entries                      */
//       __IOM uint32_t RX_FIFO_28_INTR_EN : 1;    /*!< RX FIFO full interrupt enable bit. This when set, interrupt
//                                                      is sent to PLIC when RX FIFO is filled by 28 entries                      */
//       __IOM uint32_t RX_FIFO_30_INTR_EN : 1;    /*!< RX FIFO full interrupt enable bit. This when set, interrupt
//                                                      is sent to PLIC when RX FIFO is filled by 30 entries                      */
//       __IOM uint32_t RX_FIFO_FULL_INTR_EN : 1;  /*!< RX FIFO full interrupt enable bit. This when set, interrupt
//                                                      is sent to PLIC when RX FIFO is full - 32 entries                         */
//             uint32_t            : 14;
//     } INTR_EN_b;
//   } ;
  
//   union {
//     __IOM uint32_t FIFO_STATUS;                 /*!< Gives the status of TX/RX FIFO                                            */
    
//     struct {
//       __IOM uint32_t TX_FIFO_EMPTY : 1;         /*!< TX FIFO empty. TX FIFO is empty                                           */
//       __IOM uint32_t TX_FIFO_DUAL : 1;          /*!< TX FIFO full. TX FIFO is filled by 2 entries                              */
//       __IOM uint32_t TX_FIFO_QUAD : 1;          /*!< TX FIFO full. TX FIFO is filled by 4 entries                              */
//       __IOM uint32_t TX_FIFO_OCTAL : 1;         /*!< TX FIFO full. TX FIFO is filled by 8 entries                              */
//       __IOM uint32_t TX_FIFO_HALF : 1;          /*!< TX FIFO full. TX FIFO is filled by 16 entries                             */
//       __IOM uint32_t TX_FIFO_24 : 1;            /*!< TX FIFO full. TX FIFO is filled by 24 entries                             */
//       __IOM uint32_t TX_FIFO_28 : 1;            /*!< TX FIFO full. TX FIFO is filled by 28 entries                             */
//       __IOM uint32_t TX_FIFO_30 : 1;            /*!< TX FIFO full. TX FIFO is filled by 30 entries                             */
//       __IOM uint32_t TX_FIFO_FULL : 1;          /*!< TX FIFO full. TX FIFO is full - 32 entries                                */
//       __IOM uint32_t RX_FIFO_EMPTY : 1;         /*!< RX FIFO empty. RX FIFO is empty                                           */
//       __IOM uint32_t RX_FIFO_DUAL : 1;          /*!< RX FIFO full. RX FIFO is filled by 2 entries                              */
//       __IOM uint32_t RX_FIFO_QUAD : 1;          /*!< RX FIFO full. RX FIFO is filled by 4 entries                              */
//       __IOM uint32_t RX_FIFO_OCTAL : 1;         /*!< RX FIFO full. RX FIFO is filled by 8 entries                              */
//       __IOM uint32_t RX_FIFO_HALF : 1;          /*!< RX FIFO full. RX FIFO is filled by 16 entries                             */
//       __IOM uint32_t RX_FIFO_24 : 1;            /*!< RX FIFO full. RX FIFO is filled by 24 entries                             */
//       __IOM uint32_t RX_FIFO_28 : 1;            /*!< RX FIFO full. RX FIFO is filled by 28 entries                             */
//       __IOM uint32_t RX_FIFO_30 : 1;            /*!< RX FIFO full. RX FIFO is filled by 30 entries                             */
//       __IOM uint32_t RX_FIFO_FULL : 1;          /*!< RX FIFO full. RX FIFO is full - 32 entries                                */
//             uint32_t            : 14;
//     } FIFO_STATUS_b;
//   } ;
  
//   union {
//     __IOM uint16_t COMM_STATUS;                 /*!< Status of SPI communication                                               */
    
//     struct {
//       __IOM uint16_t BUSY       : 1;            /*!< SPI Busy bit. This will be set when NCS goes low and will be
//                                                      reset when NCS goes high                                                  */
//       __IOM uint16_t TX_STARTED : 1;            /*!< Transmit enable bit. This bit will be set when the transmit
//                                                      operation starts and will be reset once the transmit operation
//                                                      is complete                                                               */
//       __IOM uint16_t RX_STARTED : 1;            /*!< Receive not enable bit. This bit will be reset when the receive
//                                                      operation starts and will be set once the receive operation
//                                                      is complete                                                               */
//       __IOM uint16_t TX_DEPTH   : 3;            /*!< TX FIFO Threshold bits to know the number of entries in the
//                                                      TX FIFO                                                                   */
//       __IOM uint16_t RX_DEPTH   : 3;            /*!< RX FIFO Threshold bits to know the number of entries in the
//                                                      RX FIFO.                                                                  */
//       __IOM uint16_t OVERRUN    : 1;            /*!< Overrun bit. This will be set when there is an overrun during
//                                                      receive operation                                                         */
//             uint16_t            : 6;
//     } COMM_STATUS_b;
//   } ;
//   __IM  uint16_t  RESERVED;
  
//   union {
//     __IOM uint8_t NCS_CTRL;                     /*!< SPI ncs control register                                                  */
    
//     struct {
//       __IOM uint8_t NCS_SELECT  : 1;            /*!< Used to select between the hardware ncs and the software ncs.
//                                                      If set to high, then it selects the software controlled
//                                                      ncs. Else , it selects the hardware ncs                                   */
//       __IOM uint8_t NCS_SW      : 1;            /*!< holds the value of software controlled ncs                                */
//             uint8_t             : 6;
//     } NCS_CTRL_b;
//   } ;
//   __IM  uint8_t   RESERVED1;
//   __IM  uint16_t  RESERVED2;
// } SPI1_Type;                                    /*!< Size = 32 (0x20)                                                          */



/* =========================================================================================================================== */
/* ================                                           SPI2                                            ================ */
/* =========================================================================================================================== */


// /**
//   * @brief SPI communication peripheral (SPI2)
//   */

// typedef struct {                                /*!< SPI2 Structure                                                            */
  
//   union {
//     __IOM uint32_t CTRL;                        /*!< SPI communication control register                                        */
    
//     struct {
//       __IOM uint32_t SLAVE_MODE : 1;            /*!< holds the spi slave mode. If set, spi will act as a slave device,
//                                                      else it will be in master mode                                            */
//       __IOM uint32_t EN         : 1;            /*!< holds the spi enable control. Once set, spi transaction will
//                                                      start and it will be reset at the end of spi transaction                  */
//       __IOM uint32_t LSBFIRST   : 1;            /*!< holds whether the spi transaction is LSB first. If set LSB first
//                                                      else MSB first                                                            */
//       __IOM uint32_t RX_FLUSH   : 1;            /*!< Flush the rx fifo                                                         */
//       __IOM uint32_t COMM_MODE  : 2;            /*!< holds the communication mode of the spi transaction. 00 - only
//                                                      transmit; 01 - only receive; 10 - transmit and immediate
//                                                      receive; 11 - transmit and receive                                        */
//       __IOM uint32_t TOTAL_BIT_TX : 8;          /*!< holds the total number of bits to be received in a spi transaction        */
//       __IOM uint32_t TOTAL_BIT_RX : 8;          /*!< holds the total number of bits to be transmitted in a spi transaction     */
//       __IOM uint32_t SCLK_OUTEN : 1;            /*!< holds the SCLK pin's output enable. If set, the controller generates
//                                                      the sclk else sclk is expected from the spi device                        */
//       __IOM uint32_t NCS_OUTEN  : 1;            /*!< holds the NCS pin's output enable. If set, the controller generates
//                                                      the ncs else ncs is expected from the spi device                          */
//       __IOM uint32_t MISO_OUTEN : 1;            /*!< holds the MISO pin's output enable. If set, output is transmitted
//                                                      through this pin else input is read from this pin                         */
//       __IOM uint32_t MOSI_OUTEN : 1;            /*!< holds the MOSI pin's output enable. If set, output is transmitted
//                                                      through this pin else input is read from this pin                         */
//       __IOM uint32_t TX_DMA_SIZE : 3;           /*!< holds the dma transmit transcation size in bytes                          */
//       __IOM uint32_t RX_DMA_SIZE : 3;           /*!< holds the dma receive transcation size in bytes                           */
//     } CTRL_b;
//   } ;
  
//   union {
//     __IOM uint32_t CLK_CTRL;                    /*!< SPI clock generation control register                                     */
    
//     struct {
//       __IOM uint32_t CLK_POLARITY : 1;          /*!< holds the clock polarity                                                  */
//       __IOM uint32_t CLK_PHASE  : 1;            /*!< holds the clock phase                                                     */
//       __IOM uint32_t CLK_PRESCALAR : 14;        /*!< holds the prescaller value of the sclk                                    */
//       __IOM uint32_t SETUP_DELAY : 8;           /*!< holds the setup delay                                                     */
//       __IOM uint32_t HOLD_DELAY : 8;            /*!< holds the hold delay                                                      */
//     } CLK_CTRL_b;
//   } ;
//   __IOM uint32_t  TX;                           /*!< holds the tx data. This register is written by the AXI write
//                                                      request and once written the data is transferred to TX
//                                                      FIFO                                                                      */
//   __IOM uint32_t  RX;                           /*!< holds the tx data. This register is read by the AXI read request.
//                                                      The data is written from the RX FIFO                                      */
  
//   union {
//     __IOM uint32_t INTR_EN;                     /*!< Spi interrupt enable register                                             */
    
//     struct {
//       __IOM uint32_t TX_FIFO_EMPTY_INTR_EN : 1; /*!< TX FIFO empty interrupt enable bit. This when set, interrupt
//                                                      is sent to PLIC when TX FIFO is empty                                     */
//       __IOM uint32_t TX_FIFO_DUAL_INTR_EN : 1;  /*!< TX FIFO full interrupt enable bit. This when set, interrupt
//                                                      is sent to PLIC when TX FIFO is filled by 2 entries                       */
//       __IOM uint32_t TX_FIFO_QUAD_INTR_EN : 1;  /*!< TX FIFO full interrupt enable bit. This when set, interrupt
//                                                      is sent to PLIC when TX FIFO is filled by 4 entries                       */
//       __IOM uint32_t TX_FIFO_OCTAL_INTR_EN : 1; /*!< TX FIFO full interrupt enable bit. This when set, interrupt
//                                                      is sent to PLIC when TX FIFO is filled by 8 entries                       */
//       __IOM uint32_t TX_FIFO_HALF_INTR_EN : 1;  /*!< TX FIFO full interrupt enable bit. This when set, interrupt
//                                                      is sent to PLIC when TX FIFO is filled by 16 entries                      */
//       __IOM uint32_t TX_FIFO_24_INTR_EN : 1;    /*!< TX FIFO full interrupt enable bit. This when set, interrupt
//                                                      is sent to PLIC when TX FIFO is filled by 24 entries                      */
//       __IOM uint32_t TX_FIFO_28_INTR_EN : 1;    /*!< TX FIFO full interrupt enable bit. This when set, interrupt
//                                                      is sent to PLIC when TX FIFO is filled by 28 entries                      */
//       __IOM uint32_t TX_FIFO_30_INTR_EN : 1;    /*!< TX FIFO full interrupt enable bit. This when set, interrupt
//                                                      is sent to PLIC when TX FIFO is filled by 30 entries                      */
//       __IOM uint32_t TX_FIFO_FULL_INTR_EN : 1;  /*!< TX FIFO full interrupt enable bit. This when set, interrupt
//                                                      is sent to PLIC when TX FIFO is full - 32 entries                         */
//       __IOM uint32_t RX_FIFO_EMPTY_INTR_EN : 1; /*!< RX FIFO empty interrupt enable bit. This when set, interrupt
//                                                      is sent to PLIC when RX FIFO is empty                                     */
//       __IOM uint32_t RX_FIFO_DUAL_INTR_EN : 1;  /*!< RX FIFO full interrupt enable bit. This when set, interrupt
//                                                      is sent to PLIC when RX FIFO is filled by 2 entries                       */
//       __IOM uint32_t RX_FIFO_QUAD_INTR_EN : 1;  /*!< RX FIFO full interrupt enable bit. This when set, interrupt
//                                                      is sent to PLIC when RX FIFO is filled by 4 entries                       */
//       __IOM uint32_t RX_FIFO_OCTAL_INTR_EN : 1; /*!< RX FIFO full interrupt enable bit. This when set, interrupt
//                                                      is sent to PLIC when RX FIFO is filled by 8 entries                       */
//       __IOM uint32_t RX_FIFO_HALF_INTR_EN : 1;  /*!< RX FIFO full interrupt enable bit. This when set, interrupt
//                                                      is sent to PLIC when RX FIFO is filled by 16 entries                      */
//       __IOM uint32_t RX_FIFO_24_INTR_EN : 1;    /*!< RX FIFO full interrupt enable bit. This when set, interrupt
//                                                      is sent to PLIC when RX FIFO is filled by 24 entries                      */
//       __IOM uint32_t RX_FIFO_28_INTR_EN : 1;    /*!< RX FIFO full interrupt enable bit. This when set, interrupt
//                                                      is sent to PLIC when RX FIFO is filled by 28 entries                      */
//       __IOM uint32_t RX_FIFO_30_INTR_EN : 1;    /*!< RX FIFO full interrupt enable bit. This when set, interrupt
//                                                      is sent to PLIC when RX FIFO is filled by 30 entries                      */
//       __IOM uint32_t RX_FIFO_FULL_INTR_EN : 1;  /*!< RX FIFO full interrupt enable bit. This when set, interrupt
//                                                      is sent to PLIC when RX FIFO is full - 32 entries                         */
//             uint32_t            : 14;
//     } INTR_EN_b;
//   } ;
  
//   union {
//     __IOM uint32_t FIFO_STATUS;                 /*!< Gives the status of TX/RX FIFO                                            */
    
//     struct {
//       __IOM uint32_t TX_FIFO_EMPTY : 1;         /*!< TX FIFO empty. TX FIFO is empty                                           */
//       __IOM uint32_t TX_FIFO_DUAL : 1;          /*!< TX FIFO full. TX FIFO is filled by 2 entries                              */
//       __IOM uint32_t TX_FIFO_QUAD : 1;          /*!< TX FIFO full. TX FIFO is filled by 4 entries                              */
//       __IOM uint32_t TX_FIFO_OCTAL : 1;         /*!< TX FIFO full. TX FIFO is filled by 8 entries                              */
//       __IOM uint32_t TX_FIFO_HALF : 1;          /*!< TX FIFO full. TX FIFO is filled by 16 entries                             */
//       __IOM uint32_t TX_FIFO_24 : 1;            /*!< TX FIFO full. TX FIFO is filled by 24 entries                             */
//       __IOM uint32_t TX_FIFO_28 : 1;            /*!< TX FIFO full. TX FIFO is filled by 28 entries                             */
//       __IOM uint32_t TX_FIFO_30 : 1;            /*!< TX FIFO full. TX FIFO is filled by 30 entries                             */
//       __IOM uint32_t TX_FIFO_FULL : 1;          /*!< TX FIFO full. TX FIFO is full - 32 entries                                */
//       __IOM uint32_t RX_FIFO_EMPTY : 1;         /*!< RX FIFO empty. RX FIFO is empty                                           */
//       __IOM uint32_t RX_FIFO_DUAL : 1;          /*!< RX FIFO full. RX FIFO is filled by 2 entries                              */
//       __IOM uint32_t RX_FIFO_QUAD : 1;          /*!< RX FIFO full. RX FIFO is filled by 4 entries                              */
//       __IOM uint32_t RX_FIFO_OCTAL : 1;         /*!< RX FIFO full. RX FIFO is filled by 8 entries                              */
//       __IOM uint32_t RX_FIFO_HALF : 1;          /*!< RX FIFO full. RX FIFO is filled by 16 entries                             */
//       __IOM uint32_t RX_FIFO_24 : 1;            /*!< RX FIFO full. RX FIFO is filled by 24 entries                             */
//       __IOM uint32_t RX_FIFO_28 : 1;            /*!< RX FIFO full. RX FIFO is filled by 28 entries                             */
//       __IOM uint32_t RX_FIFO_30 : 1;            /*!< RX FIFO full. RX FIFO is filled by 30 entries                             */
//       __IOM uint32_t RX_FIFO_FULL : 1;          /*!< RX FIFO full. RX FIFO is full - 32 entries                                */
//             uint32_t            : 14;
//     } FIFO_STATUS_b;
//   } ;
  
//   union {
//     __IOM uint16_t COMM_STATUS;                 /*!< Status of SPI communication                                               */
    
//     struct {
//       __IOM uint16_t BUSY       : 1;            /*!< SPI Busy bit. This will be set when NCS goes low and will be
//                                                      reset when NCS goes high                                                  */
//       __IOM uint16_t TX_STARTED : 1;            /*!< Transmit enable bit. This bit will be set when the transmit
//                                                      operation starts and will be reset once the transmit operation
//                                                      is complete                                                               */
//       __IOM uint16_t RX_STARTED : 1;            /*!< Receive not enable bit. This bit will be reset when the receive
//                                                      operation starts and will be set once the receive operation
//                                                      is complete                                                               */
//       __IOM uint16_t TX_DEPTH   : 3;            /*!< TX FIFO Threshold bits to know the number of entries in the
//                                                      TX FIFO                                                                   */
//       __IOM uint16_t RX_DEPTH   : 3;            /*!< RX FIFO Threshold bits to know the number of entries in the
//                                                      RX FIFO.                                                                  */
//       __IOM uint16_t OVERRUN    : 1;            /*!< Overrun bit. This will be set when there is an overrun during
//                                                      receive operation                                                         */
//             uint16_t            : 6;
//     } COMM_STATUS_b;
//   } ;
//   __IM  uint16_t  RESERVED;
  
//   union {
//     __IOM uint8_t NCS_CTRL;                     /*!< SPI ncs control register                                                  */
    
//     struct {
//       __IOM uint8_t NCS_SELECT  : 1;            /*!< Used to select between the hardware ncs and the software ncs.
//                                                      If set to high, then it selects the software controlled
//                                                      ncs. Else , it selects the hardware ncs                                   */
//       __IOM uint8_t NCS_SW      : 1;            /*!< holds the value of software controlled ncs                                */
//             uint8_t             : 6;
//     } NCS_CTRL_b;
//   } ;
//   __IM  uint8_t   RESERVED1;
//   __IM  uint16_t  RESERVED2;
// } SPI2_Type;                                    /*!< Size = 32 (0x20)                                                          */



/* =========================================================================================================================== */
/* ================                                           SPI3                                            ================ */
/* =========================================================================================================================== */


// /**
//   * @brief SPI communication peripheral (SPI3)
//   */

// typedef struct {                                /*!< SPI3 Structure                                                            */
  
//   union {
//     __IOM uint32_t CTRL;                        /*!< SPI communication control register                                        */
    
//     struct {
//       __IOM uint32_t SLAVE_MODE : 1;            /*!< holds the spi slave mode. If set, spi will act as a slave device,
//                                                      else it will be in master mode                                            */
//       __IOM uint32_t EN         : 1;            /*!< holds the spi enable control. Once set, spi transaction will
//                                                      start and it will be reset at the end of spi transaction                  */
//       __IOM uint32_t LSBFIRST   : 1;            /*!< holds whether the spi transaction is LSB first. If set LSB first
//                                                      else MSB first                                                            */
//       __IOM uint32_t RX_FLUSH   : 1;            /*!< Flush the rx fifo                                                         */
//       __IOM uint32_t COMM_MODE  : 2;            /*!< holds the communication mode of the spi transaction. 00 - only
//                                                      transmit; 01 - only receive; 10 - transmit and immediate
//                                                      receive; 11 - transmit and receive                                        */
//       __IOM uint32_t TOTAL_BIT_TX : 8;          /*!< holds the total number of bits to be received in a spi transaction        */
//       __IOM uint32_t TOTAL_BIT_RX : 8;          /*!< holds the total number of bits to be transmitted in a spi transaction     */
//       __IOM uint32_t SCLK_OUTEN : 1;            /*!< holds the SCLK pin's output enable. If set, the controller generates
//                                                      the sclk else sclk is expected from the spi device                        */
//       __IOM uint32_t NCS_OUTEN  : 1;            /*!< holds the NCS pin's output enable. If set, the controller generates
//                                                      the ncs else ncs is expected from the spi device                          */
//       __IOM uint32_t MISO_OUTEN : 1;            /*!< holds the MISO pin's output enable. If set, output is transmitted
//                                                      through this pin else input is read from this pin                         */
//       __IOM uint32_t MOSI_OUTEN : 1;            /*!< holds the MOSI pin's output enable. If set, output is transmitted
//                                                      through this pin else input is read from this pin                         */
//       __IOM uint32_t TX_DMA_SIZE : 3;           /*!< holds the dma transmit transcation size in bytes                          */
//       __IOM uint32_t RX_DMA_SIZE : 3;           /*!< holds the dma receive transcation size in bytes                           */
//     } CTRL_b;
//   } ;
  
//   union {
//     __IOM uint32_t CLK_CTRL;                    /*!< SPI clock generation control register                                     */
    
//     struct {
//       __IOM uint32_t CLK_POLARITY : 1;          /*!< holds the clock polarity                                                  */
//       __IOM uint32_t CLK_PHASE  : 1;            /*!< holds the clock phase                                                     */
//       __IOM uint32_t CLK_PRESCALAR : 14;        /*!< holds the prescaller value of the sclk                                    */
//       __IOM uint32_t SETUP_DELAY : 8;           /*!< holds the setup delay                                                     */
//       __IOM uint32_t HOLD_DELAY : 8;            /*!< holds the hold delay                                                      */
//     } CLK_CTRL_b;
//   } ;
//   __IOM uint32_t  TX;                           /*!< holds the tx data. This register is written by the AXI write
//                                                      request and once written the data is transferred to TX
//                                                      FIFO                                                                      */
//   __IOM uint32_t  RX;                           /*!< holds the tx data. This register is read by the AXI read request.
//                                                      The data is written from the RX FIFO                                      */
  
//   union {
//     __IOM uint32_t INTR_EN;                     /*!< Spi interrupt enable register                                             */
    
//     struct {
//       __IOM uint32_t TX_FIFO_EMPTY_INTR_EN : 1; /*!< TX FIFO empty interrupt enable bit. This when set, interrupt
//                                                      is sent to PLIC when TX FIFO is empty                                     */
//       __IOM uint32_t TX_FIFO_DUAL_INTR_EN : 1;  /*!< TX FIFO full interrupt enable bit. This when set, interrupt
//                                                      is sent to PLIC when TX FIFO is filled by 2 entries                       */
//       __IOM uint32_t TX_FIFO_QUAD_INTR_EN : 1;  /*!< TX FIFO full interrupt enable bit. This when set, interrupt
//                                                      is sent to PLIC when TX FIFO is filled by 4 entries                       */
//       __IOM uint32_t TX_FIFO_OCTAL_INTR_EN : 1; /*!< TX FIFO full interrupt enable bit. This when set, interrupt
//                                                      is sent to PLIC when TX FIFO is filled by 8 entries                       */
//       __IOM uint32_t TX_FIFO_HALF_INTR_EN : 1;  /*!< TX FIFO full interrupt enable bit. This when set, interrupt
//                                                      is sent to PLIC when TX FIFO is filled by 16 entries                      */
//       __IOM uint32_t TX_FIFO_24_INTR_EN : 1;    /*!< TX FIFO full interrupt enable bit. This when set, interrupt
//                                                      is sent to PLIC when TX FIFO is filled by 24 entries                      */
//       __IOM uint32_t TX_FIFO_28_INTR_EN : 1;    /*!< TX FIFO full interrupt enable bit. This when set, interrupt
//                                                      is sent to PLIC when TX FIFO is filled by 28 entries                      */
//       __IOM uint32_t TX_FIFO_30_INTR_EN : 1;    /*!< TX FIFO full interrupt enable bit. This when set, interrupt
//                                                      is sent to PLIC when TX FIFO is filled by 30 entries                      */
//       __IOM uint32_t TX_FIFO_FULL_INTR_EN : 1;  /*!< TX FIFO full interrupt enable bit. This when set, interrupt
//                                                      is sent to PLIC when TX FIFO is full - 32 entries                         */
//       __IOM uint32_t RX_FIFO_EMPTY_INTR_EN : 1; /*!< RX FIFO empty interrupt enable bit. This when set, interrupt
//                                                      is sent to PLIC when RX FIFO is empty                                     */
//       __IOM uint32_t RX_FIFO_DUAL_INTR_EN : 1;  /*!< RX FIFO full interrupt enable bit. This when set, interrupt
//                                                      is sent to PLIC when RX FIFO is filled by 2 entries                       */
//       __IOM uint32_t RX_FIFO_QUAD_INTR_EN : 1;  /*!< RX FIFO full interrupt enable bit. This when set, interrupt
//                                                      is sent to PLIC when RX FIFO is filled by 4 entries                       */
//       __IOM uint32_t RX_FIFO_OCTAL_INTR_EN : 1; /*!< RX FIFO full interrupt enable bit. This when set, interrupt
//                                                      is sent to PLIC when RX FIFO is filled by 8 entries                       */
//       __IOM uint32_t RX_FIFO_HALF_INTR_EN : 1;  /*!< RX FIFO full interrupt enable bit. This when set, interrupt
//                                                      is sent to PLIC when RX FIFO is filled by 16 entries                      */
//       __IOM uint32_t RX_FIFO_24_INTR_EN : 1;    /*!< RX FIFO full interrupt enable bit. This when set, interrupt
//                                                      is sent to PLIC when RX FIFO is filled by 24 entries                      */
//       __IOM uint32_t RX_FIFO_28_INTR_EN : 1;    /*!< RX FIFO full interrupt enable bit. This when set, interrupt
//                                                      is sent to PLIC when RX FIFO is filled by 28 entries                      */
//       __IOM uint32_t RX_FIFO_30_INTR_EN : 1;    /*!< RX FIFO full interrupt enable bit. This when set, interrupt
//                                                      is sent to PLIC when RX FIFO is filled by 30 entries                      */
//       __IOM uint32_t RX_FIFO_FULL_INTR_EN : 1;  /*!< RX FIFO full interrupt enable bit. This when set, interrupt
//                                                      is sent to PLIC when RX FIFO is full - 32 entries                         */
//             uint32_t            : 14;
//     } INTR_EN_b;
//   } ;
  
//   union {
//     __IOM uint32_t FIFO_STATUS;                 /*!< Gives the status of TX/RX FIFO                                            */
    
//     struct {
//       __IOM uint32_t TX_FIFO_EMPTY : 1;         /*!< TX FIFO empty. TX FIFO is empty                                           */
//       __IOM uint32_t TX_FIFO_DUAL : 1;          /*!< TX FIFO full. TX FIFO is filled by 2 entries                              */
//       __IOM uint32_t TX_FIFO_QUAD : 1;          /*!< TX FIFO full. TX FIFO is filled by 4 entries                              */
//       __IOM uint32_t TX_FIFO_OCTAL : 1;         /*!< TX FIFO full. TX FIFO is filled by 8 entries                              */
//       __IOM uint32_t TX_FIFO_HALF : 1;          /*!< TX FIFO full. TX FIFO is filled by 16 entries                             */
//       __IOM uint32_t TX_FIFO_24 : 1;            /*!< TX FIFO full. TX FIFO is filled by 24 entries                             */
//       __IOM uint32_t TX_FIFO_28 : 1;            /*!< TX FIFO full. TX FIFO is filled by 28 entries                             */
//       __IOM uint32_t TX_FIFO_30 : 1;            /*!< TX FIFO full. TX FIFO is filled by 30 entries                             */
//       __IOM uint32_t TX_FIFO_FULL : 1;          /*!< TX FIFO full. TX FIFO is full - 32 entries                                */
//       __IOM uint32_t RX_FIFO_EMPTY : 1;         /*!< RX FIFO empty. RX FIFO is empty                                           */
//       __IOM uint32_t RX_FIFO_DUAL : 1;          /*!< RX FIFO full. RX FIFO is filled by 2 entries                              */
//       __IOM uint32_t RX_FIFO_QUAD : 1;          /*!< RX FIFO full. RX FIFO is filled by 4 entries                              */
//       __IOM uint32_t RX_FIFO_OCTAL : 1;         /*!< RX FIFO full. RX FIFO is filled by 8 entries                              */
//       __IOM uint32_t RX_FIFO_HALF : 1;          /*!< RX FIFO full. RX FIFO is filled by 16 entries                             */
//       __IOM uint32_t RX_FIFO_24 : 1;            /*!< RX FIFO full. RX FIFO is filled by 24 entries                             */
//       __IOM uint32_t RX_FIFO_28 : 1;            /*!< RX FIFO full. RX FIFO is filled by 28 entries                             */
//       __IOM uint32_t RX_FIFO_30 : 1;            /*!< RX FIFO full. RX FIFO is filled by 30 entries                             */
//       __IOM uint32_t RX_FIFO_FULL : 1;          /*!< RX FIFO full. RX FIFO is full - 32 entries                                */
//             uint32_t            : 14;
//     } FIFO_STATUS_b;
//   } ;
  
//   union {
//     __IOM uint16_t COMM_STATUS;                 /*!< Status of SPI communication                                               */
    
//     struct {
//       __IOM uint16_t BUSY       : 1;            /*!< SPI Busy bit. This will be set when NCS goes low and will be
//                                                      reset when NCS goes high                                                  */
//       __IOM uint16_t TX_STARTED : 1;            /*!< Transmit enable bit. This bit will be set when the transmit
//                                                      operation starts and will be reset once the transmit operation
//                                                      is complete                                                               */
//       __IOM uint16_t RX_STARTED : 1;            /*!< Receive not enable bit. This bit will be reset when the receive
//                                                      operation starts and will be set once the receive operation
//                                                      is complete                                                               */
//       __IOM uint16_t TX_DEPTH   : 3;            /*!< TX FIFO Threshold bits to know the number of entries in the
//                                                      TX FIFO                                                                   */
//       __IOM uint16_t RX_DEPTH   : 3;            /*!< RX FIFO Threshold bits to know the number of entries in the
//                                                      RX FIFO.                                                                  */
//       __IOM uint16_t OVERRUN    : 1;            /*!< Overrun bit. This will be set when there is an overrun during
//                                                      receive operation                                                         */
//             uint16_t            : 6;
//     } COMM_STATUS_b;
//   } ;
//   __IM  uint16_t  RESERVED;
  
//   union {
//     __IOM uint8_t NCS_CTRL;                     /*!< SPI ncs control register                                                  */
    
//     struct {
//       __IOM uint8_t NCS_SELECT  : 1;            /*!< Used to select between the hardware ncs and the software ncs.
//                                                      If set to high, then it selects the software controlled
//                                                      ncs. Else , it selects the hardware ncs                                   */
//       __IOM uint8_t NCS_SW      : 1;            /*!< holds the value of software controlled ncs                                */
//             uint8_t             : 6;
//     } NCS_CTRL_b;
//   } ;
//   __IM  uint8_t   RESERVED1;
//   __IM  uint16_t  RESERVED2;
// } SPI3_Type;                                    /*!< Size = 32 (0x20)                                                          */



/* =========================================================================================================================== */
/* ================                                         QUADSPI                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief QuadSPI Interface 0 (QUADSPI0)
  */



typedef struct {                                /*!< QUADSPI0 Structure                                                        */
  
  union {
    __IOM uint32_t CR;                          /*!< Control Register                                                          */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< QSPI Communication Enable                                                 */
      __IOM uint32_t ABORT      : 1;            /*!< QSPI Communication Abort request                                          */
      __IOM uint32_t DMAEN      : 1;            /*!< DMA Transfer enable                                                       */
      __IOM uint32_t TCEN       : 1;            /*!< Timeout counter enable                                                    */
            uint32_t            : 3;
      __IOM uint32_t FTHRES     : 4;            /*!< IFO threshold level                                                       */
      __IOM uint32_t TEIE       : 1;            /*!< Transfer error interrupt enable                                           */
      __IOM uint32_t TCIE       : 1;            /*!< Transfer complete interrupt enable                                        */
      __IOM uint32_t FTIE       : 1;            /*!< FIFO threshold interrupt enable                                           */
      __IOM uint32_t SMIE       : 1;            /*!< Status match interrupt enable                                             */
      __IOM uint32_t TOIE       : 1;            /*!< TimeOut interrupt enable                                                  */
      __IOM uint32_t APMS       : 1;            /*!< Automatic poll mode stop                                                  */
      __IOM uint32_t PMM        : 1;            /*!< Polling match mode                                                        */
      __IOM uint32_t PRESCALER  : 8;            /*!< Clock prescaler                                                           */
            uint32_t            : 6;
    } CR_b;
  } ;
  
  union {
    __IOM uint32_t DCR;                         /*!< Device Configuration Register                                             */
    
    struct {
      __IOM uint32_t CKMODE     : 1;            /*!< Mode 0 / mode 3                                                           */
            uint32_t            : 7;
      __IOM uint32_t CSHT       : 3;            /*!< Chip select high time                                                     */
            uint32_t            : 5;
      __IOM uint32_t FSIZE      : 5;            /*!< FLASH memory size                                                         */
      __IOM uint32_t MODE_Byte  : 8;            /*!< Dummy Cycle Mode Byte for Micron Flash                                    */
            uint32_t            : 3;
    } DCR_b;
  } ;
  
  union {
    __IM  uint32_t SR;                          /*!< Status Register                                                           */
    
    struct {
      __IM  uint32_t TEF        : 1;            /*!< Transfer error flag                                                       */
      __IM  uint32_t TCF        : 1;            /*!< Transfer complete flag                                                    */
      __IM  uint32_t FTF        : 1;            /*!< FIFO threshold flag                                                       */
      __IM  uint32_t SMF        : 1;            /*!< Status match flag                                                         */
      __IM  uint32_t TOF        : 1;            /*!< Timeout flag                                                              */
      __IM  uint32_t BUSY       : 1;            /*!< Busy                                                                      */
            uint32_t            : 2;
      __IM  uint32_t FLEVEL     : 7;            /*!< FIFO level                                                                */
            uint32_t            : 17;
    } SR_b;
  } ;
  
  union {
    __IOM uint32_t FCR;                         /*!< Flag Clear Register                                                       */
    
    struct {
      __IOM uint32_t CTEF       : 1;            /*!< Clear transfer error flag                                                 */
      __IOM uint32_t CTCF       : 1;            /*!< Clear transfer complete flag                                              */
            uint32_t            : 1;
      __IOM uint32_t CSMF       : 1;            /*!< Clear status match flag                                                   */
      __IOM uint32_t CTOF       : 1;            /*!< Clear timeout flag                                                        */
            uint32_t            : 27;
    } FCR_b;
  } ;
  
  union {
    __IOM uint32_t DLR;                         /*!< data length register                                                      */
    
    struct {
      __IOM uint32_t DL         : 32;           /*!< Data length                                                               */
    } DLR_b;
  } ;
  
  union {
    __IOM uint32_t CCR;                         /*!< communication configuration register                                      */
    
    struct {
      __IOM uint32_t INSTRUCTION : 8;           /*!< Instruction                                                               */
      __IOM uint32_t IMODE      : 2;            /*!< Instruction mode                                                          */
      __IOM uint32_t ADMODE     : 2;            /*!< Address mode                                                              */
      __IOM uint32_t ADSIZE     : 2;            /*!< Address size                                                              */
      __IOM uint32_t ABMODE     : 2;            /*!< Alternate bytes mode                                                      */
      __IOM uint32_t ABSIZE     : 2;            /*!< Alternate bytes size                                                      */
      __IOM uint32_t DCYC       : 5;            /*!< Number of dummy cycles                                                    */
            uint32_t            : 1;
      __IOM uint32_t DMODE      : 2;            /*!< Data mode                                                                 */
      __IOM uint32_t FMODE      : 2;            /*!< Functional mode                                                           */
      __IOM uint32_t SIOO       : 1;            /*!< Send instruction only once mode                                           */
      __IOM uint32_t DUMMY_BIT  : 1;            /*!< Set value 1 to send Dummy Cycles. Default 0                               */
      __IOM uint32_t MM_MODE    : 1;            /*!< Memory Mapped Mode. Default value 0. For XIP Mode, set 0, for
                                                     RAM Mode, set 1.                                                          */
            uint32_t            : 1;
    } CCR_b;
  } ;
  
  union {
    __IOM uint32_t AR;                          /*!< Address Register                                                          */
    
    struct {
      __IOM uint32_t ADDRESS    : 32;           /*!< Address                                                                   */
    } AR_b;
  } ;
  
  union {
    __IOM uint32_t ABR;                         /*!< Alternate Byte Register                                                   */
    
    struct {
      __IOM uint32_t ALTERNATE  : 32;           /*!< Alternate Byte                                                            */
    } ABR_b;
  } ;
  // __IM  uint32_t  RESERVED[2];

  __IOM QSPI_Data DR;                            /*!< Data Register                                                             */
  
  union {
    __IOM uint32_t PSMKR;                       /*!< Polling Status Mask Register                                              */
    
    struct {
      __IOM uint32_t MASK       : 32;           /*!< Status mask                                                               */
    } PSMKR_b;
  } ;
  
  union {
    __IOM uint32_t PSMAR;                       /*!< Polling Status Match Register                                             */
    
    struct {
      __IOM uint32_t Match      : 32;           /*!< Status Match                                                              */
    } PSMAR_b;
  } ;
  __IM  uint32_t  RESERVED1;
  
  union {
    __IOM uint32_t LPTR;                        /*!< Low Power Timeout Register                                                */
    
    struct {
      __IOM uint32_t Match      : 32;           /*!< Status Match                                                              */
    } LPTR_b;
  } ;
  
  union {
    __IOM uint32_t RMC;                         /*!< RAM Mode Configuration Register                                           */
    
    struct {
      __IOM uint32_t WDCYC      : 5;            /*!< RAM Write Mode Dummy Cycle Count                                          */
      __IOM uint32_t RDCYC      : 5;            /*!< RAM Read Mode Dummy Cycle Count                                           */
      __IOM uint32_t WINST      : 8;            /*!< RAM Write Mode Instruction                                                */
      __IOM uint32_t RINST      : 8;            /*!< RAM Read Mode Instruction                                                 */
            uint32_t            : 6;
    } RMC_b;
  } ;
  
} QUADSPI_Type;                                /*!< Size = 60 (0x3c)                                                          */



/* =========================================================================================================================== */
/* ================                                         QUADSPI1                                          ================ */
/* =========================================================================================================================== */


// /**
//   * @brief QuadSPI Interface 1 (QUADSPI1)
//   */

// typedef struct {                                /*!< QUADSPI1 Structure                                                        */
  
//   union {
//     __IOM uint32_t CR;                          /*!< Control Register                                                          */
    
//     struct {
//       __IOM uint32_t EN         : 1;            /*!< QSPI Communication Enable                                                 */
//       __IOM uint32_t ABORT      : 1;            /*!< QSPI Communication Abort request                                          */
//       __IOM uint32_t DMAEN      : 1;            /*!< DMA Transfer enable                                                       */
//       __IOM uint32_t TCEN       : 1;            /*!< Timeout counter enable                                                    */
//             uint32_t            : 3;
//       __IOM uint32_t FTHRES     : 4;            /*!< IFO threshold level                                                       */
//       __IOM uint32_t TEIE       : 1;            /*!< Transfer error interrupt enable                                           */
//       __IOM uint32_t TCIE       : 1;            /*!< Transfer complete interrupt enable                                        */
//       __IOM uint32_t FTIE       : 1;            /*!< FIFO threshold interrupt enable                                           */
//       __IOM uint32_t SMIE       : 1;            /*!< Status match interrupt enable                                             */
//       __IOM uint32_t TOIE       : 1;            /*!< TimeOut interrupt enable                                                  */
//       __IOM uint32_t APMS       : 1;            /*!< Automatic poll mode stop                                                  */
//       __IOM uint32_t PMM        : 1;            /*!< Polling match mode                                                        */
//       __IOM uint32_t PRESCALER  : 8;            /*!< Clock prescaler                                                           */
//             uint32_t            : 6;
//     } CR_b;
//   } ;
  
//   union {
//     __IOM uint32_t DCR;                         /*!< Device Configuration Register                                             */
    
//     struct {
//       __IOM uint32_t CKMODE     : 1;            /*!< Mode 0 / mode 3                                                           */
//             uint32_t            : 7;
//       __IOM uint32_t CSHT       : 3;            /*!< Chip select high time                                                     */
//             uint32_t            : 5;
//       __IOM uint32_t FSIZE      : 5;            /*!< FLASH memory size                                                         */
//       __IOM uint32_t MODE_Byte  : 8;            /*!< Dummy Cycle Mode Byte for Micron Flash                                    */
//             uint32_t            : 3;
//     } DCR_b;
//   } ;
  
//   union {
//     __IM  uint32_t SR;                          /*!< Status Register                                                           */
    
//     struct {
//       __IM  uint32_t TEF        : 1;            /*!< Transfer error flag                                                       */
//       __IM  uint32_t TCF        : 1;            /*!< Transfer complete flag                                                    */
//       __IM  uint32_t FTF        : 1;            /*!< FIFO threshold flag                                                       */
//       __IM  uint32_t SMF        : 1;            /*!< Status match flag                                                         */
//       __IM  uint32_t TOF        : 1;            /*!< Timeout flag                                                              */
//       __IM  uint32_t BUSY       : 1;            /*!< Busy                                                                      */
//             uint32_t            : 2;
//       __IM  uint32_t FLEVEL     : 7;            /*!< FIFO level                                                                */
//             uint32_t            : 17;
//     } SR_b;
//   } ;
  
//   union {
//     __IOM uint32_t FCR;                         /*!< Flag Clear Register                                                       */
    
//     struct {
//       __IOM uint32_t CTEF       : 1;            /*!< Clear transfer error flag                                                 */
//       __IOM uint32_t CTCF       : 1;            /*!< Clear transfer complete flag                                              */
//             uint32_t            : 1;
//       __IOM uint32_t CSMF       : 1;            /*!< Clear status match flag                                                   */
//       __IOM uint32_t CTOF       : 1;            /*!< Clear timeout flag                                                        */
//             uint32_t            : 27;
//     } FCR_b;
//   } ;
  
//   union {
//     __IOM uint32_t DLR;                         /*!< data length register                                                      */
    
//     struct {
//       __IOM uint32_t DL         : 32;           /*!< Data length                                                               */
//     } DLR_b;
//   } ;
  
//   union {
//     __IOM uint32_t CCR;                         /*!< communication configuration register                                      */
    
//     struct {
//       __IOM uint32_t INSTRUCTION : 8;           /*!< Instruction                                                               */
//       __IOM uint32_t IMODE      : 2;            /*!< Instruction mode                                                          */
//       __IOM uint32_t ADMODE     : 2;            /*!< Address mode                                                              */
//       __IOM uint32_t ADSIZE     : 2;            /*!< Address size                                                              */
//       __IOM uint32_t ABMODE     : 2;            /*!< Alternate bytes mode                                                      */
//       __IOM uint32_t ABSIZE     : 2;            /*!< Alternate bytes size                                                      */
//       __IOM uint32_t DCYC       : 5;            /*!< Number of dummy cycles                                                    */
//             uint32_t            : 1;
//       __IOM uint32_t DMODE      : 2;            /*!< Data mode                                                                 */
//       __IOM uint32_t FMODE      : 2;            /*!< Functional mode                                                           */
//       __IOM uint32_t SIOO       : 1;            /*!< Send instruction only once mode                                           */
//       __IOM uint32_t DUMMY_BIT  : 1;            /*!< Set value 1 to send Dummy Cycles. Default 0                               */
//       __IOM uint32_t MM_MODE    : 1;            /*!< Memory Mapped Mode. Default value 0. For XIP Mode, set 0, for
//                                                      RAM Mode, set 1.                                                          */
//             uint32_t            : 1;
//     } CCR_b;
//   } ;
  
//   union {
//     __IOM uint32_t AR;                          /*!< Address Register                                                          */
    
//     struct {
//       __IOM uint32_t ADDRESS    : 32;           /*!< Address                                                                   */
//     } AR_b;
//   } ;
  
//   union {
//     __IOM uint32_t ABR;                         /*!< Alternate Byte Register                                                   */
    
//     struct {
//       __IOM uint32_t ALTERNATE  : 32;           /*!< Alternate Byte                                                            */
//     } ABR_b;
//   } ;
//   __IM  uint32_t  RESERVED[2];
  
//   union {
//     __IOM uint32_t PSMKR;                       /*!< Polling Status Mask Register                                              */
    
//     struct {
//       __IOM uint32_t MASK       : 32;           /*!< Status mask                                                               */
//     } PSMKR_b;
//   } ;
  
//   union {
//     __IOM uint32_t PSMAR;                       /*!< Polling Status Match Register                                             */
    
//     struct {
//       __IOM uint32_t Match      : 32;           /*!< Status Match                                                              */
//     } PSMAR_b;
//   } ;
//   __IM  uint32_t  RESERVED1;
  
//   union {
//     __IOM uint32_t LPTR;                        /*!< Low Power Timeout Register                                                */
    
//     struct {
//       __IOM uint32_t Match      : 32;           /*!< Status Match                                                              */
//     } LPTR_b;
//   } ;
  
//   union {
//     __IOM uint32_t RMC;                         /*!< RAM Mode Configuration Register                                           */
    
//     struct {
//       __IOM uint32_t WDCYC      : 5;            /*!< RAM Write Mode Dummy Cycle Count                                          */
//       __IOM uint32_t RDCYC      : 5;            /*!< RAM Read Mode Dummy Cycle Count                                           */
//       __IOM uint32_t WINST      : 8;            /*!< RAM Write Mode Instruction                                                */
//       __IOM uint32_t RINST      : 8;            /*!< RAM Read Mode Instruction                                                 */
//             uint32_t            : 6;
//     } RMC_b;
//   } ;
//   #error "Struct end-padding calculation error!"
// } QUADSPI1_Type;                                /*!< Size = 60 (0x3c)                                                          */



/* =========================================================================================================================== */
/* ================                                          ITRACE                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Instruction Trace (ITRACE)
  */

typedef struct {                                /*!< ITRACE Structure                                                          */
  
  union {
    __IOM uint16_t CTRL;                        /*!< Itrace control register                                                   */
    
    struct {
      __IOM uint16_t ACTIVE     : 1;            /*!< Indicates whether trace is active or not. Used for gating.                */
      __IOM uint16_t EN         : 1;            /*!< Enables the trace                                                         */
      __IOM uint16_t I_EN       : 1;            /*!< Enables the Instruction trace                                             */
            uint16_t            : 5;
      __IOM uint16_t RESYNC_MODE : 2;           /*!< Sets the resync packet mode. 0-Not supported, 1-Trace packet
                                                     count, 2-Every clock, 3-Instruction retired                               */
            uint16_t            : 2;
      __IOM uint16_t RESYNC_MAX : 4;            /*!< Sets the resync interval time.                                            */
    } CTRL_b;
  } ;
  __IM  uint16_t  RESERVED;
  __IM  uint32_t  RESERVED1;
  
  union {
    __IOM uint32_t FITER_CTRL;                  /*!< Instruction filter control                                                */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< Filter enable                                                             */
      __IOM uint32_t PRV_EN     : 1;            /*!< Match privielge mode enable                                               */
      __IOM uint32_t PRV        : 2;            /*!< The privelege mode to filter when enabled                                 */
            uint32_t            : 2;
      __IOM uint32_t COMP1_EN   : 1;            /*!< Enable the first comparator                                               */
      __IOM uint32_t MATCH_COMP1 : 2;           /*!< Mentions which comparator output to use for this 1st filter               */
      __IOM uint32_t COMP2_EN   : 1;            /*!< Enable the second comparator                                              */
      __IOM uint32_t MATCH_COMP2 : 2;           /*!< Mentions which comparator output to use for this 2nd filter               */
      __IOM uint32_t COMP3_EN   : 1;            /*!< Enable the first comparator                                               */
      __IOM uint32_t MATCH_COMP3 : 2;           /*!< Mentions which comparator output to use for this 3rd filter               */
            uint32_t            : 17;
    } FITER_CTRL_b;
  } ;
  
  union {
    __IOM uint16_t COMP1_CTRL;                  /*!< Control register for 1st comparator                                       */
    
    struct {
      __IOM uint16_t PINPUT_MODE : 2;           /*!< Primary comparator input mode. 0: iaddr, 1: context, 2: tval,
                                                     3: daddr.                                                                 */
      __IOM uint16_t SINPUT_MODE : 2;           /*!< Secondary comparator input mode. 0: iaddr, 1: context, 2: tval,
                                                     3: daddr.                                                                 */
      __IOM uint16_t PINPUT_COMP_MODE : 3;      /*!< Mentions the comparison to be done for primary input. 0-equality,
                                                     1-not equal, 2-less than, 3-less than equal to, 4-greater
                                                     than, 5-greater than equal to, 6-False, 7-True                            */
            uint16_t            : 1;
      __IOM uint16_t SINPUT_COMP_MODE : 3;      /*!< Mentions the comparison to be done for secondary input. 0-equality,
                                                     1-not equal, 2-less than, 3-less than equal to, 4-greater
                                                     than, 5-greater than equal to, 6-False, 7-True                            */
            uint16_t            : 1;
      __IOM uint16_t PS_COMP_MODE : 2;          /*!< The comparison to be performed between primary and secondary
                                                     input.                                                                    */
      __IOM uint16_t PNOTIFY    : 1;            /*!< Sends a support packet when primary comparator matches                    */
      __IOM uint16_t SNOTIFY    : 1;            /*!< Sends a support packet when secondary comparator matches                  */
    } COMP1_CTRL_b;
  } ;
  __IM  uint16_t  RESERVED2;
  
  union {
    __IOM uint16_t COMP2_CTRL;                  /*!< Control register for 1st comparator                                       */
    
    struct {
      __IOM uint16_t PINPUT_MODE : 2;           /*!< Primary comparator input mode. 0: iaddr, 1: context, 2: tval,
                                                     3: daddr.                                                                 */
      __IOM uint16_t SINPUT_MODE : 2;           /*!< Secondary comparator input mode. 0: iaddr, 1: context, 2: tval,
                                                     3: daddr.                                                                 */
      __IOM uint16_t PINPUT_COMP_MODE : 3;      /*!< Mentions the comparison to be done for primary input. 0-equality,
                                                     1-not equal, 2-less than, 3-less than equal to, 4-greater
                                                     than, 5-greater than equal to, 6-False, 7-True                            */
            uint16_t            : 1;
      __IOM uint16_t SINPUT_COMP_MODE : 3;      /*!< Mentions the comparison to be done for secondary input. 0-equality,
                                                     1-not equal, 2-less than, 3-less than equal to, 4-greater
                                                     than, 5-greater than equal to, 6-False, 7-True                            */
            uint16_t            : 1;
      __IOM uint16_t PS_COMP_MODE : 2;          /*!< The comparison to be performed between primary and secondary
                                                     input.                                                                    */
      __IOM uint16_t PNOTIFY    : 1;            /*!< Sends a support packet when primary comparator matches                    */
      __IOM uint16_t SNOTIFY    : 1;            /*!< Sends a support packet when secondary comparator matches                  */
    } COMP2_CTRL_b;
  } ;
  __IM  uint16_t  RESERVED3;
  
  union {
    __IOM uint16_t COMP3_CTRL;                  /*!< Control register for 1st comparator                                       */
    
    struct {
      __IOM uint16_t PINPUT_MODE : 2;           /*!< Primary comparator input mode. 0: iaddr, 1: context, 2: tval,
                                                     3: daddr.                                                                 */
      __IOM uint16_t SINPUT_MODE : 2;           /*!< Secondary comparator input mode. 0: iaddr, 1: context, 2: tval,
                                                     3: daddr.                                                                 */
      __IOM uint16_t PINPUT_COMP_MODE : 3;      /*!< Mentions the comparison to be done for primary input. 0-equality,
                                                     1-not equal, 2-less than, 3-less than equal to, 4-greater
                                                     than, 5-greater than equal to, 6-False, 7-True                            */
            uint16_t            : 1;
      __IOM uint16_t SINPUT_COMP_MODE : 3;      /*!< Mentions the comparison to be done for secondary input. 0-equality,
                                                     1-not equal, 2-less than, 3-less than equal to, 4-greater
                                                     than, 5-greater than equal to, 6-False, 7-True                            */
            uint16_t            : 1;
      __IOM uint16_t PS_COMP_MODE : 2;          /*!< The comparison to be performed between primary and secondary
                                                     input.                                                                    */
      __IOM uint16_t PNOTIFY    : 1;            /*!< Sends a support packet when primary comparator matches                    */
      __IOM uint16_t SNOTIFY    : 1;            /*!< Sends a support packet when secondary comparator matches                  */
    } COMP3_CTRL_b;
  } ;
  __IM  uint16_t  RESERVED4;
  __IOM uint32_t  COMP1_PMATCH_LOW;             /*!< Comparator 1 primary match data: Low 32 bits                              */
  __IOM uint32_t  COMP1_PMATCH_HIGH;            /*!< Comparator 1 primary match data: High 32 bits                             */
  __IOM uint32_t  COMP1_SMATCH_LOW;             /*!< Comparator 1 secondary match data: Low 32 bits                            */
} ITRACE_Type;                                  /*!< Size = 36 (0x24)                                                          */



/* =========================================================================================================================== */
/* ================                                        ITRACE_RAM                                         ================ */
/* =========================================================================================================================== */


/**
  * @brief The RAM sink where all the trace packets are stored (ITRACE_RAM)
  */

typedef struct {                                /*!< ITRACE_RAM Structure                                                      */
  
  union {
    __IOM uint32_t CTRL;                        /*!< Control register                                                          */
    
    struct {
      __IOM uint32_t ACTIVE     : 1;            /*!< Indicates whether RAM is active or not.                                   */
      __IOM uint32_t EN         : 1;            /*!< Enables the RAM to take trace packets.                                    */
            uint32_t            : 4;
      __IOM uint32_t STOP_ON_WRAP : 1;          /*!< Stop filling up packets into RAM when full                                */
            uint32_t            : 25;
    } CTRL_b;
  } ;
  
  union {
    __IM  uint32_t IMPL;                        /*!< Implementation details register                                           */
    
    struct {
      __IM  uint32_t VER_MAJOR  : 1;            /*!< Major version number                                                      */
      __IM  uint32_t VER_MINOR  : 1;            /*!< Minor version number                                                      */
      __IM  uint32_t COMP_TYPE  : 1;            /*!< Trace RAM sink component type                                             */
      __IM  uint32_t HAS_SRAM   : 1;            /*!< Indicates whether SRAM is present                                         */
      __IM  uint32_t HAS_SMEM   : 1;            /*!< Indicates whether SREM is present                                         */
            uint32_t            : 27;
    } IMPL_b;
  } ;
  __IM  uint32_t  RESERVED[2];
  __IOM uint32_t  START_LOW;                    /*!< The RAM start address register. Low 32 bits                               */
  __IOM uint32_t  START_HIGH;                   /*!< The RAM start address register. High 32 bits                              */
  __IOM uint32_t  LIMIT_LOW;                    /*!< The RAM end address register. Low 32 bits                                 */
  __IOM uint32_t  LIMIT_HIGH;                   /*!< The RAM end address register. High 32 bits                                */
  __IOM uint32_t  WP_LOW;                       /*!< Write pointer of trace packet into RAM. Low 32 bits                       */
  __IOM uint32_t  WP_HIGH;                      /*!< Write pointer of trace packet into RAM. High 32 bits                      */
  __IOM uint32_t  RP_LOW;                       /*!< Read pointer of trace packet into RAM. Low 32 bits                        */
  __IOM uint32_t  RP_HIGH;                      /*!< Read pointer of trace packet into RAM. High 32 bits                       */
  __IM  uint32_t  RESERVED1[4];
  __IM  uint32_t  DATA;                         /*!< RAM data is read by external host via this register.                      */
  __IOM uint32_t  DMA_THRESH;                   /*!< When the ITRACE RAM reaches the threshold limit, it will send
                                                     an interrupt to the DMA, then DMA will start the transfer.                */
} ITRACE_RAM_Type;                              /*!< Size = 72 (0x48)                                                          */



/* =========================================================================================================================== */
/* ================                                           PLIC                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Platform Level Interrupt Controller (PLIC)
  */

typedef struct {                                /*!< PLIC Structure                                                            */
  __IOM uint32_t  PRIORITY0;                    /*!< Priority register for interrupt source 0                                  */
  __IOM uint32_t  PRIORITY1;                    /*!< Priority register for interrupt source 1                                  */
  __IOM uint32_t  PRIORITY2;                    /*!< Priority register for interrupt source 2                                  */
  __IOM uint32_t  PRIORITY3;                    /*!< Priority register for interrupt source 3                                  */
  __IOM uint32_t  PRIORITY4;                    /*!< Priority register for interrupt source 4                                  */
  __IOM uint32_t  PRIORITY5;                    /*!< Priority register for interrupt source 5                                  */
  __IOM uint32_t  PRIORITY6;                    /*!< Priority register for interrupt source 6                                  */
  __IOM uint32_t  PRIORITY7;                    /*!< Priority register for interrupt source 7                                  */
  __IOM uint32_t  PRIORITY8;                    /*!< Priority register for interrupt source 8                                  */
  __IOM uint32_t  PRIORITY9;                    /*!< Priority register for interrupt source 9                                  */
  __IOM uint32_t  PRIORITY10;                   /*!< Priority register for interrupt source 10                                 */
  __IOM uint32_t  PRIORITY11;                   /*!< Priority register for interrupt source 11                                 */
  __IOM uint32_t  PRIORITY12;                   /*!< Priority register for interrupt source 12                                 */
  __IOM uint32_t  PRIORITY13;                   /*!< Priority register for interrupt source 13                                 */
  __IOM uint32_t  PRIORITY14;                   /*!< Priority register for interrupt source 14                                 */
  __IOM uint32_t  PRIORITY15;                   /*!< Priority register for interrupt source 15                                 */
  __IOM uint32_t  PRIORITY16;                   /*!< Priority register for interrupt source 16                                 */
  __IOM uint32_t  PRIORITY17;                   /*!< Priority register for interrupt source 17                                 */
  __IOM uint32_t  PRIORITY18;                   /*!< Priority register for interrupt source 18                                 */
  __IOM uint32_t  PRIORITY19;                   /*!< Priority register for interrupt source 19                                 */
  __IOM uint32_t  PRIORITY20;                   /*!< Priority register for interrupt source 20                                 */
  __IOM uint32_t  PRIORITY21;                   /*!< Priority register for interrupt source 21                                 */
  __IOM uint32_t  PRIORITY22;                   /*!< Priority register for interrupt source 22                                 */
  __IOM uint32_t  PRIORITY23;                   /*!< Priority register for interrupt source 23                                 */
  __IOM uint32_t  PRIORITY24;                   /*!< Priority register for interrupt source 24                                 */
  __IOM uint32_t  PRIORITY25;                   /*!< Priority register for interrupt source 25                                 */
  __IOM uint32_t  PRIORITY26;                   /*!< Priority register for interrupt source 26                                 */
  __IOM uint32_t  PRIORITY27;                   /*!< Priority register for interrupt source 27                                 */
  __IOM uint32_t  PRIORITY28;                   /*!< Priority register for interrupt source 28                                 */
  __IOM uint32_t  PRIORITY29;                   /*!< Priority register for interrupt source 29                                 */
  __IOM uint32_t  PRIORITY30;                   /*!< Priority register for interrupt source 30                                 */
  __IOM uint32_t  PRIORITY31;                   /*!< Priority register for interrupt source 31                                 */
  __IOM uint32_t  PRIORITY32;                   /*!< Priority register for interrupt source 32                                 */
  __IOM uint32_t  PRIORITY33;                   /*!< Priority register for interrupt source 33                                 */
  __IOM uint32_t  PRIORITY34;                   /*!< Priority register for interrupt source 34                                 */
  __IOM uint32_t  PRIORITY35;                   /*!< Priority register for interrupt source 35                                 */
  __IOM uint32_t  PRIORITY36;                   /*!< Priority register for interrupt source 36                                 */
  __IOM uint32_t  PRIORITY37;                   /*!< Priority register for interrupt source 37                                 */
  __IOM uint32_t  PRIORITY38;                   /*!< Priority register for interrupt source 38                                 */
  __IOM uint32_t  PRIORITY39;                   /*!< Priority register for interrupt source 39                                 */
  __IOM uint32_t  PRIORITY40;                   /*!< Priority register for interrupt source 40                                 */
  __IOM uint32_t  PRIORITY41;                   /*!< Priority register for interrupt source 41                                 */
  __IOM uint32_t  PRIORITY42;                   /*!< Priority register for interrupt source 42                                 */
  __IOM uint32_t  PRIORITY43;                   /*!< Priority register for interrupt source 43                                 */
  __IOM uint32_t  PRIORITY44;                   /*!< Priority register for interrupt source 44                                 */
  __IOM uint32_t  PRIORITY45;                   /*!< Priority register for interrupt source 45                                 */
  __IOM uint32_t  PRIORITY46;                   /*!< Priority register for interrupt source 46                                 */
  __IOM uint32_t  PRIORITY47;                   /*!< Priority register for interrupt source 47                                 */
  __IOM uint32_t  PRIORITY48;                   /*!< Priority register for interrupt source 48                                 */
  __IOM uint32_t  PRIORITY49;                   /*!< Priority register for interrupt source 49                                 */
  __IOM uint32_t  PRIORITY50;                   /*!< Priority register for interrupt source 50                                 */
  __IOM uint32_t  PRIORITY51;                   /*!< Priority register for interrupt source 51                                 */
  __IOM uint32_t  PRIORITY52;                   /*!< Priority register for interrupt source 52                                 */
  __IOM uint32_t  PRIORITY53;                   /*!< Priority register for interrupt source 53                                 */
  __IOM uint32_t  PRIORITY54;                   /*!< Priority register for interrupt source 54                                 */
  __IOM uint32_t  PRIORITY55;                   /*!< Priority register for interrupt source 55                                 */
  __IOM uint32_t  PRIORITY56;                   /*!< Priority register for interrupt source 56                                 */
  __IOM uint32_t  PRIORITY57;                   /*!< Priority register for interrupt source 57                                 */
  __IOM uint32_t  PRIORITY58;                   /*!< Priority register for interrupt source 58                                 */
  __IOM uint32_t  PRIORITY59;                   /*!< Priority register for interrupt source 59                                 */
  __IOM uint32_t  PRIORITY60;                   /*!< Priority register for interrupt source 60                                 */
  __IOM uint32_t  PRIORITY61;                   /*!< Priority register for interrupt source 61                                 */
  __IOM uint32_t  PRIORITY62;                   /*!< Priority register for interrupt source 62                                 */
  __IOM uint32_t  PRIORITY63;                   /*!< Priority register for interrupt source 63                                 */
  __IM  uint32_t  RESERVED[960];
  __IM  uint32_t  PENDING_0_32;                 /*!< Interrupt pending bits of sources 0-32                                    */
  __IM  uint32_t  PENDING_33_63;                /*!< Interrupt pending bits of sources 33-63                                   */
  __IM  uint32_t  RESERVED1[1022];
  __IOM uint32_t  INTR_EN_0_32;                 /*!< Interrupt enable bits of sources 0-32                                     */
  __IOM uint32_t  INTR_EN_33_63;                /*!< Interrupt enable bits of sources 33-63                                    */
  __IM  uint32_t  RESERVED2[14334];
  __IOM uint32_t  PRIORITY_THRES;               /*!< Priority threshold register                                               */
  __IOM uint32_t  INTR_COMPLETE;                /*!< Interrupt claim/complete register                                         */
} PLIC_Type;                                    /*!< Size = 65544 (0x10008)                                                    */



/* =========================================================================================================================== */
/* ================                                            OTP                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief One-Time Programmable Memory (OTP)
  */

typedef struct {                                /*!< OTP Structure                                                             */
  
  union {
    __IOM uint32_t CTRL;                        /*!< One-Time Programmable Memory Control Register                             */
    
    struct {
      __IOM uint32_t START      : 1;            /*!< Starts the OTP Operations                                                 */
      __IOM uint32_t READ_WRITE : 1;            /*!< This determines whether the operation to perform is Read or
                                                     Write (0 - Write : 1 - Read)                                              */
      __IOM uint32_t INIT       : 1;            /*!< The Initialization to be done on OTP Memory before any program
                                                     operation                                                                 */
            uint32_t            : 29;
    } CTRL_b;
  } ;
  __IM  uint32_t  RESERVED;
  
  union {
    __IOM uint32_t STATUS;                      /*!< One-Time Programmable Memory Status Register                              */
    
    struct {
      __IOM uint32_t GET_OUTPUT : 1;            /*!< Status bit to get output from OTP Memory                                  */
      __IOM uint32_t PROG_STATUS : 1;           /*!< Status bit to check programming status on OTP Memory                      */
      __IOM uint32_t FATAL_ERR  : 1;            /*!< Status bit to check if the programming failed on OTP Memory               */
      __IOM uint32_t INIT_DONE  : 1;            /*!< Status bit to if initialization is done on OTP Memory                     */
            uint32_t            : 28;
    } STATUS_b;
  } ;
  __IM  uint32_t  RESERVED1;
  
  union {
    __IOM uint32_t ADDRESS;                     /*!< One-Time Programmable Memory Address Register                             */
    
    struct {
      __IOM uint32_t ADDR       : 32;           /*!< Memory address on which the DATA to be written or read                    */
    } ADDRESS_b;
  } ;
  __IM  uint32_t  RESERVED2;
  
  union {
    __IOM uint32_t DATA_READ;                   /*!< One-Time Programmable Memory READ Register                                */
    
    struct {
      __IOM uint32_t OTP_READ   : 8;            /*!< The DATA to be read from the OTP Memory                                   */
            uint32_t            : 24;
    } DATA_READ_b;
  } ;
  __IM  uint32_t  RESERVED3;
  
  union {
    __IOM uint32_t DATA_WRITE;                  /*!< One-Time Programmable Memory WRITE Register                               */
    
    struct {
      __IOM uint32_t OTP_WRITE  : 1;            /*!< The DATA to be written on the OTP Memory                                  */
            uint32_t            : 31;
    } DATA_WRITE_b;
  } ;
} OTP_Type;                                     /*!< Size = 36 (0x24)                                                          */


/** @} */ /* End of group Device_Peripheral_peripherals */


/* =========================================================================================================================== */
/* ================                          Device Specific Peripheral Address Map                           ================ */
/* =========================================================================================================================== */


/** @addtogroup Device_Peripheral_peripheralAddr
  * @{
  */

#define DMA_BASE                    0x07000000UL
#define ADC_BASE                    0x00032000UL
#define PLL_BASE                    0x00100000UL
#define PWM0_BASE                   0x00030000UL
#define PWM1_BASE                   0x00030100UL
#define PWM2_BASE                   0x00030200UL
#define PWM3_BASE                   0x00030300UL
#define PWM4_BASE                   0x00030400UL
#define PWM5_BASE                   0x00030500UL
#define PWM6_BASE                   0x00030600UL
#define PWM7_BASE                   0x00030700UL
#define PWM8_BASE                   0x00030800UL
#define PWM9_BASE                   0x00030900UL
#define PWM10_BASE                  0x00030A00UL
#define PWM11_BASE                  0x00030B00UL
#define PWM12_BASE                  0x00030C00UL
#define PWM13_BASE                  0x00030D00UL
#define GPTIMER0_BASE               0x00044200UL
#define GPTIMER1_BASE               0x00044220UL
#define GPTIMER2_BASE               0x00044240UL
#define GPTIMER3_BASE               0x00044260UL
#define CLINT0_BASE                 0x02000000UL
#define UART0_BASE                  0x00011300UL
#define UART1_BASE                  0x00011400UL
#define UART2_BASE                  0x00011500UL
#define UART3_BASE                  0x00011600UL
#define UART4_BASE                  0x00011700UL
#define I2C0_BASE                   0x00044000UL
#define I2C1_BASE                   0x00044100UL
#define WDT_BASE                    0x00040500UL
#define PINMUX0_BASE                0x00040400UL
#define GPIO_BASE                   0x00040200UL
#define GPIO_PINMUX_BASE            0x00040300UL
#define AES_BASE                    0x04000000UL
#define SHA256_BASE                 0x03000000UL
#define RSA_BASE                    0x05000000UL
#define SPI0_BASE                   0x00020000UL
#define SPI1_BASE                   0x00020100UL
#define SPI2_BASE                   0x00020200UL
#define SPI3_BASE                   0x00020300UL
#define QUADSPI0_BASE               0x00060200UL
#define QUADSPI1_BASE               0x00060300UL
#define ITRACE_BASE                 0x00060000UL
#define ITRACE_RAM_BASE             0x00060100UL
#define PLIC_BASE                   0x0C000000UL
#define OTP_BASE                    0x00033000UL
#define PWM_BASE                   0x00030000UL
#define GPTIMER_BASE               0x00044200UL
#define CLINT0_BASE                0x02000000UL
#define UART_BASE                  0x00011300UL
#define I2C_BASE                   0x00044000UL
#define WDT_BASE                   0x00040400UL
#define PINMUX0_BASE               0x00040300UL
#define GPIO_BASE                  0x00040200UL
#define AES_BASE                   0x04000000UL
#define SHA256_BASE                0x03000000UL
#define RSA_BASE                   0x05000000UL
#define SPI_BASE                   0x00020000UL
#define QUADSPI_BASE               0x00040000UL
#define ITRACE_BASE                0x00060000UL
#define ITRACE_RAM_BASE            0x00060100UL
#define PLIC_BASE                  0x0C000000UL
#define OTP_BASE                   0x00033000UL
#define ADC_BASE                   0x00032000UL
#define I2C_OFFSET                  0x00000100UL
#define PWM_OFFSET                  0x00000100UL
#define I2C_OFFSET                  0x00000100UL
#define UART_OFFSET                 0x00000100UL
#define SPI_OFFSET                  0x00000100UL
#define GPIO_OFFSET                 0x00000008UL 
#define PWM_OFFSET                  0x00000100UL
#define GPTIMER_OFFSET              0x00000020UL
#define QSPI_OFFSET                 0x00000100UL

#define CLOCK_FREQUENCY_FPGA        40000000UL
#define CLOCK_FREQUENCY_ASIC        700000000UL
extern volatile uint8_t log_level;
extern volatile uint64_t CLOCK_FREQUENCY_BASE;
// volatile uint64_t CLOCK_FREQUENCY_BASE = CLOCK_FREQUENCY_ASIC;

/** @} */ /* End of group Device_Peripheral_peripheralAddr */


/* =========================================================================================================================== */
/* ================                                  Peripheral declaration                                   ================ */
/* =========================================================================================================================== */




/** @addtogroup Device_Peripheral_declaration
  * @{
  */

#define DMA                         ((DMA_Type*)               DMA_BASE)
#define ADC                         ((ADC_Type*)               ADC_BASE)
#define PLL                         ((PLL_Type*)               PLL_BASE)
#define PWM0                        ((PWM_Type*)               PWM0_BASE)
#define PWM1                        ((PWM_Type*)               PWM1_BASE)
#define PWM2                        ((PWM_Type*)               PWM2_BASE)
#define PWM3                        ((PWM_Type*)               PWM3_BASE)
#define PWM4                        ((PWM_Type*)               PWM4_BASE)
#define PWM5                        ((PWM_Type*)               PWM5_BASE)
#define PWM6                        ((PWM_Type*)               PWM6_BASE)
#define PWM7                        ((PWM_Type*)               PWM7_BASE)
#define PWM8                        ((PWM_Type*)               PWM8_BASE)
#define PWM9                        ((PWM_Type*)               PWM9_BASE)
#define PWM10                       ((PWM_Type*)               PWM10_BASE)
#define PWM11                       ((PWM_Type*)               PWM11_BASE)
#define PWM12                       ((PWM_Type*)               PWM12_BASE)
#define PWM13                       ((PWM_Type*)               PWM13_BASE)
#define GPTIMER0                    ((GPTIMER_Type*)           GPTIMER0_BASE)
#define GPTIMER1                    ((GPTIMER_Type*)           GPTIMER1_BASE)
#define GPTIMER2                    ((GPTIMER_Type*)           GPTIMER2_BASE)
#define GPTIMER3                    ((GPTIMER_Type*)           GPTIMER3_BASE)
#define CLINT0                      ((CLINT0_Type*)            CLINT0_BASE)
#define UART0                       ((UART_Type*)              UART0_BASE)
#define UART1                       ((UART_Type*)              UART1_BASE)
#define UART2                       ((UART_Type*)              UART2_BASE)
#define UART3                       ((UART_Type*)              UART3_BASE)
#define UART4                       ((UART_Type*)              UART4_BASE)
#define I2C0                        ((I2C_Type*)               I2C0_BASE)
#define I2C1                        ((I2C_Type*)               I2C1_BASE)
#define WDT                         ((WDT_Type*)               WDT_BASE)
#define PINMUX0                     ((PINMUX_Type*)            PINMUX0_BASE)
#define GPIO                        ((GPIO_Type*)              GPIO_BASE)
#define GPIO_PINMUX                 ((GPIO_PINMUX_Type*)       GPIO_PINMUX_BASE)
#define AES                         ((AES_Type*)               AES_BASE)
#define SHA256                      ((SHA256_Type*)            SHA256_BASE)
#define RSA                         ((RSA_Type*)               RSA_BASE)
#define SPI0                        ((SPI_Type*)               SPI0_BASE)
#define SPI1                        ((SPI_Type*)               SPI1_BASE)
#define SPI2                        ((SPI_Type*)               SPI2_BASE)
#define SPI3                        ((SPI_Type*)               SPI3_BASE)
#define QUADSPI0                    ((QUADSPI_Type*)           QUADSPI0_BASE)
#define QUADSPI1                    ((QUADSPI_Type*)           QUADSPI1_BASE)
#define ITRACE                      ((ITRACE_Type*)            ITRACE_BASE)
#define ITRACE_RAM                  ((ITRACE_RAM_Type*)        ITRACE_RAM_BASE)
#define PLIC                        ((PLIC_Type*)              PLIC_BASE)
#define OTP                         ((OTP_Type*)               OTP_BASE)

/** @addtogroup Device_Peripheral_declaration
  * @{
  */

#define I2C_REG(x)      ((I2C_Type*)(I2C_BASE + (x)*I2C_OFFSET))
#define SPI_REG(x)      ((SPI_Type*)(SPI_BASE + (x)*SPI_OFFSET))
#define UART_REG(x)     ((UART_Type*)(UART_BASE + (x)*UART_OFFSET))
#define QUADSPI_Reg(x)  ((QUADSPI_Type*)(QUADSPI_BASE + ((x) * QSPI_OFFSET)))
#define GPTIMER_REG(x)  ((GPTIMER_Type*)(GPTIMER_BASE + (x)*GPTIMER_OFFSET))
#define PWM_REG(x)      ((PWM_Type*)(PWM_BASE + (x)*PWM_OFFSET))
#define GPIO_REG        ((GPIO_Type*)(GPIO_BASE))
#define OTP             ((OTP_Type*)OTP_BASE)
#define ADC             ((ADC_Type *)ADC_BASE)
#define ITRACE          ((ITRACE_Type*)ITRACE_BASE)
#define ITRACE_RAM          ((ITRACE_RAM_Type*)ITRACE_RAM_BASE)
/** @} */ /* End of group Device_Peripheral_declaration */


/* =========================================  End of section using anonymous unions  ========================================= */
#if defined (__CC_ARM)
  #pragma pop
#elif defined (__ICCARM__)
  /* leave anonymous unions enabled */
#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
  #pragma clang diagnostic pop
#elif defined (__GNUC__)
  /* anonymous unions are enabled by default */
#elif defined (__TMS470__)
  /* anonymous unions are enabled by default */
#elif defined (__TASKING__)
  #pragma warning restore
#elif defined (__CSMC__)
  /* anonymous unions are enabled by default */
#endif


#ifdef __cplusplus
}
#endif

#endif /* SECURE_IOT_H */


/** @} */ /* End of group Secure_IoT */

/** @} */ /* End of group Mindgrove Technologies Private Limited */
