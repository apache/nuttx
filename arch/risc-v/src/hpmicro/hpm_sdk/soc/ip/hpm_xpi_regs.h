/*
 * Copyright (c) 2021-2022 HPMicro
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *
 */


#ifndef HPM_XPI_H
#define HPM_XPI_H

typedef struct {
    __RW uint32_t GCR0;                        /* 0x0: XPI General Configuration Register 0 */
    __R  uint8_t  RESERVED0[4];                /* 0x4 - 0x7: Reserved */
    __RW uint32_t GCR1;                        /* 0x8: XPI General Configuration Register 1 */
    __RW uint32_t MACR;                        /* 0xC: Memory-mapped Access Configuration Register */
    __RW uint32_t INTEN;                       /* 0x10: Interrupt Enable register. */
    __RW uint32_t INTR;                        /* 0x14: Interrupt register. */
    __RW uint32_t INSTRKEY;                    /* 0x18: INSGPR password register */
    __RW uint32_t INSTRLCK;                    /* 0x1C: INSGPR access lock control */
    __RW uint32_t AHBBUFCR[8];                 /* 0x20 - 0x3C: AHB Rx Buffer control register 0 */
    __R  uint8_t  RESERVED1[32];               /* 0x40 - 0x5F: Reserved */
    __RW uint32_t DEVSIZE[4];                  /* 0x60 - 0x6C: Size for A1 device */
    __RW uint32_t DEVATTR[4];                  /* 0x70 - 0x7C: Attribute for A1 device */
    __RW uint32_t DEVMACR[4];                  /* 0x80 - 0x8C: Memory-mapped Access Confiugration for A1 device */
    __R  uint8_t  RESERVED2[4];                /* 0x90 - 0x93: Reserved */
    __RW uint32_t DEVMISC;                     /* 0x94: Misc. for Device */
    __R  uint8_t  RESERVED3[8];                /* 0x98 - 0x9F: Reserved */
    __RW uint32_t APBDAR;                      /* 0xA0: APB Device Address Register */
    __RW uint32_t APBINSCR;                    /* 0xA4: APB Sequence Configuration Register */
    __R  uint8_t  RESERVED4[8];                /* 0xA8 - 0xAF: Reserved */
    __RW uint32_t APBCMD;                      /* 0xB0: APB Command Reg. */
    __R  uint8_t  RESERVED5[4];                /* 0xB4 - 0xB7: Reserved */
    __RW uint32_t PRXFCR;                      /* 0xB8: APB RX FIFO Control Register */
    __RW uint32_t PTXFCR;                      /* 0xBC: APB TX FIFO Control Register */
    __RW uint32_t DLLCR[2];                    /* 0xC0 - 0xC4: DLL ControlÂ  Register for CA */
    __R  uint8_t  RESERVED6[24];               /* 0xC8 - 0xDF: Reserved */
    __RW uint32_t STAT0;                       /* 0xE0: Status Register 0 */
    __RW uint32_t STAT1;                       /* 0xE4: Status Register 1 */
    __RW uint32_t STAT2;                       /* 0xE8: Status Register 2 */
    __RW uint32_t AHBSPNDSTS;                  /* 0xEC: AHB RX FIFO STATUS */
    __RW uint32_t PRXFSTS;                     /* 0xF0: APB RX FIFO STATUS */
    __RW uint32_t PTXFSTS;                     /* 0xF4: APB TX FIFO STATUS */
    __R  uint8_t  RESERVED7[8];                /* 0xF8 - 0xFF: Reserved */
    __R  uint32_t PRX[32];                     /* 0x100 - 0x17C: APB RX FIFO Data Register. */
    __W  uint32_t PTX[32];                     /* 0x180 - 0x1FC: APB TX FIFO Data Register. */
    __RW uint32_t INSTR[16];                   /* 0x200 - 0x23C: Istruction Group 0 */
} XPI_Type;


/* Bitfield definition for register: GCR0 */
/*
 * OCTCACB (RW)
 *
 * This  bit is to support Flash Octal mode access by combining Port A and B Data pins  (A_DATA[3:0] and  B_DATA[3:0]).
 * NOTE: Combination mode is not supported if Port A and Port B are 8 bit data  width. This bit should be set to zero in this case.
 * 0 - Disable.
 * 1 - Enable
 */
#define XPI_GCR0_OCTCACB_MASK (0x2000U)
#define XPI_GCR0_OCTCACB_SHIFT (13U)
#define XPI_GCR0_OCTCACB_SET(x) (((uint32_t)(x) << XPI_GCR0_OCTCACB_SHIFT) & XPI_GCR0_OCTCACB_MASK)
#define XPI_GCR0_OCTCACB_GET(x) (((uint32_t)(x) & XPI_GCR0_OCTCACB_MASK) >> XPI_GCR0_OCTCACB_SHIFT)

/*
 * HALFSPD (RW)
 *
 * Half  Speed Serial Flash access Enable.
 *         This bit enables the divide by 2 of the clock to external serial flash  devices (A_SCLK/B_SCLK) for all  commands (for both SDR and DDR mode). QSPI need to be set into MDIS mode  before changing  value of HSEN. Otherwise, it is possible to cause issue on internal  logic/state machine.
 * 0 - Disable divide by 2 of serial flash clock for half speed  commands.
 * 1 - Enable divide by 2 of serial flash clock for half speed commands.
 */
#define XPI_GCR0_HALFSPD_MASK (0x800U)
#define XPI_GCR0_HALFSPD_SHIFT (11U)
#define XPI_GCR0_HALFSPD_SET(x) (((uint32_t)(x) << XPI_GCR0_HALFSPD_SHIFT) & XPI_GCR0_HALFSPD_MASK)
#define XPI_GCR0_HALFSPD_GET(x) (((uint32_t)(x) & XPI_GCR0_HALFSPD_MASK) >> XPI_GCR0_HALFSPD_SHIFT)

/*
 * RXCLKSRC (RW)
 *
 * Sample  Clock source selection for Flash Reading Refer RX Clock Source Features for more details.
 * 00 - Dummy Read strobe generated by QSPI Controller and loopback  internally.
 * 01 - Dummy Read strobe generated by QSPI Controller and loopback from DQS  pad.
 * 10 - Reserved
 * 11 - Flash provided Read strobe and input from DQS pad
 */
#define XPI_GCR0_RXCLKSRC_MASK (0x30U)
#define XPI_GCR0_RXCLKSRC_SHIFT (4U)
#define XPI_GCR0_RXCLKSRC_SET(x) (((uint32_t)(x) << XPI_GCR0_RXCLKSRC_SHIFT) & XPI_GCR0_RXCLKSRC_MASK)
#define XPI_GCR0_RXCLKSRC_GET(x) (((uint32_t)(x) & XPI_GCR0_RXCLKSRC_MASK) >> XPI_GCR0_RXCLKSRC_SHIFT)

/*
 * DIS (RW)
 *
 * Module Disable
 * When module disabled, AHB/serial clock will be gated off internally, only  register access (except LUT/IP RX&TX FIFO) is allowed.
 */
#define XPI_GCR0_DIS_MASK (0x2U)
#define XPI_GCR0_DIS_SHIFT (1U)
#define XPI_GCR0_DIS_SET(x) (((uint32_t)(x) << XPI_GCR0_DIS_SHIFT) & XPI_GCR0_DIS_MASK)
#define XPI_GCR0_DIS_GET(x) (((uint32_t)(x) & XPI_GCR0_DIS_MASK) >> XPI_GCR0_DIS_SHIFT)

/*
 * RST (RW)
 *
 * Software Reset
 * This bit is auto-cleared by hardware after software reset done.
 * Configuration registers will not be reset.
 */
#define XPI_GCR0_RST_MASK (0x1U)
#define XPI_GCR0_RST_SHIFT (0U)
#define XPI_GCR0_RST_SET(x) (((uint32_t)(x) << XPI_GCR0_RST_SHIFT) & XPI_GCR0_RST_MASK)
#define XPI_GCR0_RST_GET(x) (((uint32_t)(x) & XPI_GCR0_RST_MASK) >> XPI_GCR0_RST_SHIFT)

/* Bitfield definition for register: GCR1 */
/*
 * SCLKBO (RW)
 *
 * B_SCLK  pad can be used as A_SCLK differential clock output (inverted clock to  A_SCLK). In this case, port B flash access is not available. After changing the value of this  field, CMD0[RST] should be set.
 * 0 - B_SCLK pad is used as port B SCLK clock output. Port B flash access is  available.
 * 1 - B_SCLK pad is used as port A SCLK inverted clock output (Differential  clock to A_SCLK). Port B flash access is not available.
 */
#define XPI_GCR1_SCLKBO_MASK (0x80000UL)
#define XPI_GCR1_SCLKBO_SHIFT (19U)
#define XPI_GCR1_SCLKBO_SET(x) (((uint32_t)(x) << XPI_GCR1_SCLKBO_SHIFT) & XPI_GCR1_SCLKBO_MASK)
#define XPI_GCR1_SCLKBO_GET(x) (((uint32_t)(x) & XPI_GCR1_SCLKBO_MASK) >> XPI_GCR1_SCLKBO_SHIFT)

/* Bitfield definition for register: MACR */
/*
 * RDALGN8B (RW)
 *
 * AHB  Read Address option bit. This option bit is intend to remove AHB burst start  address alignment limitation. When XPI controller is used for FPGA application, there may be requirement  that XPI fetch exactly the byte number as AHB burst. In this case, FPGA device should be  designed as non wordaddressable and this option bit should be set 0.
 * 0 - There is AHB read burst start address alignment limitation when flash  is accessed in parallel mode or flash is wordaddressable.
 * 1 - There is no AHB read burst start address alignment limitation. XPI will  fetch more data than AHB burst required to meet the alignment requirement.
 */
#define XPI_MACR_RDALGN8B_MASK (0x40U)
#define XPI_MACR_RDALGN8B_SHIFT (6U)
#define XPI_MACR_RDALGN8B_SET(x) (((uint32_t)(x) << XPI_MACR_RDALGN8B_SHIFT) & XPI_MACR_RDALGN8B_MASK)
#define XPI_MACR_RDALGN8B_GET(x) (((uint32_t)(x) & XPI_MACR_RDALGN8B_MASK) >> XPI_MACR_RDALGN8B_SHIFT)

/*
 * PREFETCHEN (RW)
 *
 * AHB Read Prefetch Enable.
 * When AHB read prefetch is enabled, XPI will fetch more flash read data than  current AHB burst needed so that the read latency for next AHB read access will be reduced.
 */
#define XPI_MACR_PREFETCHEN_MASK (0x20U)
#define XPI_MACR_PREFETCHEN_SHIFT (5U)
#define XPI_MACR_PREFETCHEN_SET(x) (((uint32_t)(x) << XPI_MACR_PREFETCHEN_SHIFT) & XPI_MACR_PREFETCHEN_MASK)
#define XPI_MACR_PREFETCHEN_GET(x) (((uint32_t)(x) & XPI_MACR_PREFETCHEN_MASK) >> XPI_MACR_PREFETCHEN_SHIFT)

/*
 * WRBUFEN (RW)
 *
 * Enable AHB bus bufferable write access support. This field affects the last beat of  AHB write access, refer for more details about AHB bufferable write.
 * 0 - Disabled. For all AHB write access (no matter bufferable or non-bufferable  ), XPI will return AHB Bus ready after all data is transmitted to External device and AHB  command finished.
 * 1 - Enabled. For AHB bufferable write access, XPI will return AHB Bus ready  when the AHB command is granted by arbitrator and will not wait for AHB command  finished.
 */
#define XPI_MACR_WRBUFEN_MASK (0x10U)
#define XPI_MACR_WRBUFEN_SHIFT (4U)
#define XPI_MACR_WRBUFEN_SET(x) (((uint32_t)(x) << XPI_MACR_WRBUFEN_SHIFT) & XPI_MACR_WRBUFEN_MASK)
#define XPI_MACR_WRBUFEN_GET(x) (((uint32_t)(x) & XPI_MACR_WRBUFEN_MASK) >> XPI_MACR_WRBUFEN_SHIFT)

/*
 * RDCACHEEN (RW)
 *
 * Enable AHB bus cachable read access support.
 * 0 - Disabled. When there is AHB bus cachable read access, XPI will not  check whether it hit AHB TX Buffer.
 * 1 - Enabled. When there is AHB bus cachable read access, XPI will check  whether it hit AHB TX Buffer first.
 */
#define XPI_MACR_RDCACHEEN_MASK (0x8U)
#define XPI_MACR_RDCACHEEN_SHIFT (3U)
#define XPI_MACR_RDCACHEEN_SET(x) (((uint32_t)(x) << XPI_MACR_RDCACHEEN_SHIFT) & XPI_MACR_RDCACHEEN_MASK)
#define XPI_MACR_RDCACHEEN_GET(x) (((uint32_t)(x) & XPI_MACR_RDCACHEEN_MASK) >> XPI_MACR_RDCACHEEN_SHIFT)

/*
 * CLRTXFIFO (RW)
 *
 * Clear TX Fifo
 */
#define XPI_MACR_CLRTXFIFO_MASK (0x4U)
#define XPI_MACR_CLRTXFIFO_SHIFT (2U)
#define XPI_MACR_CLRTXFIFO_SET(x) (((uint32_t)(x) << XPI_MACR_CLRTXFIFO_SHIFT) & XPI_MACR_CLRTXFIFO_MASK)
#define XPI_MACR_CLRTXFIFO_GET(x) (((uint32_t)(x) & XPI_MACR_CLRTXFIFO_MASK) >> XPI_MACR_CLRTXFIFO_SHIFT)

/*
 * CLRRXFIFO (RW)
 *
 * Clear RX Fifo
 */
#define XPI_MACR_CLRRXFIFO_MASK (0x2U)
#define XPI_MACR_CLRRXFIFO_SHIFT (1U)
#define XPI_MACR_CLRRXFIFO_SET(x) (((uint32_t)(x) << XPI_MACR_CLRRXFIFO_SHIFT) & XPI_MACR_CLRRXFIFO_MASK)
#define XPI_MACR_CLRRXFIFO_GET(x) (((uint32_t)(x) & XPI_MACR_CLRRXFIFO_MASK) >> XPI_MACR_CLRRXFIFO_SHIFT)

/* Bitfield definition for register: INTEN */
/*
 * EXECTO (RW)
 *
 * Sequence execution timeout interrupt enable.Refer Interrupts chapter for more details.
 */
#define XPI_INTEN_EXECTO_MASK (0x800U)
#define XPI_INTEN_EXECTO_SHIFT (11U)
#define XPI_INTEN_EXECTO_SET(x) (((uint32_t)(x) << XPI_INTEN_EXECTO_SHIFT) & XPI_INTEN_EXECTO_MASK)
#define XPI_INTEN_EXECTO_GET(x) (((uint32_t)(x) & XPI_INTEN_EXECTO_MASK) >> XPI_INTEN_EXECTO_SHIFT)

/*
 * BUSTO (RW)
 *
 * AHB Bus timeout interrupt.Refer Interrupts chapter for more details.
 */
#define XPI_INTEN_BUSTO_MASK (0x400U)
#define XPI_INTEN_BUSTO_SHIFT (10U)
#define XPI_INTEN_BUSTO_SET(x) (((uint32_t)(x) << XPI_INTEN_BUSTO_SHIFT) & XPI_INTEN_BUSTO_MASK)
#define XPI_INTEN_BUSTO_GET(x) (((uint32_t)(x) & XPI_INTEN_BUSTO_MASK) >> XPI_INTEN_BUSTO_SHIFT)

/*
 * PTXWE (RW)
 *
 * APB TX FIFO WaterMark empty interrupt enable. APB TX FIFO has no less empty space than WaterMark level interrupt enable.
 */
#define XPI_INTEN_PTXWE_MASK (0x40U)
#define XPI_INTEN_PTXWE_SHIFT (6U)
#define XPI_INTEN_PTXWE_SET(x) (((uint32_t)(x) << XPI_INTEN_PTXWE_SHIFT) & XPI_INTEN_PTXWE_MASK)
#define XPI_INTEN_PTXWE_GET(x) (((uint32_t)(x) & XPI_INTEN_PTXWE_MASK) >> XPI_INTEN_PTXWE_SHIFT)

/*
 * PRXWA (RW)
 *
 * APB RX FIFO WaterMark available interrupt enable. APB RX FIFO has no less valid data than WaterMark level interrupt enable.
 */
#define XPI_INTEN_PRXWA_MASK (0x20U)
#define XPI_INTEN_PRXWA_SHIFT (5U)
#define XPI_INTEN_PRXWA_SET(x) (((uint32_t)(x) << XPI_INTEN_PRXWA_SHIFT) & XPI_INTEN_PRXWA_MASK)
#define XPI_INTEN_PRXWA_GET(x) (((uint32_t)(x) & XPI_INTEN_PRXWA_MASK) >> XPI_INTEN_PRXWA_SHIFT)

/*
 * HCMDERR (RW)
 *
 * AHB triggered Command Sequences Error Detected interrupt enable.
 */
#define XPI_INTEN_HCMDERR_MASK (0x10U)
#define XPI_INTEN_HCMDERR_SHIFT (4U)
#define XPI_INTEN_HCMDERR_SET(x) (((uint32_t)(x) << XPI_INTEN_HCMDERR_SHIFT) & XPI_INTEN_HCMDERR_MASK)
#define XPI_INTEN_HCMDERR_GET(x) (((uint32_t)(x) & XPI_INTEN_HCMDERR_MASK) >> XPI_INTEN_HCMDERR_SHIFT)

/*
 * PCMDERR (RW)
 *
 * APB triggered Command Sequences Error Detected interrupt enable
 */
#define XPI_INTEN_PCMDERR_MASK (0x8U)
#define XPI_INTEN_PCMDERR_SHIFT (3U)
#define XPI_INTEN_PCMDERR_SET(x) (((uint32_t)(x) << XPI_INTEN_PCMDERR_SHIFT) & XPI_INTEN_PCMDERR_MASK)
#define XPI_INTEN_PCMDERR_GET(x) (((uint32_t)(x) & XPI_INTEN_PCMDERR_MASK) >> XPI_INTEN_PCMDERR_SHIFT)

/*
 * HCMDGTO (RO)
 *
 * AHB triggered Command Sequences Grant Timeout interrupt enable.
 */
#define XPI_INTEN_HCMDGTO_MASK (0x4U)
#define XPI_INTEN_HCMDGTO_SHIFT (2U)
#define XPI_INTEN_HCMDGTO_GET(x) (((uint32_t)(x) & XPI_INTEN_HCMDGTO_MASK) >> XPI_INTEN_HCMDGTO_SHIFT)

/*
 * PCMDGTO (RO)
 *
 * APB triggered Command Sequences Grant Timeout interrupt enable.
 */
#define XPI_INTEN_PCMDGTO_MASK (0x2U)
#define XPI_INTEN_PCMDGTO_SHIFT (1U)
#define XPI_INTEN_PCMDGTO_GET(x) (((uint32_t)(x) & XPI_INTEN_PCMDGTO_MASK) >> XPI_INTEN_PCMDGTO_SHIFT)

/*
 * PCMDD (RO)
 *
 * APB triggered Command Sequences Execution finished interrupt enable.
 */
#define XPI_INTEN_PCMDD_MASK (0x1U)
#define XPI_INTEN_PCMDD_SHIFT (0U)
#define XPI_INTEN_PCMDD_GET(x) (((uint32_t)(x) & XPI_INTEN_PCMDD_MASK) >> XPI_INTEN_PCMDD_SHIFT)

/* Bitfield definition for register: INTR */
/*
 * EXECTO (RW)
 *
 * Instruction equence execution timeout interrupt.
 */
#define XPI_INTR_EXECTO_MASK (0x800U)
#define XPI_INTR_EXECTO_SHIFT (11U)
#define XPI_INTR_EXECTO_SET(x) (((uint32_t)(x) << XPI_INTR_EXECTO_SHIFT) & XPI_INTR_EXECTO_MASK)
#define XPI_INTR_EXECTO_GET(x) (((uint32_t)(x) & XPI_INTR_EXECTO_MASK) >> XPI_INTR_EXECTO_SHIFT)

/*
 * BUSTO (RW)
 *
 * AHB Bus timeout interrupt.
 */
#define XPI_INTR_BUSTO_MASK (0x400U)
#define XPI_INTR_BUSTO_SHIFT (10U)
#define XPI_INTR_BUSTO_SET(x) (((uint32_t)(x) << XPI_INTR_BUSTO_SHIFT) & XPI_INTR_BUSTO_MASK)
#define XPI_INTR_BUSTO_GET(x) (((uint32_t)(x) & XPI_INTR_BUSTO_MASK) >> XPI_INTR_BUSTO_SHIFT)

/*
 * PTXWE (RW)
 *
 * APB TX FIFO WaterMark empty interrupt. APB TX FIFO has no less empty space than WaterMark level interrupt
 */
#define XPI_INTR_PTXWE_MASK (0x40U)
#define XPI_INTR_PTXWE_SHIFT (6U)
#define XPI_INTR_PTXWE_SET(x) (((uint32_t)(x) << XPI_INTR_PTXWE_SHIFT) & XPI_INTR_PTXWE_MASK)
#define XPI_INTR_PTXWE_GET(x) (((uint32_t)(x) & XPI_INTR_PTXWE_MASK) >> XPI_INTR_PTXWE_SHIFT)

/*
 * PRXWA (RW)
 *
 * APB RX FIFO WaterMark available interrupt. APB RX FIFO has no less valid data than WaterMark level interrupt.
 */
#define XPI_INTR_PRXWA_MASK (0x20U)
#define XPI_INTR_PRXWA_SHIFT (5U)
#define XPI_INTR_PRXWA_SET(x) (((uint32_t)(x) << XPI_INTR_PRXWA_SHIFT) & XPI_INTR_PRXWA_MASK)
#define XPI_INTR_PRXWA_GET(x) (((uint32_t)(x) & XPI_INTR_PRXWA_MASK) >> XPI_INTR_PRXWA_SHIFT)

/*
 * HCMDERR (RW)
 *
 * AHB triggered Command Sequences Error Detected interrupt.
 */
#define XPI_INTR_HCMDERR_MASK (0x10U)
#define XPI_INTR_HCMDERR_SHIFT (4U)
#define XPI_INTR_HCMDERR_SET(x) (((uint32_t)(x) << XPI_INTR_HCMDERR_SHIFT) & XPI_INTR_HCMDERR_MASK)
#define XPI_INTR_HCMDERR_GET(x) (((uint32_t)(x) & XPI_INTR_HCMDERR_MASK) >> XPI_INTR_HCMDERR_SHIFT)

/*
 * PCMDERR (RW)
 *
 * APB triggered Command Sequences Error Detected interrupt.
 */
#define XPI_INTR_PCMDERR_MASK (0x8U)
#define XPI_INTR_PCMDERR_SHIFT (3U)
#define XPI_INTR_PCMDERR_SET(x) (((uint32_t)(x) << XPI_INTR_PCMDERR_SHIFT) & XPI_INTR_PCMDERR_MASK)
#define XPI_INTR_PCMDERR_GET(x) (((uint32_t)(x) & XPI_INTR_PCMDERR_MASK) >> XPI_INTR_PCMDERR_SHIFT)

/*
 * HCMDGTO (RO)
 *
 * AHB triggered Command Sequences Grant Timeout interrupt.
 */
#define XPI_INTR_HCMDGTO_MASK (0x4U)
#define XPI_INTR_HCMDGTO_SHIFT (2U)
#define XPI_INTR_HCMDGTO_GET(x) (((uint32_t)(x) & XPI_INTR_HCMDGTO_MASK) >> XPI_INTR_HCMDGTO_SHIFT)

/*
 * PCMDGTO (RO)
 *
 * APB triggered Command Sequences Grant Timeout interrupt.
 */
#define XPI_INTR_PCMDGTO_MASK (0x2U)
#define XPI_INTR_PCMDGTO_SHIFT (1U)
#define XPI_INTR_PCMDGTO_GET(x) (((uint32_t)(x) & XPI_INTR_PCMDGTO_MASK) >> XPI_INTR_PCMDGTO_SHIFT)

/*
 * PCMDD (RO)
 *
 * APB triggered Command Sequences Execution done interrupt.
 */
#define XPI_INTR_PCMDD_MASK (0x1U)
#define XPI_INTR_PCMDD_SHIFT (0U)
#define XPI_INTR_PCMDD_GET(x) (((uint32_t)(x) & XPI_INTR_PCMDD_MASK) >> XPI_INTR_PCMDD_SHIFT)

/* Bitfield definition for register: INSTRKEY */
/*
 * KEY (RW)
 *
 * The Key to lock or unlock INSTR. The key is 0x5850594B. Read value is always 0x5850594B.
 */
#define XPI_INSTRKEY_KEY_MASK (0xFFFFFFFFUL)
#define XPI_INSTRKEY_KEY_SHIFT (0U)
#define XPI_INSTRKEY_KEY_SET(x) (((uint32_t)(x) << XPI_INSTRKEY_KEY_SHIFT) & XPI_INSTRKEY_KEY_MASK)
#define XPI_INSTRKEY_KEY_GET(x) (((uint32_t)(x) & XPI_INSTRKEY_KEY_MASK) >> XPI_INSTRKEY_KEY_SHIFT)

/* Bitfield definition for register: INSTRLCK */
/*
 * UNLOCK (RW)
 *
 * Unlock INSTR registers
 */
#define XPI_INSTRLCK_UNLOCK_MASK (0x2U)
#define XPI_INSTRLCK_UNLOCK_SHIFT (1U)
#define XPI_INSTRLCK_UNLOCK_SET(x) (((uint32_t)(x) << XPI_INSTRLCK_UNLOCK_SHIFT) & XPI_INSTRLCK_UNLOCK_MASK)
#define XPI_INSTRLCK_UNLOCK_GET(x) (((uint32_t)(x) & XPI_INSTRLCK_UNLOCK_MASK) >> XPI_INSTRLCK_UNLOCK_SHIFT)

/*
 * LOCK (RW)
 *
 * Lock INSTR registers
 */
#define XPI_INSTRLCK_LOCK_MASK (0x1U)
#define XPI_INSTRLCK_LOCK_SHIFT (0U)
#define XPI_INSTRLCK_LOCK_SET(x) (((uint32_t)(x) << XPI_INSTRLCK_LOCK_SHIFT) & XPI_INSTRLCK_LOCK_MASK)
#define XPI_INSTRLCK_LOCK_GET(x) (((uint32_t)(x) & XPI_INSTRLCK_LOCK_MASK) >> XPI_INSTRLCK_LOCK_SHIFT)

/* Bitfield definition for register array: AHBBUFCR */
/*
 * PREFETCHEN (RW)
 *
 * AHB Read Prefetch Enable for current AHB RX Buffer corresponding Master.
 */
#define XPI_AHBBUFCR_PREFETCHEN_MASK (0x80000000UL)
#define XPI_AHBBUFCR_PREFETCHEN_SHIFT (31U)
#define XPI_AHBBUFCR_PREFETCHEN_SET(x) (((uint32_t)(x) << XPI_AHBBUFCR_PREFETCHEN_SHIFT) & XPI_AHBBUFCR_PREFETCHEN_MASK)
#define XPI_AHBBUFCR_PREFETCHEN_GET(x) (((uint32_t)(x) & XPI_AHBBUFCR_PREFETCHEN_MASK) >> XPI_AHBBUFCR_PREFETCHEN_SHIFT)

/*
 * PRIORITY (RW)
 *
 * This priority for AHB Master Read which this AHB RX Buffer is assigned. 7 is the  highest priority, 0 the lowest. Please refer to Command Abort and Suspend for more details.
 */
#define XPI_AHBBUFCR_PRIORITY_MASK (0x3000000UL)
#define XPI_AHBBUFCR_PRIORITY_SHIFT (24U)
#define XPI_AHBBUFCR_PRIORITY_SET(x) (((uint32_t)(x) << XPI_AHBBUFCR_PRIORITY_SHIFT) & XPI_AHBBUFCR_PRIORITY_MASK)
#define XPI_AHBBUFCR_PRIORITY_GET(x) (((uint32_t)(x) & XPI_AHBBUFCR_PRIORITY_MASK) >> XPI_AHBBUFCR_PRIORITY_SHIFT)

/*
 * MID (RW)
 *
 * This AHB RX Buffer is assigned according to AHB Master with ID (MSTR_ID). Please refer to AHB RX Buffer Management for AHB RX Buffer allocation.
 */
#define XPI_AHBBUFCR_MID_MASK (0xF0000UL)
#define XPI_AHBBUFCR_MID_SHIFT (16U)
#define XPI_AHBBUFCR_MID_SET(x) (((uint32_t)(x) << XPI_AHBBUFCR_MID_SHIFT) & XPI_AHBBUFCR_MID_MASK)
#define XPI_AHBBUFCR_MID_GET(x) (((uint32_t)(x) & XPI_AHBBUFCR_MID_MASK) >> XPI_AHBBUFCR_MID_SHIFT)

/*
 * BUFSZ (RW)
 *
 * AHB RX Buffer Size in 64 bits. Please refer to AHB RX Buffer Management for more details.
 */
#define XPI_AHBBUFCR_BUFSZ_MASK (0xFFU)
#define XPI_AHBBUFCR_BUFSZ_SHIFT (0U)
#define XPI_AHBBUFCR_BUFSZ_SET(x) (((uint32_t)(x) << XPI_AHBBUFCR_BUFSZ_SHIFT) & XPI_AHBBUFCR_BUFSZ_MASK)
#define XPI_AHBBUFCR_BUFSZ_GET(x) (((uint32_t)(x) & XPI_AHBBUFCR_BUFSZ_MASK) >> XPI_AHBBUFCR_BUFSZ_SHIFT)

/* Bitfield definition for register array: DEVSIZE */
/*
 * SIZE_KB (RW)
 *
 * Flash Size in KByte.
 */
#define XPI_DEVSIZE_SIZE_KB_MASK (0x7FFFFFUL)
#define XPI_DEVSIZE_SIZE_KB_SHIFT (0U)
#define XPI_DEVSIZE_SIZE_KB_SET(x) (((uint32_t)(x) << XPI_DEVSIZE_SIZE_KB_SHIFT) & XPI_DEVSIZE_SIZE_KB_MASK)
#define XPI_DEVSIZE_SIZE_KB_GET(x) (((uint32_t)(x) & XPI_DEVSIZE_SIZE_KB_MASK) >> XPI_DEVSIZE_SIZE_KB_SHIFT)

/* Bitfield definition for register array: DEVATTR */
/*
 * CSINTVAL (RW)
 *
 * This field is used to set the minimum interval between flash device Chip selection  deassertion and flash device Chip selection assertion. If external flash has a limitation on the  interval between command  sequences, this field should be set accordingly. If there is no limitation,  set this field with value 0x0. When CSINTERVALUNIT is 0x0, the chip selection invalid interval is:  CSINTERVAL * 1 serial clock cycle; When CSINTERVALUNIT is 0x1, the chip selection invalid interval is:  CSINTERVAL * 256 serial clock cycle. NOTE: The chip selection interval is 2 cycle at least even if CSINTERVAL is  less than 2.
 */
#define XPI_DEVATTR_CSINTVAL_MASK (0xFFFF0000UL)
#define XPI_DEVATTR_CSINTVAL_SHIFT (16U)
#define XPI_DEVATTR_CSINTVAL_SET(x) (((uint32_t)(x) << XPI_DEVATTR_CSINTVAL_SHIFT) & XPI_DEVATTR_CSINTVAL_MASK)
#define XPI_DEVATTR_CSINTVAL_GET(x) (((uint32_t)(x) & XPI_DEVATTR_CSINTVAL_MASK) >> XPI_DEVATTR_CSINTVAL_SHIFT)

/*
 * CSINTVU (RW)
 *
 * CS interval unit
 * 0b - The CS interval unit is 1 serial clock cycle
 * 1b - The CS interval unit is 256 serial clock cycle
 */
#define XPI_DEVATTR_CSINTVU_MASK (0x8000U)
#define XPI_DEVATTR_CSINTVU_SHIFT (15U)
#define XPI_DEVATTR_CSINTVU_SET(x) (((uint32_t)(x) << XPI_DEVATTR_CSINTVU_SHIFT) & XPI_DEVATTR_CSINTVU_MASK)
#define XPI_DEVATTR_CSINTVU_GET(x) (((uint32_t)(x) & XPI_DEVATTR_CSINTVU_MASK) >> XPI_DEVATTR_CSINTVU_SHIFT)

/*
 * CAS (RW)
 *
 * Column Address Size.
 * When external flash has separate address field for row address and column  address, this field should be set to flash column address bit width. XPI will automatically split flash  mapped address to Row address and Column address according to CAS field and WA field setting.  This bit should be set to 0x0 when external Flash don't support column address. XPI will transmit all  flash address bits as Row address. For flash address mapping, please refer to Flash memory map for  more detail.
 */
#define XPI_DEVATTR_CAS_MASK (0x7800U)
#define XPI_DEVATTR_CAS_SHIFT (11U)
#define XPI_DEVATTR_CAS_SET(x) (((uint32_t)(x) << XPI_DEVATTR_CAS_SHIFT) & XPI_DEVATTR_CAS_MASK)
#define XPI_DEVATTR_CAS_GET(x) (((uint32_t)(x) & XPI_DEVATTR_CAS_MASK) >> XPI_DEVATTR_CAS_SHIFT)

/*
 * WA (RW)
 *
 * Word Addressable.
 * This bit should be set when external Flash is word addressable. If Flash is  word addressable, it should be access in terms of 16 bits. At this time, XPI will not transmit Flash  address bit 0 to external Flash. For flash address mapping, please refer to Flash memory map for more detail.
 */
#define XPI_DEVATTR_WA_MASK (0x400U)
#define XPI_DEVATTR_WA_SHIFT (10U)
#define XPI_DEVATTR_WA_SET(x) (((uint32_t)(x) << XPI_DEVATTR_WA_SHIFT) & XPI_DEVATTR_WA_MASK)
#define XPI_DEVATTR_WA_GET(x) (((uint32_t)(x) & XPI_DEVATTR_WA_MASK) >> XPI_DEVATTR_WA_SHIFT)

/*
 * TCSH (RW)
 *
 * Serial Flash CS Hold time.
 * This field is used to meet flash TCSH timing requirement. Serial flash CS  Hold time promised by XPI is: TCSH in serial root clock cycles (for both SDR and DDR mode). Please  refer to XPI Input Timing for more detail.
 */
#define XPI_DEVATTR_TCSH_MASK (0x3E0U)
#define XPI_DEVATTR_TCSH_SHIFT (5U)
#define XPI_DEVATTR_TCSH_SET(x) (((uint32_t)(x) << XPI_DEVATTR_TCSH_SHIFT) & XPI_DEVATTR_TCSH_MASK)
#define XPI_DEVATTR_TCSH_GET(x) (((uint32_t)(x) & XPI_DEVATTR_TCSH_MASK) >> XPI_DEVATTR_TCSH_SHIFT)

/*
 * TCSS (RW)
 *
 * Serial Flash CS setup time.
 * This field is used to meet flash TCSS timing requirement. Serial flash CS  Setup time promised by XPI is: (TCSS + 1/2) serial root clock cycles (for both SDR and DDR mode).  Please refer to XPI Input Timing for more detail.
 */
#define XPI_DEVATTR_TCSS_MASK (0x1FU)
#define XPI_DEVATTR_TCSS_SHIFT (0U)
#define XPI_DEVATTR_TCSS_SET(x) (((uint32_t)(x) << XPI_DEVATTR_TCSS_SHIFT) & XPI_DEVATTR_TCSS_MASK)
#define XPI_DEVATTR_TCSS_GET(x) (((uint32_t)(x) & XPI_DEVATTR_TCSS_MASK) >> XPI_DEVATTR_TCSS_SHIFT)

/* Bitfield definition for register array: DEVMACR */
/*
 * CLRINSTRPTR (RW)
 *
 * Clear the instruction pointer which is internally saved pointer by JMP_ON_CS. Refer  Programmable Sequence Engine for details. This field is used for AHB Read access to external Flash supporting XIP  (Execute-In-Place) mode
 */
#define XPI_DEVMACR_CLRINSTRPTR_MASK (0x80000000UL)
#define XPI_DEVMACR_CLRINSTRPTR_SHIFT (31U)
#define XPI_DEVMACR_CLRINSTRPTR_SET(x) (((uint32_t)(x) << XPI_DEVMACR_CLRINSTRPTR_SHIFT) & XPI_DEVMACR_CLRINSTRPTR_MASK)
#define XPI_DEVMACR_CLRINSTRPTR_GET(x) (((uint32_t)(x) & XPI_DEVMACR_CLRINSTRPTR_MASK) >> XPI_DEVMACR_CLRINSTRPTR_SHIFT)

/*
 * WRWAITUNIT (RW)
 *
 * AWRWAIT unit
 * 000b - The AWRWAIT unit is 2 ahb clock cycle
 * 001b - The AWRWAIT unit is 8 ahb clock cycle
 * 010b - The AWRWAIT unit is 32 ahb clock cycle
 * 011b - The AWRWAIT unit is 128 ahb clock cycle
 * 100b - The AWRWAIT unit is 512 ahb clock cycle
 * 101b - The AWRWAIT unit is 2048 ahb clock cycle
 * 110b - The AWRWAIT unit is 8192 ahb clock cycle
 * 111b - The AWRWAIT unit is 32768 ahb clock cycle
 */
#define XPI_DEVMACR_WRWAITUNIT_MASK (0x70000000UL)
#define XPI_DEVMACR_WRWAITUNIT_SHIFT (28U)
#define XPI_DEVMACR_WRWAITUNIT_SET(x) (((uint32_t)(x) << XPI_DEVMACR_WRWAITUNIT_SHIFT) & XPI_DEVMACR_WRWAITUNIT_MASK)
#define XPI_DEVMACR_WRWAITUNIT_GET(x) (((uint32_t)(x) & XPI_DEVMACR_WRWAITUNIT_MASK) >> XPI_DEVMACR_WRWAITUNIT_SHIFT)

/*
 * WRWAIT (RW)
 *
 * For certain devices (such as FPGA), it need some time to write data into internal  memory after the command sequences finished on XPI interface. If another Read command  sequence comes before previous programming finished internally, the read data may be wrong. This  field is used to hold AHB Bus ready for AHB write access to wait the programming finished in external  device. Then there will be no AHB read command triggered before the programming finished in external  device. The Wait cycle between AHB triggered command sequences finished on XPI interface and AHB  return Bus ready: AWRWAIT * AWRWAITUNIT
 */
#define XPI_DEVMACR_WRWAIT_MASK (0xFFF0000UL)
#define XPI_DEVMACR_WRWAIT_SHIFT (16U)
#define XPI_DEVMACR_WRWAIT_SET(x) (((uint32_t)(x) << XPI_DEVMACR_WRWAIT_SHIFT) & XPI_DEVMACR_WRWAIT_MASK)
#define XPI_DEVMACR_WRWAIT_GET(x) (((uint32_t)(x) & XPI_DEVMACR_WRWAIT_MASK) >> XPI_DEVMACR_WRWAIT_SHIFT)

/*
 * WRINSGRPNUM (RW)
 *
 * Sequence Number for AHB Write triggered Command. For certain flash devices (E.g. HyperFlash/HyperRam/Serial NAND flash), a  Flash programming access is done by several command sequences. AHB write Command will trigger  (AWRSEQNUM+1) command sequences to external flash every time. XPI executes the sequences in LUT  incrementally.
 * NOTE:
 * - Software should make sure the last sequence index never exceed LUT  sequence numbers: AWRSEQID+AWRSEQNUM < 16
 * - Software need to make sure field AWRSEQNUM and LUT is configured  correctly according to external device spec. XPI don't check the sequence and just  execute them one by one.
 */
#define XPI_DEVMACR_WRINSGRPNUM_MASK (0xE000U)
#define XPI_DEVMACR_WRINSGRPNUM_SHIFT (13U)
#define XPI_DEVMACR_WRINSGRPNUM_SET(x) (((uint32_t)(x) << XPI_DEVMACR_WRINSGRPNUM_SHIFT) & XPI_DEVMACR_WRINSGRPNUM_MASK)
#define XPI_DEVMACR_WRINSGRPNUM_GET(x) (((uint32_t)(x) & XPI_DEVMACR_WRINSGRPNUM_MASK) >> XPI_DEVMACR_WRINSGRPNUM_SHIFT)

/*
 * WRINSGRPIND (RW)
 *
 * Sequence Index for AHB Write triggered Command.
 */
#define XPI_DEVMACR_WRINSGRPIND_MASK (0xF00U)
#define XPI_DEVMACR_WRINSGRPIND_SHIFT (8U)
#define XPI_DEVMACR_WRINSGRPIND_SET(x) (((uint32_t)(x) << XPI_DEVMACR_WRINSGRPIND_SHIFT) & XPI_DEVMACR_WRINSGRPIND_MASK)
#define XPI_DEVMACR_WRINSGRPIND_GET(x) (((uint32_t)(x) & XPI_DEVMACR_WRINSGRPIND_MASK) >> XPI_DEVMACR_WRINSGRPIND_SHIFT)

/*
 * RDINSGRPNUM (RW)
 *
 * Sequence Number for AHB Read triggered Command in LUT. For certain flash devices (E.g. HyperFlash/HyperRam/Serial NAND flash), a  Flash reading access is done by several command sequences. AHB read Command will trigger (ARDSEQNUM+1)  command sequences to external flash every time. XPI executes the sequences in LUT  incrementally.
 * NOTE:
 * - Software should make sure the last sequence index never exceed LUT  sequence numbers: ARDSEQID+ARDSEQNUM <= 16
 * - Software need to make sure field ARDSEQNUM and LUT is configured  correctly according to external device spec. XPI don't check the sequence and just execute them  one by one.
 */
#define XPI_DEVMACR_RDINSGRPNUM_MASK (0xE0U)
#define XPI_DEVMACR_RDINSGRPNUM_SHIFT (5U)
#define XPI_DEVMACR_RDINSGRPNUM_SET(x) (((uint32_t)(x) << XPI_DEVMACR_RDINSGRPNUM_SHIFT) & XPI_DEVMACR_RDINSGRPNUM_MASK)
#define XPI_DEVMACR_RDINSGRPNUM_GET(x) (((uint32_t)(x) & XPI_DEVMACR_RDINSGRPNUM_MASK) >> XPI_DEVMACR_RDINSGRPNUM_SHIFT)

/*
 * RDINSGRPIND (RW)
 *
 * Sequence Index for AHB Read triggered Command in LUT
 */
#define XPI_DEVMACR_RDINSGRPIND_MASK (0xFU)
#define XPI_DEVMACR_RDINSGRPIND_SHIFT (0U)
#define XPI_DEVMACR_RDINSGRPIND_SET(x) (((uint32_t)(x) << XPI_DEVMACR_RDINSGRPIND_SHIFT) & XPI_DEVMACR_RDINSGRPIND_MASK)
#define XPI_DEVMACR_RDINSGRPIND_GET(x) (((uint32_t)(x) & XPI_DEVMACR_RDINSGRPIND_MASK) >> XPI_DEVMACR_RDINSGRPIND_SHIFT)

/* Bitfield definition for register: DEVMISC */
/*
 * WMENB (RW)
 *
 * Write mask enable bit for flash device on port B. When write mask function is  needed for memory device on port B, this bit must be set.
 * 0b - Write mask is disabled, DQS(RWDS) pin will be un-driven when writing  to external device.
 * 1b - Write mask is enabled, DQS(RWDS) pin will be driven by XPI as write  mask output when writing to external device.
 */
#define XPI_DEVMISC_WMENB_MASK (0x8U)
#define XPI_DEVMISC_WMENB_SHIFT (3U)
#define XPI_DEVMISC_WMENB_SET(x) (((uint32_t)(x) << XPI_DEVMISC_WMENB_SHIFT) & XPI_DEVMISC_WMENB_MASK)
#define XPI_DEVMISC_WMENB_GET(x) (((uint32_t)(x) & XPI_DEVMISC_WMENB_MASK) >> XPI_DEVMISC_WMENB_SHIFT)

/*
 * WMENA (RW)
 *
 * Write mask enable bit for flash device on port A. When write mask function is  needed for memory device on port A, this bit must be set.
 * 0b - Write mask is disabled, DQS(RWDS) pin will be un-driven when writing  to external device.
 * 1b - Write mask is enabled, DQS(RWDS) pin will be driven by XPI as write  mask output when writing to external device.
 */
#define XPI_DEVMISC_WMENA_MASK (0x4U)
#define XPI_DEVMISC_WMENA_SHIFT (2U)
#define XPI_DEVMISC_WMENA_SET(x) (((uint32_t)(x) << XPI_DEVMISC_WMENA_SHIFT) & XPI_DEVMISC_WMENA_MASK)
#define XPI_DEVMISC_WMENA_GET(x) (((uint32_t)(x) & XPI_DEVMISC_WMENA_MASK) >> XPI_DEVMISC_WMENA_SHIFT)

/*
 * WMOPT1 (RW)
 *
 * Write mask option bit 1. This option bit could be used to remove AHB write burst  start address alignment limitation.
 * 0b - DQS pin will be used as Write Mask when writing to external device.  There is no limitation on AHB write burst start address alignment when flash is accessed in  individual mode.
 * 1b - DQS pin will not be used as Write Mask when writing to external  device. There is limitation on AHB write burst start address alignment when flash is accessed in  individual mode.
 */
#define XPI_DEVMISC_WMOPT1_MASK (0x1U)
#define XPI_DEVMISC_WMOPT1_SHIFT (0U)
#define XPI_DEVMISC_WMOPT1_SET(x) (((uint32_t)(x) << XPI_DEVMISC_WMOPT1_SHIFT) & XPI_DEVMISC_WMOPT1_MASK)
#define XPI_DEVMISC_WMOPT1_GET(x) (((uint32_t)(x) & XPI_DEVMISC_WMOPT1_MASK) >> XPI_DEVMISC_WMOPT1_SHIFT)

/* Bitfield definition for register: APBDAR */
/*
 * DAR (RW)
 *
 * Device Address (for example, Serial NOR) for APB command
 */
#define XPI_APBDAR_DAR_MASK (0xFFFFFFFFUL)
#define XPI_APBDAR_DAR_SHIFT (0U)
#define XPI_APBDAR_DAR_SET(x) (((uint32_t)(x) << XPI_APBDAR_DAR_SHIFT) & XPI_APBDAR_DAR_MASK)
#define XPI_APBDAR_DAR_GET(x) (((uint32_t)(x) & XPI_APBDAR_DAR_MASK) >> XPI_APBDAR_DAR_SHIFT)

/* Bitfield definition for register: APBINSCR */
/*
 * PINSGRPNUM (RW)
 *
 * Sequence Number for APB command: ISEQNUM+1.
 */
#define XPI_APBINSCR_PINSGRPNUM_MASK (0x7000000UL)
#define XPI_APBINSCR_PINSGRPNUM_SHIFT (24U)
#define XPI_APBINSCR_PINSGRPNUM_SET(x) (((uint32_t)(x) << XPI_APBINSCR_PINSGRPNUM_SHIFT) & XPI_APBINSCR_PINSGRPNUM_MASK)
#define XPI_APBINSCR_PINSGRPNUM_GET(x) (((uint32_t)(x) & XPI_APBINSCR_PINSGRPNUM_MASK) >> XPI_APBINSCR_PINSGRPNUM_SHIFT)

/*
 * PINSGRPIND (RW)
 *
 * Sequence Index in INSTR for APB command.
 */
#define XPI_APBINSCR_PINSGRPIND_MASK (0xF0000UL)
#define XPI_APBINSCR_PINSGRPIND_SHIFT (16U)
#define XPI_APBINSCR_PINSGRPIND_SET(x) (((uint32_t)(x) << XPI_APBINSCR_PINSGRPIND_SHIFT) & XPI_APBINSCR_PINSGRPIND_MASK)
#define XPI_APBINSCR_PINSGRPIND_GET(x) (((uint32_t)(x) & XPI_APBINSCR_PINSGRPIND_MASK) >> XPI_APBINSCR_PINSGRPIND_SHIFT)

/*
 * PDATSZ (RW)
 *
 * Flash Read/Program Data Size (in Bytes) for APB command.
 */
#define XPI_APBINSCR_PDATSZ_MASK (0xFFFFU)
#define XPI_APBINSCR_PDATSZ_SHIFT (0U)
#define XPI_APBINSCR_PDATSZ_SET(x) (((uint32_t)(x) << XPI_APBINSCR_PDATSZ_SHIFT) & XPI_APBINSCR_PDATSZ_MASK)
#define XPI_APBINSCR_PDATSZ_GET(x) (((uint32_t)(x) & XPI_APBINSCR_PDATSZ_MASK) >> XPI_APBINSCR_PDATSZ_SHIFT)

/* Bitfield definition for register: APBCMD */
/*
 * TRG (RW)
 *
 * Setting this bit will trigger an IP Command.
 * NOTE: It's not allowed to trigger another IP command before previous IP command  is finished on XPI interface. Software need to poll register bit INTR_IP_CMD_DONE or wait  for this interrupt in order to wait for IP command finished.
 */
#define XPI_APBCMD_TRG_MASK (0x1U)
#define XPI_APBCMD_TRG_SHIFT (0U)
#define XPI_APBCMD_TRG_SET(x) (((uint32_t)(x) << XPI_APBCMD_TRG_SHIFT) & XPI_APBCMD_TRG_MASK)
#define XPI_APBCMD_TRG_GET(x) (((uint32_t)(x) & XPI_APBCMD_TRG_MASK) >> XPI_APBCMD_TRG_SHIFT)

/* Bitfield definition for register: PRXFCR */
/*
 * WMRK (RW)
 *
 * Watermark level is (RXWMRK+1)*64 Bits. Interrupt register bit IPRXWA is set when filling level in IP RX FIFO is no  less than Watermark level by XPI. There will be a DMA request when the filling level is no less than  Watermark level and DMA read is enabled (register bit RXDMAEN is set). There will be an IPRXWA (IP  RX FIFO watermark available) interrupt generated when the filling level is no less than  Watermark level and IPRXWA interrupt is enabled (register bit INTEN_IPRXWA is set).
 * NOTE: After write-1-clear to INTR[IPRXWA], read address should be rolled  back to start address (memory mapped).
 */
#define XPI_PRXFCR_WMRK_MASK (0x3CU)
#define XPI_PRXFCR_WMRK_SHIFT (2U)
#define XPI_PRXFCR_WMRK_SET(x) (((uint32_t)(x) << XPI_PRXFCR_WMRK_SHIFT) & XPI_PRXFCR_WMRK_MASK)
#define XPI_PRXFCR_WMRK_GET(x) (((uint32_t)(x) & XPI_PRXFCR_WMRK_MASK) >> XPI_PRXFCR_WMRK_SHIFT)

/*
 * DMAEN (RW)
 *
 * APB RX FIFO reading by DMA enabled.
 * 0b - IP RX FIFO would be read by processor.
 * 1b - IP RX FIFO would be read by DMA.
 */
#define XPI_PRXFCR_DMAEN_MASK (0x2U)
#define XPI_PRXFCR_DMAEN_SHIFT (1U)
#define XPI_PRXFCR_DMAEN_SET(x) (((uint32_t)(x) << XPI_PRXFCR_DMAEN_SHIFT) & XPI_PRXFCR_DMAEN_MASK)
#define XPI_PRXFCR_DMAEN_GET(x) (((uint32_t)(x) & XPI_PRXFCR_DMAEN_MASK) >> XPI_PRXFCR_DMAEN_SHIFT)

/*
 * CLRRXF (RW)
 *
 * Clear all valid data entries in APB RX FIFO. The read/write pointers in APB RX FIFO will be reset.
 */
#define XPI_PRXFCR_CLRRXF_MASK (0x1U)
#define XPI_PRXFCR_CLRRXF_SHIFT (0U)
#define XPI_PRXFCR_CLRRXF_SET(x) (((uint32_t)(x) << XPI_PRXFCR_CLRRXF_SHIFT) & XPI_PRXFCR_CLRRXF_MASK)
#define XPI_PRXFCR_CLRRXF_GET(x) (((uint32_t)(x) & XPI_PRXFCR_CLRRXF_MASK) >> XPI_PRXFCR_CLRRXF_SHIFT)

/* Bitfield definition for register: PTXFCR */
/*
 * WMRK (RW)
 *
 * Watermark level is (TXWMRK+1)*64 Bits.  Interrupt register bit IPTXWE is set when empty level in IP TX FIFO is no  less than Watermark level by XPI. There will be a DMA request when empty level is no less than Watermark  level and DMA filling is enable (register bit TXDMAEN is set). There will be an IPTXWE (IP TX  FIFO Watermark Empty) interrupt generated when empty level is no less than Watermark level and  IPTXWE interrupt is enable (register bit INTEN_IPTXWE is set).
 * NOTE:
 * - The watermark level should be no more than the write window.
 * - The watermark level should be no more than IP TX FIFO size.
 * - The write address to IP RX FIFO should roll back to the start address of  write window after pushing IP TX FIFO by writing-one-clear to INTR[IPTXWE].
 */
#define XPI_PTXFCR_WMRK_MASK (0x3CU)
#define XPI_PTXFCR_WMRK_SHIFT (2U)
#define XPI_PTXFCR_WMRK_SET(x) (((uint32_t)(x) << XPI_PTXFCR_WMRK_SHIFT) & XPI_PTXFCR_WMRK_MASK)
#define XPI_PTXFCR_WMRK_GET(x) (((uint32_t)(x) & XPI_PTXFCR_WMRK_MASK) >> XPI_PTXFCR_WMRK_SHIFT)

/*
 * DMAEN (RW)
 *
 * APB RX FIFO reading by DMA enabled.
 * 0b - APB TX FIFO would be write by processor.
 * 1b - APB TXX FIFO would be write by DMA.
 */
#define XPI_PTXFCR_DMAEN_MASK (0x2U)
#define XPI_PTXFCR_DMAEN_SHIFT (1U)
#define XPI_PTXFCR_DMAEN_SET(x) (((uint32_t)(x) << XPI_PTXFCR_DMAEN_SHIFT) & XPI_PTXFCR_DMAEN_MASK)
#define XPI_PTXFCR_DMAEN_GET(x) (((uint32_t)(x) & XPI_PTXFCR_DMAEN_MASK) >> XPI_PTXFCR_DMAEN_SHIFT)

/*
 * CLRTXF (RW)
 *
 * Clear all valid data entries in APB TX FIFO. The read/write pointers in APB TX FIFO will be reset.
 */
#define XPI_PTXFCR_CLRTXF_MASK (0x1U)
#define XPI_PTXFCR_CLRTXF_SHIFT (0U)
#define XPI_PTXFCR_CLRTXF_SET(x) (((uint32_t)(x) << XPI_PTXFCR_CLRTXF_SHIFT) & XPI_PTXFCR_CLRTXF_MASK)
#define XPI_PTXFCR_CLRTXF_GET(x) (((uint32_t)(x) & XPI_PTXFCR_CLRTXF_MASK) >> XPI_PTXFCR_CLRTXF_SHIFT)

/* Bitfield definition for register array: DLLCR */
/*
 * OVRDVAL (RW)
 *
 * Slave clock delay line delay cell number selection override value. When OVRDEN is set 0x1, the delay cell number in DLL is OVRDVAL+1.
 */
#define XPI_DLLCR_OVRDVAL_MASK (0x7E00U)
#define XPI_DLLCR_OVRDVAL_SHIFT (9U)
#define XPI_DLLCR_OVRDVAL_SET(x) (((uint32_t)(x) << XPI_DLLCR_OVRDVAL_SHIFT) & XPI_DLLCR_OVRDVAL_MASK)
#define XPI_DLLCR_OVRDVAL_GET(x) (((uint32_t)(x) & XPI_DLLCR_OVRDVAL_MASK) >> XPI_DLLCR_OVRDVAL_SHIFT)

/*
 * OVRDEN (RW)
 *
 * Slave clock delay line delay cell number selection override enable.
 */
#define XPI_DLLCR_OVRDEN_MASK (0x100U)
#define XPI_DLLCR_OVRDEN_SHIFT (8U)
#define XPI_DLLCR_OVRDEN_SET(x) (((uint32_t)(x) << XPI_DLLCR_OVRDEN_SHIFT) & XPI_DLLCR_OVRDEN_MASK)
#define XPI_DLLCR_OVRDEN_GET(x) (((uint32_t)(x) & XPI_DLLCR_OVRDEN_MASK) >> XPI_DLLCR_OVRDEN_SHIFT)

/*
 * DLYTGT (RW)
 *
 * The delay target for slave delay line is: ((DLYTARGET+1) * 1/32 * clock cycle of  reference clock (serial root clock). If serial root clock is >= 100 MHz, DLLEN set to  0x1, OVRDEN set to =0x0, then DLYTARGET setting of 0xF is recommended.
 */
#define XPI_DLLCR_DLYTGT_MASK (0x78U)
#define XPI_DLLCR_DLYTGT_SHIFT (3U)
#define XPI_DLLCR_DLYTGT_SET(x) (((uint32_t)(x) << XPI_DLLCR_DLYTGT_SHIFT) & XPI_DLLCR_DLYTGT_MASK)
#define XPI_DLLCR_DLYTGT_GET(x) (((uint32_t)(x) & XPI_DLLCR_DLYTGT_MASK) >> XPI_DLLCR_DLYTGT_SHIFT)

/*
 * RST (RW)
 *
 * Software could force a reset on DLL by setting this field to 0x1. This will cause the  DLL to lose lock and re-calibrate to detect an ref_clock half period phase shift. The reset  action is edge triggered, so software        need to clear this bit after set this bit (no delay limitation).
 */
#define XPI_DLLCR_RST_MASK (0x2U)
#define XPI_DLLCR_RST_SHIFT (1U)
#define XPI_DLLCR_RST_SET(x) (((uint32_t)(x) << XPI_DLLCR_RST_SHIFT) & XPI_DLLCR_RST_MASK)
#define XPI_DLLCR_RST_GET(x) (((uint32_t)(x) & XPI_DLLCR_RST_MASK) >> XPI_DLLCR_RST_SHIFT)

/*
 * EN (RW)
 *
 * DLL calibration enable.
 * When this bit is cleared, DLL calibration is disabled and the delay cell  number in slave delay line is always 1. Please note that SLV delay line is overridden when OVRDEN bit is  set and this bit field setting is ignored.
 */
#define XPI_DLLCR_EN_MASK (0x1U)
#define XPI_DLLCR_EN_SHIFT (0U)
#define XPI_DLLCR_EN_SET(x) (((uint32_t)(x) << XPI_DLLCR_EN_SHIFT) & XPI_DLLCR_EN_MASK)
#define XPI_DLLCR_EN_GET(x) (((uint32_t)(x) & XPI_DLLCR_EN_MASK) >> XPI_DLLCR_EN_SHIFT)

/* Bitfield definition for register: STAT0 */
/*
 * ARBCMDSRC (RO)
 *
 * This status field indicates the trigger source of current command sequence granted  by arbitrator. This field value is meaningless when ARB_CTL is not busy  (STS0[ARBIDLE]=0x1).
 * 00b - Triggered by AHB read command (triggered by AHB read).
 * 01b - Triggered by AHB write command (triggered by AHB Write).
 * 10b - Triggered by IP command (triggered by setting register bit  IPCMD.TRG).
 * 11b - Triggered by suspended command (resumed)
 */
#define XPI_STAT0_ARBCMDSRC_MASK (0xCU)
#define XPI_STAT0_ARBCMDSRC_SHIFT (2U)
#define XPI_STAT0_ARBCMDSRC_GET(x) (((uint32_t)(x) & XPI_STAT0_ARBCMDSRC_MASK) >> XPI_STAT0_ARBCMDSRC_SHIFT)

/*
 * SEQIDLE (RW)
 *
 * This status bit indicates the state machine in SEQ_CTL is idle and there is  command sequence executing on XPI interface.
 */
#define XPI_STAT0_SEQIDLE_MASK (0x1U)
#define XPI_STAT0_SEQIDLE_SHIFT (0U)
#define XPI_STAT0_SEQIDLE_SET(x) (((uint32_t)(x) << XPI_STAT0_SEQIDLE_SHIFT) & XPI_STAT0_SEQIDLE_MASK)
#define XPI_STAT0_SEQIDLE_GET(x) (((uint32_t)(x) & XPI_STAT0_SEQIDLE_MASK) >> XPI_STAT0_SEQIDLE_SHIFT)

/* Bitfield definition for register: STAT1 */
/*
 * PCMDERRCODE (RO)
 *
 * Indicates the Error Code when IP command Error detected. This field will be cleared  when INTR[IPCMDERR] is write-1-clear(w1c).
 * 0000b - No error.
 * 0010b - APB command with JMP_ON_CS instruction used in the sequence.
 * 0011b - There is unknown instruction opcode in the sequence.
 * 0100b - Instruction DUMMY_SDR/DUMMY_RWDS_SDR used in DDR sequence.
 * 0101b - Instruction DUMMY_DDR/DUMMY_RWDS_DDR used in SDR sequence.
 * 0110b - Flash access start address exceed the whole flash address range  (A1/A2/B1/B2).
 * 1110b - Sequence execution timeout.
 * 1111b - Flash boundary crossed.
 */
#define XPI_STAT1_PCMDERRCODE_MASK (0xF000000UL)
#define XPI_STAT1_PCMDERRCODE_SHIFT (24U)
#define XPI_STAT1_PCMDERRCODE_GET(x) (((uint32_t)(x) & XPI_STAT1_PCMDERRCODE_MASK) >> XPI_STAT1_PCMDERRCODE_SHIFT)

/*
 * PCMDERRID (RO)
 *
 * Indicates the sequence Index when APB command error detected. This field will be  cleared when INTR[IPCMDERR] is write-1-clear(w1c).
 */
#define XPI_STAT1_PCMDERRID_MASK (0xF0000UL)
#define XPI_STAT1_PCMDERRID_SHIFT (16U)
#define XPI_STAT1_PCMDERRID_GET(x) (((uint32_t)(x) & XPI_STAT1_PCMDERRID_MASK) >> XPI_STAT1_PCMDERRID_SHIFT)

/*
 * AHBCMDERRID (RW)
 *
 * Indicates the sequence index when an AHB command error is detected. This field will be  cleared when INTR[AHBCMDERR] is write-1-clear(w1c).
 */
#define XPI_STAT1_AHBCMDERRID_MASK (0xFU)
#define XPI_STAT1_AHBCMDERRID_SHIFT (0U)
#define XPI_STAT1_AHBCMDERRID_SET(x) (((uint32_t)(x) << XPI_STAT1_AHBCMDERRID_SHIFT) & XPI_STAT1_AHBCMDERRID_MASK)
#define XPI_STAT1_AHBCMDERRID_GET(x) (((uint32_t)(x) & XPI_STAT1_AHBCMDERRID_MASK) >> XPI_STAT1_AHBCMDERRID_SHIFT)

/* Bitfield definition for register: STAT2 */
/*
 * BREFSEL (RO)
 *
 * Flash B sample clock reference delay line delay cell number selection.
 */
#define XPI_STAT2_BREFSEL_MASK (0x3F000000UL)
#define XPI_STAT2_BREFSEL_SHIFT (24U)
#define XPI_STAT2_BREFSEL_GET(x) (((uint32_t)(x) & XPI_STAT2_BREFSEL_MASK) >> XPI_STAT2_BREFSEL_SHIFT)

/*
 * BSLVSEL (RO)
 *
 * Flash B sample clock slave delay line delay cell number selection.
 */
#define XPI_STAT2_BSLVSEL_MASK (0xFC0000UL)
#define XPI_STAT2_BSLVSEL_SHIFT (18U)
#define XPI_STAT2_BSLVSEL_GET(x) (((uint32_t)(x) & XPI_STAT2_BSLVSEL_MASK) >> XPI_STAT2_BSLVSEL_SHIFT)

/*
 * BREFLOCK (RO)
 *
 * Flash B sample clock reference delay line locked.
 */
#define XPI_STAT2_BREFLOCK_MASK (0x20000UL)
#define XPI_STAT2_BREFLOCK_SHIFT (17U)
#define XPI_STAT2_BREFLOCK_GET(x) (((uint32_t)(x) & XPI_STAT2_BREFLOCK_MASK) >> XPI_STAT2_BREFLOCK_SHIFT)

/*
 * BSLVLOCK (RO)
 *
 * Flash B sample clock slave delay line locked.
 */
#define XPI_STAT2_BSLVLOCK_MASK (0x10000UL)
#define XPI_STAT2_BSLVLOCK_SHIFT (16U)
#define XPI_STAT2_BSLVLOCK_GET(x) (((uint32_t)(x) & XPI_STAT2_BSLVLOCK_MASK) >> XPI_STAT2_BSLVLOCK_SHIFT)

/*
 * AREFSEL (RO)
 *
 * Flash A sample clock reference delay line delay cell number selection.
 */
#define XPI_STAT2_AREFSEL_MASK (0x3F00U)
#define XPI_STAT2_AREFSEL_SHIFT (8U)
#define XPI_STAT2_AREFSEL_GET(x) (((uint32_t)(x) & XPI_STAT2_AREFSEL_MASK) >> XPI_STAT2_AREFSEL_SHIFT)

/*
 * ASLVSEL (RO)
 *
 * Flash A sample clock slave delay line delay cell number selection.
 */
#define XPI_STAT2_ASLVSEL_MASK (0xFCU)
#define XPI_STAT2_ASLVSEL_SHIFT (2U)
#define XPI_STAT2_ASLVSEL_GET(x) (((uint32_t)(x) & XPI_STAT2_ASLVSEL_MASK) >> XPI_STAT2_ASLVSEL_SHIFT)

/*
 * AREFLOCK (RO)
 *
 * Flash A sample clock reference delay line locked.
 */
#define XPI_STAT2_AREFLOCK_MASK (0x2U)
#define XPI_STAT2_AREFLOCK_SHIFT (1U)
#define XPI_STAT2_AREFLOCK_GET(x) (((uint32_t)(x) & XPI_STAT2_AREFLOCK_MASK) >> XPI_STAT2_AREFLOCK_SHIFT)

/*
 * ASLVLOCK (RW)
 *
 * Flash A sample clock slave delay line locked.
 */
#define XPI_STAT2_ASLVLOCK_MASK (0x1U)
#define XPI_STAT2_ASLVLOCK_SHIFT (0U)
#define XPI_STAT2_ASLVLOCK_SET(x) (((uint32_t)(x) << XPI_STAT2_ASLVLOCK_SHIFT) & XPI_STAT2_ASLVLOCK_MASK)
#define XPI_STAT2_ASLVLOCK_GET(x) (((uint32_t)(x) & XPI_STAT2_ASLVLOCK_MASK) >> XPI_STAT2_ASLVLOCK_SHIFT)

/* Bitfield definition for register: AHBSPNDSTS */
/*
 * DATLFT (RO)
 *
 * Left Data size for suspended command sequence (in byte).
 */
#define XPI_AHBSPNDSTS_DATLFT_MASK (0xFFFF0000UL)
#define XPI_AHBSPNDSTS_DATLFT_SHIFT (16U)
#define XPI_AHBSPNDSTS_DATLFT_GET(x) (((uint32_t)(x) & XPI_AHBSPNDSTS_DATLFT_MASK) >> XPI_AHBSPNDSTS_DATLFT_SHIFT)

/*
 * BUFID (RO)
 *
 * AHB RX BUF ID for suspended command sequence
 */
#define XPI_AHBSPNDSTS_BUFID_MASK (0xEU)
#define XPI_AHBSPNDSTS_BUFID_SHIFT (1U)
#define XPI_AHBSPNDSTS_BUFID_GET(x) (((uint32_t)(x) & XPI_AHBSPNDSTS_BUFID_MASK) >> XPI_AHBSPNDSTS_BUFID_SHIFT)

/*
 * ACTIVE (RW)
 *
 * Indicates if an AHB read prefetch command sequence has been suspended.
 */
#define XPI_AHBSPNDSTS_ACTIVE_MASK (0x1U)
#define XPI_AHBSPNDSTS_ACTIVE_SHIFT (0U)
#define XPI_AHBSPNDSTS_ACTIVE_SET(x) (((uint32_t)(x) << XPI_AHBSPNDSTS_ACTIVE_SHIFT) & XPI_AHBSPNDSTS_ACTIVE_MASK)
#define XPI_AHBSPNDSTS_ACTIVE_GET(x) (((uint32_t)(x) & XPI_AHBSPNDSTS_ACTIVE_MASK) >> XPI_AHBSPNDSTS_ACTIVE_SHIFT)

/* Bitfield definition for register: PRXFSTS */
/*
 * RDCNTR (RO)
 *
 * Total Read Data Counter: RDCNTR * 64 Bits.
 */
#define XPI_PRXFSTS_RDCNTR_MASK (0xFFFF0000UL)
#define XPI_PRXFSTS_RDCNTR_SHIFT (16U)
#define XPI_PRXFSTS_RDCNTR_GET(x) (((uint32_t)(x) & XPI_PRXFSTS_RDCNTR_MASK) >> XPI_PRXFSTS_RDCNTR_SHIFT)

/*
 * FILL (RW)
 *
 * Fill level of IP RX FIFO.
 * Valid Data entries in APB RX FIFO is: FILL * 64 Bits
 */
#define XPI_PRXFSTS_FILL_MASK (0xFFU)
#define XPI_PRXFSTS_FILL_SHIFT (0U)
#define XPI_PRXFSTS_FILL_SET(x) (((uint32_t)(x) << XPI_PRXFSTS_FILL_SHIFT) & XPI_PRXFSTS_FILL_MASK)
#define XPI_PRXFSTS_FILL_GET(x) (((uint32_t)(x) & XPI_PRXFSTS_FILL_MASK) >> XPI_PRXFSTS_FILL_SHIFT)

/* Bitfield definition for register: PTXFSTS */
/*
 * RDCNTR (RO)
 *
 * Total Write Data Counter: WRCNTR * 64 Bits.
 */
#define XPI_PTXFSTS_RDCNTR_MASK (0xFFFF0000UL)
#define XPI_PTXFSTS_RDCNTR_SHIFT (16U)
#define XPI_PTXFSTS_RDCNTR_GET(x) (((uint32_t)(x) & XPI_PTXFSTS_RDCNTR_MASK) >> XPI_PTXFSTS_RDCNTR_SHIFT)

/*
 * FILL (RW)
 *
 * Fill level of APB TX FIFO.
 * Valid Data entries in APB TX FIFO is: FILL * 64 Bits
 */
#define XPI_PTXFSTS_FILL_MASK (0xFFU)
#define XPI_PTXFSTS_FILL_SHIFT (0U)
#define XPI_PTXFSTS_FILL_SET(x) (((uint32_t)(x) << XPI_PTXFSTS_FILL_SHIFT) & XPI_PTXFSTS_FILL_MASK)
#define XPI_PTXFSTS_FILL_GET(x) (((uint32_t)(x) & XPI_PTXFSTS_FILL_MASK) >> XPI_PTXFSTS_FILL_SHIFT)

/* Bitfield definition for register array: PRX */
/*
 * RXFIFO (RO)
 *
 * RX FIFO
 */
#define XPI_PRX_RXFIFO_MASK (0xFFFFFFFFUL)
#define XPI_PRX_RXFIFO_SHIFT (0U)
#define XPI_PRX_RXFIFO_GET(x) (((uint32_t)(x) & XPI_PRX_RXFIFO_MASK) >> XPI_PRX_RXFIFO_SHIFT)

/* Bitfield definition for register array: PTX */
/*
 * TXFIFO (WO)
 *
 */
#define XPI_PTX_TXFIFO_MASK (0xFFFFFFFFUL)
#define XPI_PTX_TXFIFO_SHIFT (0U)
#define XPI_PTX_TXFIFO_SET(x) (((uint32_t)(x) << XPI_PTX_TXFIFO_SHIFT) & XPI_PTX_TXFIFO_MASK)
#define XPI_PTX_TXFIFO_GET(x) (((uint32_t)(x) & XPI_PTX_TXFIFO_MASK) >> XPI_PTX_TXFIFO_SHIFT)

/* Bitfield definition for register array: INSTR */
/*
 * PHASE1 (RW)
 *
 * OPCODE1
 */
#define XPI_INSTR_PHASE1_MASK (0xFC000000UL)
#define XPI_INSTR_PHASE1_SHIFT (26U)
#define XPI_INSTR_PHASE1_SET(x) (((uint32_t)(x) << XPI_INSTR_PHASE1_SHIFT) & XPI_INSTR_PHASE1_MASK)
#define XPI_INSTR_PHASE1_GET(x) (((uint32_t)(x) & XPI_INSTR_PHASE1_MASK) >> XPI_INSTR_PHASE1_SHIFT)

/*
 * PADS1 (RW)
 *
 * NUMPADS1
 */
#define XPI_INSTR_PADS1_MASK (0x3000000UL)
#define XPI_INSTR_PADS1_SHIFT (24U)
#define XPI_INSTR_PADS1_SET(x) (((uint32_t)(x) << XPI_INSTR_PADS1_SHIFT) & XPI_INSTR_PADS1_MASK)
#define XPI_INSTR_PADS1_GET(x) (((uint32_t)(x) & XPI_INSTR_PADS1_MASK) >> XPI_INSTR_PADS1_SHIFT)

/*
 * OPERAND1 (RW)
 *
 * OPERAND1
 */
#define XPI_INSTR_OPERAND1_MASK (0xFF0000UL)
#define XPI_INSTR_OPERAND1_SHIFT (16U)
#define XPI_INSTR_OPERAND1_SET(x) (((uint32_t)(x) << XPI_INSTR_OPERAND1_SHIFT) & XPI_INSTR_OPERAND1_MASK)
#define XPI_INSTR_OPERAND1_GET(x) (((uint32_t)(x) & XPI_INSTR_OPERAND1_MASK) >> XPI_INSTR_OPERAND1_SHIFT)

/*
 * PHASE0 (RW)
 *
 * OPCODE0
 */
#define XPI_INSTR_PHASE0_MASK (0xFC00U)
#define XPI_INSTR_PHASE0_SHIFT (10U)
#define XPI_INSTR_PHASE0_SET(x) (((uint32_t)(x) << XPI_INSTR_PHASE0_SHIFT) & XPI_INSTR_PHASE0_MASK)
#define XPI_INSTR_PHASE0_GET(x) (((uint32_t)(x) & XPI_INSTR_PHASE0_MASK) >> XPI_INSTR_PHASE0_SHIFT)

/*
 * PADS0 (RW)
 *
 * NUMPADS0
 */
#define XPI_INSTR_PADS0_MASK (0x300U)
#define XPI_INSTR_PADS0_SHIFT (8U)
#define XPI_INSTR_PADS0_SET(x) (((uint32_t)(x) << XPI_INSTR_PADS0_SHIFT) & XPI_INSTR_PADS0_MASK)
#define XPI_INSTR_PADS0_GET(x) (((uint32_t)(x) & XPI_INSTR_PADS0_MASK) >> XPI_INSTR_PADS0_SHIFT)

/*
 * OPERAND0 (RW)
 *
 * OPERAND0
 */
#define XPI_INSTR_OPERAND0_MASK (0xFFU)
#define XPI_INSTR_OPERAND0_SHIFT (0U)
#define XPI_INSTR_OPERAND0_SET(x) (((uint32_t)(x) << XPI_INSTR_OPERAND0_SHIFT) & XPI_INSTR_OPERAND0_MASK)
#define XPI_INSTR_OPERAND0_GET(x) (((uint32_t)(x) & XPI_INSTR_OPERAND0_MASK) >> XPI_INSTR_OPERAND0_SHIFT)



/* AHBBUFCR register group index macro definition */
#define XPI_AHBBUFCR_M0 (0UL)
#define XPI_AHBBUFCR_M1 (1UL)
#define XPI_AHBBUFCR_M2 (2UL)
#define XPI_AHBBUFCR_M3 (3UL)
#define XPI_AHBBUFCR_M4 (4UL)
#define XPI_AHBBUFCR_M5 (5UL)
#define XPI_AHBBUFCR_M6 (6UL)
#define XPI_AHBBUFCR_M7 (7UL)

/* DEVSIZE register group index macro definition */
#define XPI_DEVSIZE_A1 (0UL)
#define XPI_DEVSIZE_A2 (1UL)
#define XPI_DEVSIZE_B1 (2UL)
#define XPI_DEVSIZE_B2 (3UL)

/* DEVATTR register group index macro definition */
#define XPI_DEVATTR_A1 (0UL)
#define XPI_DEVATTR_A2 (1UL)
#define XPI_DEVATTR_B1 (2UL)
#define XPI_DEVATTR_B2 (3UL)

/* DEVMACR register group index macro definition */
#define XPI_DEVMACR_A1 (0UL)
#define XPI_DEVMACR_A2 (1UL)
#define XPI_DEVMACR_B1 (2UL)
#define XPI_DEVMACR_B2 (3UL)

/* DLLCR register group index macro definition */
#define XPI_DLLCR_DLLA (0UL)
#define XPI_DLLCR_DLLB (1UL)

/* PRX register group index macro definition */
#define XPI_PRX_PBDR0 (0UL)
#define XPI_PRX_PBDR1 (1UL)
#define XPI_PRX_PBDR2 (2UL)
#define XPI_PRX_PBDR3 (3UL)
#define XPI_PRX_PBDR4 (4UL)
#define XPI_PRX_PBDR5 (5UL)
#define XPI_PRX_PBDR6 (6UL)
#define XPI_PRX_PBDR7 (7UL)
#define XPI_PRX_PBDR8 (8UL)
#define XPI_PRX_PBDR9 (9UL)
#define XPI_PRX_PBDR10 (10UL)
#define XPI_PRX_PBDR11 (11UL)
#define XPI_PRX_PBDR12 (12UL)
#define XPI_PRX_PBDR13 (13UL)
#define XPI_PRX_PBDR14 (14UL)
#define XPI_PRX_PBDR15 (15UL)
#define XPI_PRX_PBDR16 (16UL)
#define XPI_PRX_PBDR17 (17UL)
#define XPI_PRX_PBDR18 (18UL)
#define XPI_PRX_PBDR19 (19UL)
#define XPI_PRX_PBDR20 (20UL)
#define XPI_PRX_PBDR21 (21UL)
#define XPI_PRX_PBDR22 (22UL)
#define XPI_PRX_PBDR23 (23UL)
#define XPI_PRX_PBDR24 (24UL)
#define XPI_PRX_PBDR25 (25UL)
#define XPI_PRX_PBDR26 (26UL)
#define XPI_PRX_PBDR27 (27UL)
#define XPI_PRX_PBDR28 (28UL)
#define XPI_PRX_PBDR29 (29UL)
#define XPI_PRX_PBDR30 (30UL)
#define XPI_PRX_PBDR31 (31UL)

/* PTX register group index macro definition */
#define XPI_PTX_PBDR0 (0UL)
#define XPI_PTX_PBDR1 (1UL)
#define XPI_PTX_PBDR2 (2UL)
#define XPI_PTX_PBDR3 (3UL)
#define XPI_PTX_PBDR4 (4UL)
#define XPI_PTX_PBDR5 (5UL)
#define XPI_PTX_PBDR6 (6UL)
#define XPI_PTX_PBDR7 (7UL)
#define XPI_PTX_PBDR8 (8UL)
#define XPI_PTX_PBDR9 (9UL)
#define XPI_PTX_PBDR10 (10UL)
#define XPI_PTX_PBDR11 (11UL)
#define XPI_PTX_PBDR12 (12UL)
#define XPI_PTX_PBDR13 (13UL)
#define XPI_PTX_PBDR14 (14UL)
#define XPI_PTX_PBDR15 (15UL)
#define XPI_PTX_PBDR16 (16UL)
#define XPI_PTX_PBDR17 (17UL)
#define XPI_PTX_PBDR18 (18UL)
#define XPI_PTX_PBDR19 (19UL)
#define XPI_PTX_PBDR20 (20UL)
#define XPI_PTX_PBDR21 (21UL)
#define XPI_PTX_PBDR22 (22UL)
#define XPI_PTX_PBDR23 (23UL)
#define XPI_PTX_PBDR24 (24UL)
#define XPI_PTX_PBDR25 (25UL)
#define XPI_PTX_PBDR26 (26UL)
#define XPI_PTX_PBDR27 (27UL)
#define XPI_PTX_PBDR28 (28UL)
#define XPI_PTX_PBDR29 (29UL)
#define XPI_PTX_PBDR30 (30UL)
#define XPI_PTX_PBDR31 (31UL)

/* INSTR register group index macro definition */
#define XPI_INSTR_INSTGRP0 (0UL)
#define XPI_INSTR_INSTGRP1 (1UL)
#define XPI_INSTR_INSTGRP2 (2UL)
#define XPI_INSTR_INSTGRP3 (3UL)
#define XPI_INSTR_INSTGRP4 (4UL)
#define XPI_INSTR_INSTGRP5 (5UL)
#define XPI_INSTR_INSTGRP6 (6UL)
#define XPI_INSTR_INSTGRP7 (7UL)
#define XPI_INSTR_INSTGRP8 (8UL)
#define XPI_INSTR_INSTGRP9 (9UL)
#define XPI_INSTR_INSTGRP10 (10UL)
#define XPI_INSTR_INSTGRP11 (11UL)
#define XPI_INSTR_INSTGRP12 (12UL)
#define XPI_INSTR_INSTGRP13 (13UL)
#define XPI_INSTR_INSTGRP14 (14UL)
#define XPI_INSTR_INSTGRP15 (15UL)


#endif /* HPM_XPI_H */