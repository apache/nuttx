/*
 * Copyright(c) 2007 - 2018 Realtek Corporation. All rights reserved.
 * SPDX-License-Identifier: Apache-2.0 
 * Licensed under the Apache License, Version 2.0 (the License); you may 
 * not use this file except in compliance with the License. 
 * You may obtain a copy of the License at 
 * 
 * http://www.apache.org/licenses/LICENSE-2.0 
 * 
 * Unless required by applicable law or agreed to in writing, software 
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT 
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
 * See the License for the specific language governing permissions and 
 * limitations under the License.
 *
 * @file     rtl8710c.h
 * @brief    CMSIS HeaderFile
 * @version  1.0
 * @date     04. June 2018
 * @note     Generated by SVDConv V3.3.13 on Monday, 04.06.2018 21:34:40
 *           from File 'rtl8710c.svd',
 *           last modified on Monday, 04.06.2018 13:34:19
 */



/** @addtogroup Realtek Realtek Semiconductor Corp.
  * @{
  */


/** @addtogroup rtl8710c
  * @{
  */


#ifndef RTL8710C_H
#define RTL8710C_H

#ifdef __cplusplus
extern "C" {
#endif


/** @addtogroup Configuration_of_CMSIS
  * @{
  */



/* =========================================================================================================================== */
/* ================                                Interrupt Number Definition                                ================ */
/* =========================================================================================================================== */

enum {
/* ========================================  ARM ARMV8MML Specific Interrupt Numbers  ======================================== */
  Reset_IRQn                = -15,              /*!< -15  Reset Vector, invoked on Power up and warm reset                     */
  NonMaskableInt_IRQn       = -14,              /*!< -14  Non maskable Interrupt, cannot be stopped or preempted               */
  HardFault_IRQn            = -13,              /*!< -13  Hard Fault, all classes of Fault                                     */
  MemoryManagement_IRQn     = -12,              /*!< -12  Memory Management, MPU mismatch, including Access Violation
                                                     and No Match                                                              */
  BusFault_IRQn             = -11,              /*!< -11  Bus Fault, Pre-Fetch-, Memory Access Fault, other address/memory
                                                     related Fault                                                             */
  UsageFault_IRQn           = -10,              /*!< -10  Usage Fault, i.e. Undef Instruction, Illegal State Transition        */
  SecureFault_IRQn          =  -9,              /*!< -9 Secure Fault Handler                                                   */
  SVCall_IRQn               =  -5,              /*!< -5 System Service Call via SVC instruction                                */
  DebugMonitor_IRQn         =  -4,              /*!< -4 Debug Monitor                                                          */
  PendSV_IRQn               =  -2,              /*!< -2 Pendable request for system service                                    */
  SysTick_IRQn              =  -1,              /*!< -1 System Tick Timer                                                      */
/* ==========================================  rtl8710c Specific Interrupt Numbers  ========================================== */
  System_IRQn               =   0,              /*!< 0  System                                                                 */
  TimerGroup0_IRQn          =   1,              /*!< 1  TimerGroup0                                                            */
  TimerGroup1_IRQn          =   2,              /*!< 2  TimerGroup1                                                            */
  GPIO_IRQn                 =   3,              /*!< 3  GPIO                                                                   */
  PWM_IRQn                  =   4,              /*!< 4  PWM                                                                    */
  UART_IRQn                 =   5,              /*!< 5  UART                                                                   */
  SSI_IRQn                  =   6,              /*!< 6  SSI                                                                    */
  I2C_IRQn                  =   7,              /*!< 7  I2C                                                                    */
  GDMA0_IRQn                =   8,              /*!< 8  GDMA0                                                                  */
  LowPri_IRQn               =   9,              /*!< 9  LowPri                                                                 */
  Crypto_IRQn               =  10,              /*!< 10 Crypto                                                                 */
  SDIOD_IRQn                =  11,              /*!< 11 SDIOD                                                                  */
  WLAN_IRQn                 =  12,              /*!< 12 WLAN                                                                   */
  SGDMA0_IRQn               =  13,              /*!< 13 SGDMA0                                                                 */
  SLowPri_IRQn              =  14,              /*!< 14 SLowPri                                                                */
  SCrypto_IRQn              =  15               /*!< 15 SCrypto                                                                */
};
typedef int32_t IRQn_Type;



/* =========================================================================================================================== */
/* ================                           Processor and Core Peripheral Section                           ================ */
/* =========================================================================================================================== */

/* ===========================  Configuration of the ARM ARMV8MML Processor and Core Peripherals  ============================ */
#define __ARMV8MML_REV                 0x0000U  /*!< ARMV8MML Core Revision                                                    */
#define __NVIC_PRIO_BITS               3        /*!< Number of Bits used for Priority Levels                                   */
#define __Vendor_SysTickConfig         0        /*!< Set to 1 if different SysTick Config is used                              */
#define __VTOR_PRESENT                 1        /*!< Set to 1 if CPU supports Vector Table Offset Register                     */
#define __MPU_PRESENT                  1        /*!< MPU present or not                                                        */
#define __FPU_PRESENT                  0        /*!< FPU present or not                                                        */
#define __FPU_DP                       0        /*!< unused, Device has no FPU                                                 */
#define __SAUREGION_PRESENT            1        /*!< SAU present or not                                                        */
#define __DSP_PRESENT                  1        /*!< DSP extension present                                                     */


/** @} */ /* End of group Configuration_of_CMSIS */

#include "core_armv8mml.h"                      /*!< ARM ARMV8MML processor and core peripherals                               */
#include "system_rtl8710c.h"                    /*!< rtl8710c System                                                           */

#ifndef __IM                                    /*!< Fallback for older CMSIS versions                                         */
  #define __IM   __I
#endif
#ifndef __OM                                    /*!< Fallback for older CMSIS versions                                         */
  #define __OM   __O
#endif
#ifndef __IOM                                   /*!< Fallback for older CMSIS versions                                         */
  #define __IOM  __IO
#endif


/* ========================================  Start of section using anonymous unions  ======================================== */
#if defined (__CC_ARM)
  #pragma push
  #pragma anon_unions
#elif defined (__ICCARM__)
  #pragma language=extended
#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wc11-extensions"
  #pragma clang diagnostic ignored "-Wreserved-id-macro"
  #pragma clang diagnostic ignored "-Wgnu-anonymous-struct"
  #pragma clang diagnostic ignored "-Wnested-anon-types"
#elif defined (__GNUC__)
  /* anonymous unions are enabled by default */
#elif defined (__TMS470__)
  /* anonymous unions are enabled by default */
#elif defined (__TASKING__)
  #pragma warning 586
#elif defined (__CSMC__)
  /* anonymous unions are enabled by default */
#else
  #warning Not supported compiler type
#endif


/* =========================================================================================================================== */
/* ================                            Device Specific Peripheral Section                             ================ */
/* =========================================================================================================================== */


/** @addtogroup Device_Peripheral_peripherals
  * @{
  */



/* =========================================================================================================================== */
/* ================                                          MiscIRQ                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief System Power Control (MiscIRQ)
  */

typedef struct {                                /*!< (@ 0x00000000) MiscIRQ Structure                                          */
  
  union {
    __IM  uint32_t dummy_reg;                   /*!< (@ 0x00000000) Registers definition is not exposed                        */
    
    struct {
      __IM  uint32_t temp       : 32;           /*!< [31..0] temp                                                              */
    } dummy_reg_b;
  } ;
} MiscIRQ_Type;                                 /*!< Size = 4 (0x4)                                                            */



/* =========================================================================================================================== */
/* ================                                           GPIO                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief General Purpose I/O (GPIO)
  */

typedef struct {                                /*!< (@ 0x40001000) GPIO Structure                                             */
  
  union {
    __IM  uint32_t it_sts;                      /*!< (@ 0x00000000) GPIO interrupt type status Register                        */
    
    struct {
      __IM  uint32_t gpio_it_sts : 16;          /*!< [15..0] For each bit: 0: the specific GPIO pin is configured
                                                     to edge sensitive interrupt mode 1: the specific GPIO pin
                                                     is configured to levle sensitive interrupt mode.                          */
    } it_sts_b;
  } ;
  
  union {
    __IOM uint32_t ei_en;                       /*!< (@ 0x00000004) GPIO edge sensitive interrupt mode enable                  */
    
    struct {
      __IOM uint32_t ei_en      : 16;           /*!< [15..0] For each bit write: 0: No operation 1: the conrtolled
                                                     GPIO pin is configured as edge sensitive interrupt mode
                                                     and also cause the corresponging bit of REG_GPIO_IT_STS
                                                     to be read as zero.                                                       */
    } ei_en_b;
  } ;
  
  union {
    __IOM uint32_t li_en;                       /*!< (@ 0x00000008) GPIO level sensitive interrupt mode enable                 */
    
    struct {
      __IOM uint32_t li_en      : 16;           /*!< [15..0] For each bit write: 0: No operation 1: the conrtolled
                                                     GPIO pin is configured as level sensitive interrupt mode
                                                     and also cause the corresponging bit of REG_GPIO_IT_STS
                                                     to be read as 1.                                                          */
    } li_en_b;
  } ;
  
  union {
    __IM  uint32_t ip_sts;                      /*!< (@ 0x0000000C) GPIO interrupt polarity status                             */
    
    struct {
      __IM  uint32_t ip_sts0    : 2;            /*!< [1..0] 00: the specific GPIO pin is configured as rising-edge
                                                     (active-high sensitive) 01: the specific GPIO pin is configured
                                                     as falling-edge (active-low sensitive) 10: the specific
                                                     GPIO pin is configured as dual-edge 11: reserved                          */
      __IM  uint32_t ip_sts1    : 2;            /*!< [3..2] 00: the specific GPIO pin is configured as rising-edge
                                                     (active-high sensitive) 01: the specific GPIO pin is configured
                                                     as falling-edge (active-low sensitive) 10: the specific
                                                     GPIO pin is configured as dual-edge 11: reserved                          */
      __IM  uint32_t ip_sts2    : 2;            /*!< [5..4] 00: the specific GPIO pin is configured as rising-edge
                                                     (active-high sensitive) 01: the specific GPIO pin is configured
                                                     as falling-edge (active-low sensitive) 10: the specific
                                                     GPIO pin is configured as dual-edge 11: reserved                          */
      __IM  uint32_t ip_sts3    : 2;            /*!< [7..6] 00: the specific GPIO pin is configured as rising-edge
                                                     (active-high sensitive) 01: the specific GPIO pin is configured
                                                     as falling-edge (active-low sensitive) 10: the specific
                                                     GPIO pin is configured as dual-edge 11: reserved                          */
      __IM  uint32_t ip_sts4    : 2;            /*!< [9..8] 00: the specific GPIO pin is configured as rising-edge
                                                     (active-high sensitive) 01: the specific GPIO pin is configured
                                                     as falling-edge (active-low sensitive) 10: the specific
                                                     GPIO pin is configured as dual-edge 11: reserved                          */
      __IM  uint32_t ip_sts5    : 2;            /*!< [11..10] 00: the specific GPIO pin is configured as rising-edge
                                                     (active-high sensitive) 01: the specific GPIO pin is configured
                                                     as falling-edge (active-low sensitive) 10: the specific
                                                     GPIO pin is configured as dual-edge 11: reserved                          */
      __IM  uint32_t ip_sts6    : 2;            /*!< [13..12] 00: the specific GPIO pin is configured as rising-edge
                                                     (active-high sensitive) 01: the specific GPIO pin is configured
                                                     as falling-edge (active-low sensitive) 10: the specific
                                                     GPIO pin is configured as dual-edge 11: reserved                          */
      __IM  uint32_t ip_sts7    : 2;            /*!< [15..14] 00: the specific GPIO pin is configured as rising-edge
                                                     (active-high sensitive) 01: the specific GPIO pin is configured
                                                     as falling-edge (active-low sensitive) 10: the specific
                                                     GPIO pin is configured as dual-edge 11: reserved                          */
      __IM  uint32_t ip_sts8    : 2;            /*!< [17..16] 00: the specific GPIO pin is configured as rising-edge
                                                     (active-high sensitive) 01: the specific GPIO pin is configured
                                                     as falling-edge (active-low sensitive) 10: the specific
                                                     GPIO pin is configured as dual-edge 11: reserved                          */
      __IM  uint32_t ip_sts9    : 2;            /*!< [19..18] 00: the specific GPIO pin is configured as rising-edge
                                                     (active-high sensitive) 01: the specific GPIO pin is configured
                                                     as falling-edge (active-low sensitive) 10: the specific
                                                     GPIO pin is configured as dual-edge 11: reserved                          */
      __IM  uint32_t ip_sts10   : 2;            /*!< [21..20] 00: the specific GPIO pin is configured as rising-edge
                                                     (active-high sensitive) 01: the specific GPIO pin is configured
                                                     as falling-edge (active-low sensitive) 10: the specific
                                                     GPIO pin is configured as dual-edge 11: reserved                          */
      __IM  uint32_t ip_sts11   : 2;            /*!< [23..22] 00: the specific GPIO pin is configured as rising-edge
                                                     (active-high sensitive) 01: the specific GPIO pin is configured
                                                     as falling-edge (active-low sensitive) 10: the specific
                                                     GPIO pin is configured as dual-edge 11: reserved                          */
      __IM  uint32_t ip_sts12   : 2;            /*!< [25..24] 00: the specific GPIO pin is configured as rising-edge
                                                     (active-high sensitive) 01: the specific GPIO pin is configured
                                                     as falling-edge (active-low sensitive) 10: the specific
                                                     GPIO pin is configured as dual-edge 11: reserved                          */
      __IM  uint32_t ip_sts13   : 2;            /*!< [27..26] 00: the specific GPIO pin is configured as rising-edge
                                                     (active-high sensitive) 01: the specific GPIO pin is configured
                                                     as falling-edge (active-low sensitive) 10: the specific
                                                     GPIO pin is configured as dual-edge 11: reserved                          */
      __IM  uint32_t ip_sts14   : 2;            /*!< [29..28] 00: the specific GPIO pin is configured as rising-edge
                                                     (active-high sensitive) 01: the specific GPIO pin is configured
                                                     as falling-edge (active-low sensitive) 10: the specific
                                                     GPIO pin is configured as dual-edge 11: reserved                          */
      __IM  uint32_t ip_sts15   : 2;            /*!< [31..30] The interrupt polarity status of GPIO15                          */
    } ip_sts_b;
  } ;
  __IM  uint32_t  RESERVED;
  
  union {
    __IOM uint32_t ir_en;                       /*!< (@ 0x00000014) GPIO interrupt rising-edge enable                          */
    
    struct {
      __IOM uint32_t ir_en      : 16;           /*!< [15..0] For each bit write: 0: No operation; 1: the conrtolled
                                                     GPIO pin is configured to rising-edge interrupt mode or
                                                     high-level mode (depends on REG_GPIO_IT_STS) and also cause
                                                     the corresponding bits of REG_GPIO_IP_STS to be read as
                                                     00b.                                                                      */
    } ir_en_b;
  } ;
  
  union {
    __IOM uint32_t if_en;                       /*!< (@ 0x00000018) GPIO interrupt falling-edge enable                         */
    
    struct {
      __IOM uint32_t if_en      : 16;           /*!< [15..0] For each bit write: 0: No operation; 1: the conrtolled
                                                     GPIO pin is configured to falling-edge interrupt mode or
                                                     low-level interrupt mode (depends on REG_GPIO_IT_STS) and
                                                     cause the corresponding bits of REG_GPIO_IP_STS to be read
                                                     as 01b.                                                                   */
    } if_en_b;
  } ;
  
  union {
    __IOM uint32_t id_en;                       /*!< (@ 0x0000001C) GPIO interrupt dual-edge enable                            */
    
    struct {
      __IOM uint32_t id_en      : 16;           /*!< [15..0] For each bit write: 0: No operation; 1: the conrtolled
                                                     GPIO pin is configured to dual-edge interrupt mode and
                                                     also cause the corresponding bits of REG_GPIO_IP_STS to
                                                     be read as 10b.                                                           */
    } id_en_b;
  } ;
  
  union {
    __IM  uint32_t ie_sts;                      /*!< (@ 0x00000020) GPIO interrupt enable status                               */
    
    struct {
      __IM  uint32_t ie_sts     : 16;           /*!< [15..0] For each bit: 0: the interrupt of the specific GPIO
                                                     pin is disabled 1: the interrupt of the specific GPIO pin
                                                     is enabled                                                                */
    } ie_sts_b;
  } ;
  
  union {
    __IOM uint32_t int_en;                      /*!< (@ 0x00000024) GPIO interrupt enable                                      */
    
    struct {
      __IOM uint32_t int_en     : 16;           /*!< [15..0] For each bit write: 0: No operation 1: to enable the
                                                     specific GPIO INT and also cause the specified bit of REG_GPIO_IE_STS
                                                     to be read as ONE.                                                        */
    } int_en_b;
  } ;
  
  union {
    __IOM uint32_t int_dis;                     /*!< (@ 0x00000028) GPIO interrupt disable                                     */
    
    struct {
      __IOM uint32_t int_dis    : 16;           /*!< [15..0] For each bit write: 0: No operation 1: to disable the
                                                     specified GPIO INT and also cause the specified bit of
                                                     REG_GPIO_IE_STS to be read as ZERO.                                       */
    } int_dis_b;
  } ;
  
  union {
    __IM  uint32_t int_raw_sts;                 /*!< (@ 0x0000002C) GPIO RAW interrupt status                                  */
    
    struct {
      __IM  uint32_t int_raw_sts : 16;          /*!< [15..0] For each bit: 0: the specified GPIO pin has no pending
                                                     interrupt 1: the specified GPIO pin's interrupt is pending
                                                     (permasking)                                                              */
    } int_raw_sts_b;
  } ;
  
  union {
    __IM  uint32_t int_sts;                     /*!< (@ 0x00000030) GPIO interrupt status                                      */
    
    struct {
      __IM  uint32_t int_sts    : 16;           /*!< [15..0] For each bit: 0: the specified GPIO pin has no pending
                                                     interrupt 1: the specified GPIO pin's interrupt is pending                */
    } int_sts_b;
  } ;
  
  union {
    __IOM uint32_t int_clr;                     /*!< (@ 0x00000034) GPIO interrupt status clear                                */
    
    struct {
      __IOM uint32_t int_clr    : 16;           /*!< [15..0] For each bit writting: 0: No operation; 1: Clear edge
                                                     type pending interrupt of the conrtolled GPIO pin and clear
                                                     the specified bits of REG_GPIO_INT_STS as ZERO                            */
    } int_clr_b;
  } ;
  
  union {
    __IM  uint32_t int_func_en_sts;             /*!< (@ 0x00000038) GPIO interrupt function enable status                      */
    
    struct {
      __IM  uint32_t int_en_sts : 16;           /*!< [15..0] For each bit: 0: the specified GPIO INT is Disable 1:
                                                     the specified GPIO INT is Enable                                          */
    } int_func_en_sts_b;
  } ;
  
  union {
    __IOM uint32_t int_func_en;                 /*!< (@ 0x0000003C) GPIO interrupt function enable                             */
    
    struct {
      __IOM uint32_t int_en     : 16;           /*!< [15..0] For each bit write: 0: No operation 1: the specified
                                                     GPIO INT is enabled and also cause the specified bit of
                                                     REG_GPIO_INT_FUNC_EN_STS to be read as ONE.                               */
    } int_func_en_b;
  } ;
  
  union {
    __IOM uint32_t int_func_dis;                /*!< (@ 0x00000040) GPIO interrupt function disable                            */
    
    struct {
      __IOM uint32_t int_dis    : 16;           /*!< [15..0] For each bit write: 0: No operation 1: the specified
                                                     GPIO INT is disabled and also cause the specified bit of
                                                     REG_GPIO_INT_FUNC_EN_STS to be read as ZERO.                              */
    } int_func_dis_b;
  } ;
  __IM  uint32_t  RESERVED1[3];
  
  union {
    __IOM uint32_t int0_sel;                    /*!< (@ 0x00000050) GPIO INT0 selection                                        */
    
    struct {
      __IOM uint32_t int_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for GPIO INT0                      */
      __IOM uint32_t int_gp_sel : 2;            /*!< [6..5] GPIO port selection for GPIO INT0                                  */
      __IM  uint32_t            : 1;
      __IOM uint32_t int_deb_sel : 4;           /*!< [11..8] Debounce Output signal selection for GPIO INT0                    */
      __IM  uint32_t            : 3;
      __IOM uint32_t int_sur_sel : 1;           /*!< [15..15] 0: Useing pin input signal as interrupt signal source
                                                     1: Using debounce output signal as interrupt signal source                */
    } int0_sel_b;
  } ;
  
  union {
    __IOM uint32_t int1_sel;                    /*!< (@ 0x00000054) GPIO INT1 selection                                        */
    
    struct {
      __IOM uint32_t int_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for GPIO INT1                      */
      __IOM uint32_t int_gp_sel : 2;            /*!< [6..5] GPIO port selection for GPIO INT1                                  */
      __IM  uint32_t            : 1;
      __IOM uint32_t int_deb_sel : 4;           /*!< [11..8] Debounce Output signal selection for GPIO INT1                    */
      __IM  uint32_t            : 3;
      __IOM uint32_t int_sur_sel : 1;           /*!< [15..15] 0: Useing pin input signal as interrupt signal source
                                                     1: Using debounce output signal as interrupt signal source                */
    } int1_sel_b;
  } ;
  
  union {
    __IOM uint32_t int2_sel;                    /*!< (@ 0x00000058) GPIO INT2 selection                                        */
    
    struct {
      __IOM uint32_t int_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for GPIO INT2                      */
      __IOM uint32_t int_gp_sel : 2;            /*!< [6..5] GPIO port selection for GPIO INT2                                  */
      __IM  uint32_t            : 1;
      __IOM uint32_t int_deb_sel : 4;           /*!< [11..8] Debounce Output signal selection for GPIO INT2                    */
      __IM  uint32_t            : 3;
      __IOM uint32_t int_sur_sel : 1;           /*!< [15..15] 0: Useing pin input signal as interrupt signal source
                                                     1: Using debounce output signal as interrupt signal source                */
    } int2_sel_b;
  } ;
  
  union {
    __IOM uint32_t int3_sel;                    /*!< (@ 0x0000005C) GPIO INT3 selection                                        */
    
    struct {
      __IOM uint32_t int_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for GPIO INT3                      */
      __IOM uint32_t int_gp_sel : 2;            /*!< [6..5] GPIO port selection for GPIO INT3                                  */
      __IM  uint32_t            : 1;
      __IOM uint32_t int_deb_sel : 4;           /*!< [11..8] Debounce Output signal selection for GPIO INT3                    */
      __IM  uint32_t            : 3;
      __IOM uint32_t int_sur_sel : 1;           /*!< [15..15] 0: Useing pin input signal as interrupt signal source
                                                     1: Using debounce output signal as interrupt signal source                */
    } int3_sel_b;
  } ;
  
  union {
    __IOM uint32_t int4_sel;                    /*!< (@ 0x00000060) GPIO INT4 selection                                        */
    
    struct {
      __IOM uint32_t int_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for GPIO INT4                      */
      __IOM uint32_t int_gp_sel : 2;            /*!< [6..5] GPIO port selection for GPIO INT4                                  */
      __IM  uint32_t            : 1;
      __IOM uint32_t int_deb_sel : 4;           /*!< [11..8] Debounce Output signal selection for GPIO INT4                    */
      __IM  uint32_t            : 3;
      __IOM uint32_t int_sur_sel : 1;           /*!< [15..15] 0: Useing pin input signal as interrupt signal source
                                                     1: Using debounce output signal as interrupt signal source                */
    } int4_sel_b;
  } ;
  
  union {
    __IOM uint32_t int5_sel;                    /*!< (@ 0x00000064) GPIO INT5 selection                                        */
    
    struct {
      __IOM uint32_t int_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for GPIO INT5                      */
      __IOM uint32_t int_gp_sel : 2;            /*!< [6..5] GPIO port selection for GPIO INT5                                  */
      __IM  uint32_t            : 1;
      __IOM uint32_t int_deb_sel : 4;           /*!< [11..8] Debounce Output signal selection for GPIO INT5                    */
      __IM  uint32_t            : 3;
      __IOM uint32_t int_sur_sel : 1;           /*!< [15..15] 0: Useing pin input signal as interrupt signal source
                                                     1: Using debounce output signal as interrupt signal source                */
    } int5_sel_b;
  } ;
  
  union {
    __IOM uint32_t int6_sel;                    /*!< (@ 0x00000068) GPIO INT6 selection                                        */
    
    struct {
      __IOM uint32_t int_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for GPIO INT6                      */
      __IOM uint32_t int_gp_sel : 2;            /*!< [6..5] GPIO port selection for GPIO INT6                                  */
      __IM  uint32_t            : 1;
      __IOM uint32_t int_deb_sel : 4;           /*!< [11..8] Debounce Output signal selection for GPIO INT6                    */
      __IM  uint32_t            : 3;
      __IOM uint32_t int_sur_sel : 1;           /*!< [15..15] 0: Useing pin input signal as interrupt signal source
                                                     1: Using debounce output signal as interrupt signal source                */
    } int6_sel_b;
  } ;
  
  union {
    __IOM uint32_t int7_sel;                    /*!< (@ 0x0000006C) GPIO INT7 selection                                        */
    
    struct {
      __IOM uint32_t int_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for GPIO INT7                      */
      __IOM uint32_t int_gp_sel : 2;            /*!< [6..5] GPIO port selection for GPIO INT7                                  */
      __IM  uint32_t            : 1;
      __IOM uint32_t int_deb_sel : 4;           /*!< [11..8] Debounce Output signal selection for GPIO INT7                    */
      __IM  uint32_t            : 3;
      __IOM uint32_t int_sur_sel : 1;           /*!< [15..15] 0: Useing pin input signal as interrupt signal source
                                                     1: Using debounce output signal as interrupt signal source                */
    } int7_sel_b;
  } ;
  
  union {
    __IOM uint32_t int8_sel;                    /*!< (@ 0x00000070) GPIO INT8 selection                                        */
    
    struct {
      __IOM uint32_t int_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for GPIO INT8                      */
      __IOM uint32_t int_gp_sel : 2;            /*!< [6..5] GPIO port selection for GPIO INT8                                  */
      __IM  uint32_t            : 1;
      __IOM uint32_t int_deb_sel : 4;           /*!< [11..8] Debounce Output signal selection for GPIO INT8                    */
      __IM  uint32_t            : 3;
      __IOM uint32_t int_sur_sel : 1;           /*!< [15..15] 0: Useing pin input signal as interrupt signal source
                                                     1: Using debounce output signal as interrupt signal source                */
    } int8_sel_b;
  } ;
  
  union {
    __IOM uint32_t int9_sel;                    /*!< (@ 0x00000074) GPIO INT9 selection                                        */
    
    struct {
      __IOM uint32_t int_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for GPIO INT9                      */
      __IOM uint32_t int_gp_sel : 2;            /*!< [6..5] GPIO port selection for GPIO INT9                                  */
      __IM  uint32_t            : 1;
      __IOM uint32_t int_deb_sel : 4;           /*!< [11..8] Debounce Output signal selection for GPIO INT9                    */
      __IM  uint32_t            : 3;
      __IOM uint32_t int_sur_sel : 1;           /*!< [15..15] 0: Useing pin input signal as interrupt signal source
                                                     1: Using debounce output signal as interrupt signal source                */
    } int9_sel_b;
  } ;
  
  union {
    __IOM uint32_t int10_sel;                   /*!< (@ 0x00000078) GPIO INT10 selection                                       */
    
    struct {
      __IOM uint32_t int_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for GPIO INT10                     */
      __IOM uint32_t int_gp_sel : 2;            /*!< [6..5] GPIO port selection for GPIO INT10                                 */
      __IM  uint32_t            : 1;
      __IOM uint32_t int_deb_sel : 4;           /*!< [11..8] Debounce Output signal selection for GPIO INT10                   */
      __IM  uint32_t            : 3;
      __IOM uint32_t int_sur_sel : 1;           /*!< [15..15] 0: Useing pin input signal as interrupt signal source
                                                     1: Using debounce output signal as interrupt signal source                */
    } int10_sel_b;
  } ;
  
  union {
    __IOM uint32_t int11_sel;                   /*!< (@ 0x0000007C) GPIO INT11 selection                                       */
    
    struct {
      __IOM uint32_t int_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for GPIO INT11                     */
      __IOM uint32_t int_gp_sel : 2;            /*!< [6..5] GPIO port selection for GPIO INT11                                 */
      __IM  uint32_t            : 1;
      __IOM uint32_t int_deb_sel : 4;           /*!< [11..8] Debounce Output signal selection for GPIO INT11                   */
      __IM  uint32_t            : 3;
      __IOM uint32_t int_sur_sel : 1;           /*!< [15..15] 0: Useing pin input signal as interrupt signal source
                                                     1: Using debounce output signal as interrupt signal source                */
    } int11_sel_b;
  } ;
  
  union {
    __IOM uint32_t int12_sel;                   /*!< (@ 0x00000080) GPIO INT12 selection                                       */
    
    struct {
      __IOM uint32_t int_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for GPIO INT12                     */
      __IOM uint32_t int_gp_sel : 2;            /*!< [6..5] GPIO port selection for GPIO INT12                                 */
      __IM  uint32_t            : 1;
      __IOM uint32_t int_deb_sel : 4;           /*!< [11..8] Debounce Output signal selection for GPIO INT12                   */
      __IM  uint32_t            : 3;
      __IOM uint32_t int_sur_sel : 1;           /*!< [15..15] 0: Useing pin input signal as interrupt signal source
                                                     1: Using debounce output signal as interrupt signal source                */
    } int12_sel_b;
  } ;
  
  union {
    __IOM uint32_t int13_sel;                   /*!< (@ 0x00000084) GPIO INT13 selection                                       */
    
    struct {
      __IOM uint32_t int_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for GPIO INT13                     */
      __IOM uint32_t int_gp_sel : 2;            /*!< [6..5] GPIO port selection for GPIO INT13                                 */
      __IM  uint32_t            : 1;
      __IOM uint32_t int_deb_sel : 4;           /*!< [11..8] Debounce Output signal selection for GPIO INT13                   */
      __IM  uint32_t            : 3;
      __IOM uint32_t int_sur_sel : 1;           /*!< [15..15] 0: Useing pin input signal as interrupt signal source
                                                     1: Using debounce output signal as interrupt signal source                */
    } int13_sel_b;
  } ;
  
  union {
    __IOM uint32_t int14_sel;                   /*!< (@ 0x00000088) GPIO INT14 selection                                       */
    
    struct {
      __IOM uint32_t int_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for GPIO INT14                     */
      __IOM uint32_t int_gp_sel : 2;            /*!< [6..5] GPIO port selection for GPIO INT14                                 */
      __IM  uint32_t            : 1;
      __IOM uint32_t int_deb_sel : 4;           /*!< [11..8] Debounce Output signal selection for GPIO INT14                   */
      __IM  uint32_t            : 3;
      __IOM uint32_t int_sur_sel : 1;           /*!< [15..15] 0: Useing pin input signal as interrupt signal source
                                                     1: Using debounce output signal as interrupt signal source                */
    } int14_sel_b;
  } ;
  
  union {
    __IOM uint32_t int15_sel;                   /*!< (@ 0x0000008C) GPIO INT15 selection                                       */
    
    struct {
      __IOM uint32_t int_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for GPIO INT15                     */
      __IOM uint32_t int_gp_sel : 2;            /*!< [6..5] GPIO port selection for GPIO INT15                                 */
      __IM  uint32_t            : 1;
      __IOM uint32_t int_deb_sel : 4;           /*!< [11..8] Debounce Output signal selection for GPIO INT15                   */
      __IM  uint32_t            : 3;
      __IOM uint32_t int_sur_sel : 1;           /*!< [15..15] 0: Useing pin input signal as interrupt signal source
                                                     1: Using debounce output signal as interrupt signal source                */
    } int15_sel_b;
  } ;
  __IM  uint32_t  RESERVED2[24];
  
  union {
    __IM  uint32_t deb_sts;                     /*!< (@ 0x000000F0) GPIO port debounce status                                  */
    
    struct {
      __IM  uint32_t deb_sts    : 16;           /*!< [15..0] For each bit: 0: the specific GPIO debounce pin is DISABLE
                                                     debounce 1: the specific GPIO debounce pin is ENABLE debounce             */
    } deb_sts_b;
  } ;
  
  union {
    __IOM uint32_t deb_en;                      /*!< (@ 0x000000F4) GPIO debounce pin enable                                   */
    
    struct {
      __IOM uint32_t deb_en     : 16;           /*!< [15..0] For each bit write: 0: No operation 1: the conrtolled
                                                     GPIO de-bouncing pin is enabled and also cause the specified
                                                     bit of REG_GPIO_DEB_STS to be read as ONE.                                */
    } deb_en_b;
  } ;
  
  union {
    __IOM uint32_t deb_dis;                     /*!< (@ 0x000000F8) GPIO debounce pin disable                                  */
    
    struct {
      __IOM uint32_t deb_dis    : 16;           /*!< [15..0] For each bit write: 0: No operation 1: the conrtolled
                                                     GPIO de-bouncing pin is disabled and also cause the specified
                                                     bit of REG_GPIO_DEB_STS to be read as ZERO.                               */
    } deb_dis_b;
  } ;
  
  union {
    __IM  uint32_t deb_dp_sts;                  /*!< (@ 0x000000FC) GPIO debounce data pin status                              */
    
    struct {
      __IM  uint32_t deb_dp_sts : 16;           /*!< [15..0] For each bit reading: read the signal level of the specified
                                                     pin after de-bounce                                                       */
    } deb_dp_sts_b;
  } ;
  
  union {
    __IOM uint32_t deb0_sel;                    /*!< (@ 0x00000100) GPIO debounce0 selection                                   */
    
    struct {
      __IOM uint32_t deb_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for debounce0                      */
      __IOM uint32_t deb_gp_sel : 2;            /*!< [6..5] GPIO port selection for debounce0                                  */
      __IM  uint32_t            : 1;
      __IOM uint32_t deb_cyc    : 14;           /*!< [21..8] The GPIO signal will be filtered by the number of debounce
                                                     cycles given in this field.                                               */
    } deb0_sel_b;
  } ;
  
  union {
    __IOM uint32_t deb1_sel;                    /*!< (@ 0x00000104) GPIO debounce1 selection                                   */
    
    struct {
      __IOM uint32_t deb_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for debounce1                      */
      __IOM uint32_t deb_gp_sel : 2;            /*!< [6..5] GPIO port selection for debounce1                                  */
      __IM  uint32_t            : 1;
      __IOM uint32_t deb_cyc    : 14;           /*!< [21..8] The GPIO signal will be filtered by the number of debounce
                                                     cycles given in this field.                                               */
    } deb1_sel_b;
  } ;
  
  union {
    __IOM uint32_t deb2_sel;                    /*!< (@ 0x00000108) GPIO debounce2 selection                                   */
    
    struct {
      __IOM uint32_t deb_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for debounce2                      */
      __IOM uint32_t deb_gp_sel : 2;            /*!< [6..5] GPIO port selection for debounce2                                  */
      __IM  uint32_t            : 1;
      __IOM uint32_t deb_cyc    : 14;           /*!< [21..8] The GPIO signal will be filtered by the number of debounce
                                                     cycles given in this field.                                               */
    } deb2_sel_b;
  } ;
  
  union {
    __IOM uint32_t deb3_sel;                    /*!< (@ 0x0000010C) GPIO debounce3 selection                                   */
    
    struct {
      __IOM uint32_t deb_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for debounce3                      */
      __IOM uint32_t deb_gp_sel : 2;            /*!< [6..5] GPIO port selection for debounce3                                  */
      __IM  uint32_t            : 1;
      __IOM uint32_t deb_cyc    : 14;           /*!< [21..8] The GPIO signal will be filtered by the number of debounce
                                                     cycles given in this field.                                               */
    } deb3_sel_b;
  } ;
  
  union {
    __IOM uint32_t deb4_sel;                    /*!< (@ 0x00000110) GPIO debounce4 selection                                   */
    
    struct {
      __IOM uint32_t deb_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for debounce4                      */
      __IOM uint32_t deb_gp_sel : 2;            /*!< [6..5] GPIO port selection for debounce4                                  */
      __IM  uint32_t            : 1;
      __IOM uint32_t deb_cyc    : 14;           /*!< [21..8] The GPIO signal will be filtered by the number of debounce
                                                     cycles given in this field.                                               */
    } deb4_sel_b;
  } ;
  
  union {
    __IOM uint32_t deb5_sel;                    /*!< (@ 0x00000114) GPIO debounce5 selection                                   */
    
    struct {
      __IOM uint32_t deb_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for debounce5                      */
      __IOM uint32_t deb_gp_sel : 2;            /*!< [6..5] GPIO port selection for debounce5                                  */
      __IM  uint32_t            : 1;
      __IOM uint32_t deb_cyc    : 14;           /*!< [21..8] The GPIO signal will be filtered by the number of debounce
                                                     cycles given in this field.                                               */
    } deb5_sel_b;
  } ;
  
  union {
    __IOM uint32_t deb6_sel;                    /*!< (@ 0x00000118) GPIO debounce6 selection                                   */
    
    struct {
      __IOM uint32_t deb_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for debounce6                      */
      __IOM uint32_t deb_gp_sel : 2;            /*!< [6..5] GPIO port selection for debounce6                                  */
      __IM  uint32_t            : 1;
      __IOM uint32_t deb_cyc    : 14;           /*!< [21..8] The GPIO signal will be filtered by the number of debounce
                                                     cycles given in this field.                                               */
    } deb6_sel_b;
  } ;
  
  union {
    __IOM uint32_t deb7_sel;                    /*!< (@ 0x0000011C) GPIO debounce7 selection                                   */
    
    struct {
      __IOM uint32_t deb_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for debounce7                      */
      __IOM uint32_t deb_gp_sel : 2;            /*!< [6..5] GPIO port selection for debounce7                                  */
      __IM  uint32_t            : 1;
      __IOM uint32_t deb_cyc    : 14;           /*!< [21..8] The GPIO signal will be filtered by the number of debounce
                                                     cycles given in this field.                                               */
    } deb7_sel_b;
  } ;
  
  union {
    __IOM uint32_t deb8_sel;                    /*!< (@ 0x00000120) GPIO debounce8 selection                                   */
    
    struct {
      __IOM uint32_t deb_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for debounce8                      */
      __IOM uint32_t deb_gp_sel : 2;            /*!< [6..5] GPIO port selection for debounce8                                  */
      __IM  uint32_t            : 1;
      __IOM uint32_t deb_cyc    : 14;           /*!< [21..8] The GPIO signal will be filtered by the number of debounce
                                                     cycles given in this field.                                               */
    } deb8_sel_b;
  } ;
  
  union {
    __IOM uint32_t deb9_sel;                    /*!< (@ 0x00000124) GPIO debounce9 selection                                   */
    
    struct {
      __IOM uint32_t deb_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for debounce9                      */
      __IOM uint32_t deb_gp_sel : 2;            /*!< [6..5] GPIO port selection for debounce9                                  */
      __IM  uint32_t            : 1;
      __IOM uint32_t deb_cyc    : 14;           /*!< [21..8] The GPIO signal will be filtered by the number of debounce
                                                     cycles given in this field.                                               */
    } deb9_sel_b;
  } ;
  
  union {
    __IOM uint32_t deb10_sel;                   /*!< (@ 0x00000128) GPIO debounce10 selection                                  */
    
    struct {
      __IOM uint32_t deb_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for debounce10                     */
      __IOM uint32_t deb_gp_sel : 2;            /*!< [6..5] GPIO port selection for debounce10                                 */
      __IM  uint32_t            : 1;
      __IOM uint32_t deb_cyc    : 14;           /*!< [21..8] The GPIO signal will be filtered by the number of debounce
                                                     cycles given in this field.                                               */
    } deb10_sel_b;
  } ;
  
  union {
    __IOM uint32_t deb11_sel;                   /*!< (@ 0x0000012C) GPIO debounce11 selection                                  */
    
    struct {
      __IOM uint32_t deb_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for debounce11                     */
      __IOM uint32_t deb_gp_sel : 2;            /*!< [6..5] GPIO port selection for debounce11                                 */
      __IM  uint32_t            : 1;
      __IOM uint32_t deb_cyc    : 14;           /*!< [21..8] The GPIO signal will be filtered by the number of debounce
                                                     cycles given in this field.                                               */
    } deb11_sel_b;
  } ;
  
  union {
    __IOM uint32_t deb12_sel;                   /*!< (@ 0x00000130) GPIO debounce12 selection                                  */
    
    struct {
      __IOM uint32_t deb_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for debounce12                     */
      __IOM uint32_t deb_gp_sel : 2;            /*!< [6..5] GPIO port selection for debounce12                                 */
      __IM  uint32_t            : 1;
      __IOM uint32_t deb_cyc    : 14;           /*!< [21..8] The GPIO signal will be filtered by the number of debounce
                                                     cycles given in this field.                                               */
    } deb12_sel_b;
  } ;
  
  union {
    __IOM uint32_t deb13_sel;                   /*!< (@ 0x00000134) GPIO debounce13 selection                                  */
    
    struct {
      __IOM uint32_t deb_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for debounce13                     */
      __IOM uint32_t deb_gp_sel : 2;            /*!< [6..5] GPIO port selection for debounce13                                 */
      __IM  uint32_t            : 1;
      __IOM uint32_t deb_cyc    : 14;           /*!< [21..8] The GPIO signal will be filtered by the number of debounce
                                                     cycles given in this field.                                               */
    } deb13_sel_b;
  } ;
  
  union {
    __IOM uint32_t deb14_sel;                   /*!< (@ 0x00000138) GPIO debounce14 selection                                  */
    
    struct {
      __IOM uint32_t deb_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for debounce14                     */
      __IOM uint32_t deb_gp_sel : 2;            /*!< [6..5] GPIO port selection for debounce14                                 */
      __IM  uint32_t            : 1;
      __IOM uint32_t deb_cyc    : 14;           /*!< [21..8] The GPIO signal will be filtered by the number of debounce
                                                     cycles given in this field.                                               */
    } deb14_sel_b;
  } ;
  
  union {
    __IOM uint32_t deb15_sel;                   /*!< (@ 0x0000013C) GPIO debounce15 selection                                  */
    
    struct {
      __IOM uint32_t deb_mer_sel : 5;           /*!< [4..0] Pin selection of specified port for debounce15                     */
      __IOM uint32_t deb_gp_sel : 2;            /*!< [6..5] GPIO port selection for debounce15                                 */
      __IM  uint32_t            : 1;
      __IOM uint32_t deb_cyc    : 14;           /*!< [21..8] The GPIO signal will be filtered by the number of debounce
                                                     cycles given in this field.                                               */
    } deb15_sel_b;
  } ;
  __IM  uint32_t  RESERVED3[48];
  
  union {
    __IM  uint32_t port_a_dmd_sts;              /*!< (@ 0x00000200) GPIO port A data mode direction status                     */
    
    struct {
      __IM  uint32_t dmd_sts    : 32;           /*!< [31..0] For each bit: 0: the specific GPIO pin is configured
                                                     to INPUT data mode 1: the specific GPIO pin is configured
                                                     to OUTPUT data mode                                                       */
    } port_a_dmd_sts_b;
  } ;
  
  union {
    __IOM uint32_t port_a_idm_en;               /*!< (@ 0x00000204) GPIO port A input data mode enable                         */
    
    struct {
      __IOM uint32_t idm_en     : 32;           /*!< [31..0] For each bit write: 0: the configuration of the conrtolled
                                                     GPIO pin is unchanged; 1: the conrtolled GPIO pin is configured
                                                     to input data mode and also cause the specified bit of
                                                     REG_PORT_A_DMD_STS to be read as zero.                                    */
    } port_a_idm_en_b;
  } ;
  
  union {
    __IOM uint32_t port_a_odm_en;               /*!< (@ 0x00000208) GPIO port A output data mode enable                        */
    
    struct {
      __IOM uint32_t odm_en     : 32;           /*!< [31..0] For each bit write: 0: the configuration of conrtolled
                                                     GPIO pin is unchanged; 1: the conrtolled GPIO pin is configured
                                                     as output data mode and also cause the specified bit of
                                                     REG_PORT_A_DMD_STS to be read as one                                      */
    } port_a_odm_en_b;
  } ;
  
  union {
    __IM  uint32_t port_a_od_sts;               /*!< (@ 0x0000020C) GPIO port A output data status                             */
    
    struct {
      __IM  uint32_t od_sts     : 32;           /*!< [31..0] For each bit: 0: the specified GPIO pin is configured
                                                     as output low 1: the specified GPIO pin is configured as
                                                     output high , if the specific GPIO pin is output data mode.               */
    } port_a_od_sts_b;
  } ;
  
  union {
    __IOM uint32_t port_a_odl_en;               /*!< (@ 0x00000210) GPIO port A output data low enable                         */
    
    struct {
      __IOM uint32_t odl_en     : 32;           /*!< [31..0] For each bit write: 0: No operation 1: the conrtolled
                                                     GPIO pin is configured as output low and also cause the
                                                     specified bit of REG_PORT_A_OD_STS is zero.                               */
    } port_a_odl_en_b;
  } ;
  
  union {
    __IOM uint32_t port_a_odh_en;               /*!< (@ 0x00000214) GPIO port A output data high enable                        */
    
    struct {
      __IOM uint32_t odh_en     : 32;           /*!< [31..0] For each bit write: 0: No operation 1: the conrtolled
                                                     GPIO pin is configured as output high and also cause the
                                                     specified bit of REG_PORT_A_OD_STS is one.                                */
    } port_a_odh_en_b;
  } ;
  
  union {
    __IOM uint32_t port_a_odt_en;               /*!< (@ 0x00000218) GPIO port A output data toggle enable                      */
    
    struct {
      __IOM uint32_t odt_en     : 32;           /*!< [31..0] For each bit write: 0: No operation 1: Toggle output
                                                     of the conrtolled GPIO pin and the specified bit of REG_PORT_A_OD_STS
                                                     also will be toggled.                                                     */
    } port_a_odt_en_b;
  } ;
  
  union {
    __IM  uint32_t port_a_dp_sts;               /*!< (@ 0x0000021C) GPIO port A data pin status                                */
    
    struct {
      __IM  uint32_t dp_sts     : 32;           /*!< [31..0] For each bit reading: If the direction of the specified
                                                     bit is input then read the signal level of the input pin.
                                                     If the direction of the specified bit is output then reads
                                                     the output data register for port A.                                      */
    } port_a_dp_sts_b;
  } ;
  __IM  uint32_t  RESERVED4[8];
  
  union {
    __IM  uint32_t port_b_dmd_sts;              /*!< (@ 0x00000240) GPIO port B data mode direction status                     */
    
    struct {
      __IM  uint32_t dmd_sts    : 32;           /*!< [31..0] For each bit: 0: the specific GPIO pin is configured
                                                     to INPUT data mode 1: the specific GPIO pin is configured
                                                     to OUTPUT data mode                                                       */
    } port_b_dmd_sts_b;
  } ;
  
  union {
    __IOM uint32_t port_b_idm_en;               /*!< (@ 0x00000244) GPIO port B input data mode enable                         */
    
    struct {
      __IOM uint32_t idm_en     : 32;           /*!< [31..0] For each bit write: 0: the configuration of the conrtolled
                                                     GPIO pin is unchanged; 1: the conrtolled GPIO pin is configured
                                                     to input data mode and also cause the specified bit of
                                                     REG_PORT_B_DMD_STS to be read as zero.                                    */
    } port_b_idm_en_b;
  } ;
  
  union {
    __IOM uint32_t port_b_odm_en;               /*!< (@ 0x00000248) GPIO port B output data mode enable                        */
    
    struct {
      __IOM uint32_t odm_en     : 32;           /*!< [31..0] For each bit write: 0: the configuration of the conrtolled
                                                     GPIO pin is unchanged; 1: the conrtolled GPIO pin is configured
                                                     as output data mode and also cause the specified bit of
                                                     REG_PORT_B_DMD_STS to be read as one                                      */
    } port_b_odm_en_b;
  } ;
  
  union {
    __IM  uint32_t port_b_od_sts;               /*!< (@ 0x0000024C) GPIO port B output data status                             */
    
    struct {
      __IM  uint32_t od_sts     : 32;           /*!< [31..0] For each bit: 0: the specified GPIO pin is configured
                                                     as output low 1: the specified GPIO pin is configured as
                                                     output high , if the specific GPIO pin is output data mode.               */
    } port_b_od_sts_b;
  } ;
  
  union {
    __IOM uint32_t port_b_odl_en;               /*!< (@ 0x00000250) GPIO port B output data low enable                         */
    
    struct {
      __IOM uint32_t odl_en     : 32;           /*!< [31..0] For each bit write: 0: No operation 1: the conrtolled
                                                     GPIO pin is configured as output low and also cause the
                                                     specified bit of REG_PORT_B_OD_STS is zero.                               */
    } port_b_odl_en_b;
  } ;
  
  union {
    __IOM uint32_t port_b_odh_en;               /*!< (@ 0x00000254) GPIO port B output data high enable                        */
    
    struct {
      __IOM uint32_t odh_en     : 32;           /*!< [31..0] For each bit write: 0: No operation 1: the conrtolled
                                                     GPIO pin is configured as output high and also cause the
                                                     specified bit of REG_PORT_B_OD_STS is one.                                */
    } port_b_odh_en_b;
  } ;
  
  union {
    __IOM uint32_t port_b_odt_en;               /*!< (@ 0x00000258) GPIO port B output data toggle enable                      */
    
    struct {
      __IOM uint32_t odt_en     : 32;           /*!< [31..0] For each bit write: 0: No operation 1: Toggle output
                                                     of the conrtolled GPIO pin and the specified bit of REG_PORT_B_OD_STS
                                                     also will be toggled.                                                     */
    } port_b_odt_en_b;
  } ;
  
  union {
    __IM  uint32_t port_b_dp_sts;               /*!< (@ 0x0000025C) GPIO port B data pin status                                */
    
    struct {
      __IM  uint32_t dp_sts     : 32;           /*!< [31..0] For each bit reading: If the direction of the specified
                                                     bit is input then read the signal level of the input pin.
                                                     If the direction of the specified bit is output then reads
                                                     the output data register for port B.                                      */
    } port_b_dp_sts_b;
  } ;
  __IM  uint32_t  RESERVED5[8];
  
  union {
    __IM  uint32_t port_c_dmd_sts;              /*!< (@ 0x00000280) GPIO port C data mode direction status                     */
    
    struct {
      __IM  uint32_t dmd_sts    : 32;           /*!< [31..0] For each bit: 0: the specific GPIO pin is configured
                                                     to INPUT data mode 1: the specific GPIO pin is configured
                                                     to OUTPUT data mode                                                       */
    } port_c_dmd_sts_b;
  } ;
  
  union {
    __IOM uint32_t port_c_idm_en;               /*!< (@ 0x00000284) GPIO port C input data mode enable                         */
    
    struct {
      __IOM uint32_t idm_en     : 32;           /*!< [31..0] For each bit write: 0: the configuration of the conrtolled
                                                     GPIO pin is unchanged; 1: the conrtolled GPIO pin is configured
                                                     to input data mode and also cause the specified bit of
                                                     REG_PORT_C_DMD_STS to be read as zero.                                    */
    } port_c_idm_en_b;
  } ;
  
  union {
    __IOM uint32_t port_c_odm_en;               /*!< (@ 0x00000288) GPIO port C output data mode enable                        */
    
    struct {
      __IOM uint32_t odm_en     : 32;           /*!< [31..0] For each bit write: 0: the configuration of the conrtolled
                                                     GPIO pin is unchanged; 1: the conrtolled GPIO pin is configured
                                                     as output data mode and also cause the specified bit of
                                                     REG_PORT_C_DMD_STS to be read as one                                      */
    } port_c_odm_en_b;
  } ;
  
  union {
    __IM  uint32_t port_c_od_sts;               /*!< (@ 0x0000028C) GPIO port C output data status                             */
    
    struct {
      __IM  uint32_t od_sts     : 32;           /*!< [31..0] For each bit: 0: the specified GPIO pin is configured
                                                     as output low 1: the specified GPIO pin is configured as
                                                     output high , if the specific GPIO pin is output data mode.               */
    } port_c_od_sts_b;
  } ;
  
  union {
    __IOM uint32_t port_c_odl_en;               /*!< (@ 0x00000290) GPIO port C output data low enable                         */
    
    struct {
      __IOM uint32_t odl_en     : 32;           /*!< [31..0] For each bit write: 0: No operation 1: the conrtolled
                                                     GPIO pin is configured as output low and also cause the
                                                     specified bit of REG_PORT_C_OD_STS is zero.                               */
    } port_c_odl_en_b;
  } ;
  
  union {
    __IOM uint32_t port_c_odh_en;               /*!< (@ 0x00000294) GPIO port C output data high enable                        */
    
    struct {
      __IOM uint32_t odh_en     : 32;           /*!< [31..0] For each bit write: 0: No operation 1: the conrtolled
                                                     GPIO pin is configured as output high and also cause the
                                                     specified bit of REG_PORT_C_OD_STS is one.                                */
    } port_c_odh_en_b;
  } ;
  
  union {
    __IOM uint32_t port_c_odt_en;               /*!< (@ 0x00000298) GPIO port C output data toggle enable                      */
    
    struct {
      __IOM uint32_t odt_en     : 32;           /*!< [31..0] For each bit write: 0: No operation 1: Toggle output
                                                     of the conrtolled GPIO pin and the specified bit of REG_PORT_C_OD_STS
                                                     also will be toggled.                                                     */
    } port_c_odt_en_b;
  } ;
  
  union {
    __IM  uint32_t port_c_dp_sts;               /*!< (@ 0x0000029C) GPIO port C data pin status                                */
    
    struct {
      __IM  uint32_t dp_sts     : 32;           /*!< [31..0] For each bit reading: If the direction of the specified
                                                     bit is input then read the signal level of the input pin.
                                                     If the direction of the specified bit is output then reads
                                                     the output data register for port C.                                      */
    } port_c_dp_sts_b;
  } ;
  __IM  uint32_t  RESERVED6[8];
  
  union {
    __IM  uint32_t port_d_dmd_sts;              /*!< (@ 0x000002C0) GPIO port D data mode direction status                     */
    
    struct {
      __IM  uint32_t dmd_sts    : 32;           /*!< [31..0] For each bit: 0: the specific GPIO pin is configured
                                                     to INPUT data mode 1: the specific GPIO pin is configured
                                                     to OUTPUT data mode                                                       */
    } port_d_dmd_sts_b;
  } ;
  
  union {
    __IOM uint32_t port_d_idm_en;               /*!< (@ 0x000002C4) GPIO port D input data mode enable                         */
    
    struct {
      __IOM uint32_t idm_en     : 32;           /*!< [31..0] For each bit write: 0: the configuration of the conrtolled
                                                     GPIO pin is unchanged; 1: the conrtolled GPIO pin is configured
                                                     to input data mode and also cause the specified bit of
                                                     REG_PORT_D_DMD_STS to be read as zero.                                    */
    } port_d_idm_en_b;
  } ;
  
  union {
    __IOM uint32_t port_d_odm_en;               /*!< (@ 0x000002C8) GPIO port D output data mode enable                        */
    
    struct {
      __IOM uint32_t odm_en     : 32;           /*!< [31..0] For each bit write: 0: the configuration of the conrtolled
                                                     GPIO pin is unchanged; 1: the conrtolled GPIO pin is configured
                                                     as output data mode and also cause the specified bit of
                                                     REG_PORT_D_DMD_STS to be read as one                                      */
    } port_d_odm_en_b;
  } ;
  
  union {
    __IM  uint32_t port_d_od_sts;               /*!< (@ 0x000002CC) GPIO port D output data status                             */
    
    struct {
      __IM  uint32_t od_sts     : 32;           /*!< [31..0] For each bit: 0: the specified GPIO pin is configured
                                                     as output low 1: the specified GPIO pin is configured as
                                                     output high , if the specific GPIO pin is output data mode.               */
    } port_d_od_sts_b;
  } ;
  
  union {
    __IOM uint32_t port_d_odl_en;               /*!< (@ 0x000002D0) GPIO port D output data low enable                         */
    
    struct {
      __IOM uint32_t odl_en     : 32;           /*!< [31..0] For each bit write: 0: No operation 1: the conrtolled
                                                     GPIO pin is configured as output low and also cause the
                                                     specified bit of REG_PORT_D_OD_STS is zero.                               */
    } port_d_odl_en_b;
  } ;
  
  union {
    __IOM uint32_t port_d_odh_en;               /*!< (@ 0x000002D4) GPIO port D output data high enable                        */
    
    struct {
      __IOM uint32_t odh_en     : 32;           /*!< [31..0] For each bit write: 0: No operation 1: the conrtolled
                                                     GPIO pin is configured as output high and also cause the
                                                     specified bit of REG_PORT_D_OD_STS is one.                                */
    } port_d_odh_en_b;
  } ;
  
  union {
    __IOM uint32_t port_d_odt_en;               /*!< (@ 0x000002D8) GPIO port D output data toggle enable                      */
    
    struct {
      __IOM uint32_t odt_en     : 32;           /*!< [31..0] For each bit write: 0: No operation 1: Toggle output
                                                     of the conrtolled GPIO pin and the specified bit of REG_PORT_D_OD_STS
                                                     also will be toggled.                                                     */
    } port_d_odt_en_b;
  } ;
  
  union {
    __IM  uint32_t port_d_dp_sts;               /*!< (@ 0x000002DC) GPIO port D data pin status                                */
    
    struct {
      __IM  uint32_t dp_sts     : 32;           /*!< [31..0] For each bit reading: If the direction of the specified
                                                     bit is input then read the signal level of the input pin.
                                                     If the direction of the specified bit is output then reads
                                                     the output data register for port D.                                      */
    } port_d_dp_sts_b;
  } ;
} GPIO_Type;                                    /*!< Size = 736 (0x2e0)                                                        */



/* =========================================================================================================================== */
/* ================                                            TG0                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief General Purpose Timer Group 0 Control (TG0)
  */

typedef struct {                                /*!< (@ 0x40003800) TG0 Structure                                              */
  
  union {
    __IM  uint32_t ists;                        /*!< (@ 0x00000000) Timer Group interrupt status register                      */
    
    struct {
      __IM  uint32_t ists       : 8;            /*!< [7..0] Each bit indicates the interrupt pending status of corresponding
                                                     timer: 0: the specifiied timer has no interrupt pending
                                                     1: the specifiied timer has pending interrupt                             */
    } ists_b;
  } ;
  
  union {
    __IM  uint32_t raw_ists;                    /*!< (@ 0x00000004) Timer Group raw interrupt status register                  */
    
    struct {
      __IM  uint32_t rists      : 8;            /*!< [7..0] Each bit indicates the interrupt pending status of corresponding
                                                     timer: 0: the specifiied timer has no interrupt pending
                                                     1: the specifiied timer has pending interrupt (pre-masing)                */
    } raw_ists_b;
  } ;
  
  union {
    __IOM uint32_t tsel;                        /*!< (@ 0x00000008) Timer Group indirect read control register                 */
    
    struct {
      __IOM uint32_t tsel       : 3;            /*!< [2..0] The timer index in a timer group, to select the timer
                                                     for indirect read.                                                        */
      __IM  uint32_t            : 1;
      __IOM uint32_t sync_mode  : 1;            /*!< [4..4] Sync mode between Timer clock and APB clock 0: Freq.
                                                     of APB clock >> Freq. of Timer clock (about 10 times) 1:
                                                     others                                                                    */
      __IM  uint32_t            : 2;
      __IOM uint32_t poll       : 1;            /*!< [7..7] Set this bit to enable indirect read current value of
                                                     timer selected by tsel. This bit is cleared by HW while
                                                     finishing read and indicate REG_TIMER_TC is ready                         */
    } tsel_b;
  } ;
  
  union {
    __IM  uint32_t tc;                          /*!< (@ 0x0000000C) Timer Group indirect read timer counter register           */
    
    struct {
      __IM  uint32_t timer_tc   : 32;           /*!< [31..0] Current counter value of the specifiied timer by register
                                                     tg_tsel.                                                                  */
    } tc_b;
  } ;
} TG0_Type;                                     /*!< Size = 16 (0x10)                                                          */



/* =========================================================================================================================== */
/* ================                                            TM0                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief General Purpose Timer0 (TM0)
  */

typedef struct {                                /*!< (@ 0x40002040) TM0 Structure                                              */
  
  union {
    __IOM uint32_t lc;                          /*!< (@ 0x00000000) Timer load count register                                  */
    
    struct {
      __IOM uint32_t lc         : 32;           /*!< [31..0] The counter value to be loaded into the timer counter
                                                     when timer is enabled or reset. Min = 0, when prescaler
                                                     register > 0; otherwise Min = 1.                                          */
    } lc_b;
  } ;
  
  union {
    __IOM uint32_t tc;                          /*!< (@ 0x00000004) Timer current counter register                             */
    
    struct {
      __IOM uint32_t tc         : 32;           /*!< [31..0] Current counter value.                                            */
    } tc_b;
  } ;
  
  union {
    __IOM uint32_t pc;                          /*!< (@ 0x00000008) Timer prescaler counter register                           */
    
    struct {
      __IOM uint32_t pc         : 10;           /*!< [9..0] Pre-scaler counter will be increased every clock after
                                                     timer is enabled. When the prescaler counter is equal to
                                                     PR, the next clock increments (decrements) the TC and clears
                                                     the PC.                                                                   */
    } pc_b;
  } ;
  
  union {
    __IOM uint32_t pr;                          /*!< (@ 0x0000000C) Timer prescaler register                                   */
    
    struct {
      __IOM uint32_t pr         : 10;           /*!< [9..0] When the PC is equal to this value, the next clock increments
                                                     (decrements) the TC and clears the PC.                                    */
    } pr_b;
  } ;
  
  union {
    __IOM uint32_t ctrl;                        /*!< (@ 0x00000010) Timer control register                                     */
    
    struct {
      __IOM uint32_t en         : 1;            /*!< [0..0] Timer enable control: 0: Disable 1: Enable                         */
      __IOM uint32_t mod        : 1;            /*!< [1..1] Timer operation mode: 0: timer mode (periodical mode);
                                                     it reloads LC to TC and repeat the process according to
                                                     the setting when the timeout event occurred. 1: counter
                                                     mode (one-shot mode); only one time process.                              */
      __IOM uint32_t imr        : 1;            /*!< [2..2] Timer Interrupt mask: 0: disable interrupt 1: enable
                                                     interrupt                                                                 */
      __IOM uint32_t cnt_mod    : 1;            /*!< [3..3] Timer counting mode: 0: Up-counter 1: Down-counter                 */
    } ctrl_b;
  } ;
  
  union {
    __IOM uint32_t isr;                         /*!< (@ 0x00000014) Timer0 interrupt status register                           */
    
    struct {
      __IOM uint32_t timeout    : 1;            /*!< [0..0] Timeout interrupt                                                  */
      __IOM uint32_t match_ev0  : 1;            /*!< [1..1] Counter value match event0 interrupt.                              */
      __IOM uint32_t match_ev1  : 1;            /*!< [2..2] Counter value match event1 interrupt.                              */
      __IOM uint32_t match_ev2  : 1;            /*!< [3..3] Counter value match event2 interrupt.                              */
      __IOM uint32_t match_ev3  : 1;            /*!< [4..4] Counter value match event3 interrupt.                              */
    } isr_b;
  } ;
  __IM  uint32_t  RESERVED;
  
  union {
    __IOM uint32_t mectrl;                      /*!< (@ 0x0000001C) Timer match event control register                         */
    
    struct {
      __IOM uint32_t me0_en     : 1;            /*!< [0..0] Counter value match event0 enable control: 0: Disable
                                                     1: Enable                                                                 */
      __IOM uint32_t me1_en     : 1;            /*!< [1..1] Counter value match event1 enable control: 0: Disable
                                                     1: Enable                                                                 */
      __IOM uint32_t me2_en     : 1;            /*!< [2..2] Counter value match event2 enable control: 0: Disable
                                                     1: Enable                                                                 */
      __IOM uint32_t me3_en     : 1;            /*!< [3..3] Counter value match event3 enable control: 0: Disable
                                                     1: Enable                                                                 */
    } mectrl_b;
  } ;
  
  union {
    __IOM uint32_t me0;                         /*!< (@ 0x00000020) Timer match event0 counter register                        */
    
    struct {
      __IOM uint32_t me0        : 32;           /*!< [31..0] Timer counter value for metch event0.                             */
    } me0_b;
  } ;
  
  union {
    __IOM uint32_t me1;                         /*!< (@ 0x00000024) Timer match event1 counter register                        */
    
    struct {
      __IOM uint32_t me1        : 32;           /*!< [31..0] Timer counter value for metch event1.                             */
    } me1_b;
  } ;
  
  union {
    __IOM uint32_t me2;                         /*!< (@ 0x00000028) Timer match event2 counter register                        */
    
    struct {
      __IOM uint32_t me2        : 32;           /*!< [31..0] Timer counter value for metch event2.                             */
    } me2_b;
  } ;
  
  union {
    __IOM uint32_t me3;                         /*!< (@ 0x0000002C) Timer match event3 counter register                        */
    
    struct {
      __IOM uint32_t me3        : 32;           /*!< [31..0] Timer counter value for metch event3.                             */
    } me3_b;
  } ;
} TM0_Type;                                     /*!< Size = 48 (0x30)                                                          */



/* =========================================================================================================================== */
/* ================                                         PWM_COMM                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief PWM Group Control (PWM_COMM)
  */

typedef struct {                                /*!< (@ 0x40001C00) PWM_COMM Structure                                         */
  
  union {
    __IM  uint32_t enable_status;               /*!< (@ 0x00000000) PWM enable status Register                                 */
    
    struct {
      __IM  uint32_t pwm_en_sts : 8;            /*!< [7..0] Each bit indicates the enabling status of corresponding
                                                     PWM: 0: the specific PWM is Disabled 1: the specific PWM
                                                     is Enabled                                                                */
    } enable_status_b;
  } ;
  
  union {
    __IOM uint32_t enable_ctrl;                 /*!< (@ 0x00000004) PWM enable Register                                        */
    
    struct {
      __IOM uint32_t pwm_en     : 8;            /*!< [7..0] Each bit is used to enablel the corresponding PWM function:
                                                     When wrote 0: No operation 1: the specific PWM is enabled
                                                     and the specific bit of REG_PWM_EN_STS is ONE.                            */
    } enable_ctrl_b;
  } ;
  
  union {
    __IOM uint32_t disable_ctrl;                /*!< (@ 0x00000008) PWM disable Register                                       */
    
    struct {
      __IOM uint32_t pwm_dis    : 8;            /*!< [7..0] Each bit is used to enablel the corresponding PWM function:
                                                     When wrote 0: No operation 1: the conrtolled PWM is disabled
                                                     and the specific bit of REG_PWM_EN_STS is ZERO.                           */
    } disable_ctrl_b;
  } ;
  
  union {
    __IOM uint32_t int_status;                  /*!< (@ 0x0000000C) Timer Group indirect read control register                 */
    
    struct {
      __IOM uint32_t duty_adj_dn_lim : 8;       /*!< [7..0] To indicate the interrupt pending status for PWM 0 ~
                                                     7 duty auto-adjustment reaches the down-limit. Write 1
                                                     clear. Bit 0 for PWM0, bit 1 for PWM1, ...bit7 for PWM7.                  */
      __IM  uint32_t            : 8;
      __IOM uint32_t duty_adj_up_lim : 8;       /*!< [23..16] To indicate the interrupt pending status for PWM 0
                                                     ~ 7 duty auto-adjustment reaches the up-limit. Write 1
                                                     clear. Bit 16 for PWM0, bit 17 for PWM1, ...bit23 for PWM7.               */
      __IOM uint32_t period_end : 8;            /*!< [31..24] To indicate the interrupt pending status for PWM 0
                                                     ~7 period end. Write 1 clear. Bit 24 for PWM0, bit 25 for
                                                     PWM1, ...bit31 for PWM7.                                                  */
    } int_status_b;
  } ;
  
  union {
    __IOM uint32_t indread_idx;                 /*!< (@ 0x00000010) PWM Index of Indirect Read Register                        */
    
    struct {
      __IOM uint32_t pwm_sel    : 3;            /*!< [2..0] This field is used to assign the PWM index (0 ~ 7) for
                                                     the auto adjusted duty size indirect reading.                             */
      __IM  uint32_t            : 1;
      __IOM uint32_t sync_mode  : 1;            /*!< [4..4] Register sync mode selection for PWM clock and APB clock
                                                     0: Freq. of APB clock >> Freq. of PWM clock (about 10 times)
                                                     1: Freq. of PWM clock >= Freq. of APB clock                               */
      __IM  uint32_t            : 2;
      __IOM uint32_t pool       : 1;            /*!< [7..7] Set this bit to enable indirect read current value of
                                                     timer selected by BIT_PWM_INDREAD_IDX. This bit is cleared
                                                     by HW when reading is finished and indicates REG_PERI_PWM_INDREAD_DUTY
                                                     is ready.                                                                 */
    } indread_idx_b;
  } ;
  
  union {
    __IOM uint32_t indread_duty;                /*!< (@ 0x00000014) PWM Auto Adjusted Duty Indirect Read Register              */
    
    struct {
      __IOM uint32_t pwm_duty   : 12;           /*!< [11..0] This field is used to read the auto adjusted duty size
                                                     of the PWM which is assigned by the pwm_sel. The SW should
                                                     assign the PWM to read by write the pwm_sel and then read
                                                     this field to get the current duty size of the specified
                                                     PWM.                                                                      */
    } indread_duty_b;
  } ;
} PWM_COMM_Type;                                /*!< Size = 24 (0x18)                                                          */



/* =========================================================================================================================== */
/* ================                                           PWM0                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Pulse Width Modulation 0 (PWM0)
  */

typedef struct {                                /*!< (@ 0x40001C20) PWM0 Structure                                             */
  
  union {
    __IOM uint32_t ctrl;                        /*!< (@ 0x00000000) PWM Control Register                                       */
    
    struct {
      __IOM uint32_t duty       : 12;           /*!< [11..0] The on-duty duration of PWM pulse. The time unit is
                                                     configured by the GTIMER which is specified by clk_sel
                                                     field. It can be written at any time, but HW will apply
                                                     the changing at PWM enable time or at the end of PWM period.              */
      __IOM uint32_t clk_sel    : 4;            /*!< [15..12] The tick source selection, G-timer 0 ~ 7 or SClk: 0:
                                                     GTIMER 0 1: GTIMER 1 ... 7: GTIMER 7 8: sclk                              */
      __IM  uint32_t cur_duty   : 12;           /*!< [27..16] The current duty size which is adjusted by the duty
                                                     auto-adjustment HW. The SW can read this field to know
                                                     the current duty size. However, the latest duty size may
                                                     not be sync to this field on time or the value may transition
                                                     while the SW is reading this field. So use in-direct read
                                                     method to read the duty size is more save and is suggested.               */
      __IOM uint32_t period_ie  : 1;            /*!< [28..28] This bit control the PWM period end interrupt enable
                                                     (1) or disable (0). When the PWM period end interrupt is
                                                     enabled, the PWM HW will assert the interrupt on every
                                                     PWM period end time. This interrupt status can be read
                                                     from pwm_int_status.                                                      */
      __IM  uint32_t run_sts    : 1;            /*!< [29..29] The PWM output running status: 0: PWM output is paused
                                                     1: the PWM output is running.                                             */
      __IOM uint32_t pause      : 1;            /*!< [30..30] The paus control: 0: Normal running 1: To pause the
                                                     PWM out at current PWM period end. Since the PWM output
                                                     is not stopped immediately, the software can poll the BIT_PERI_PWMx_RUNST
                                                     to know the PWM out is still running or is paused.                        */
      __IOM uint32_t ctrl_set   : 1;            /*!< [31..31] SW can change setting only at ctrl_set = 0, and set
                                                     ctrl_set = 1 after changing PWM Ctrl. HW will clear ctrl_set
                                                     bit after changing PWM Ctrl. PS. If this PWM is disabled
                                                     (PWMx_EN=0), the HW will not clear this bit. PS. if this
                                                     bit is asserted and the duty auto adjustment is enabled,
                                                     when the PWM is enabled the HW will updates its duty at
                                                     the 1st PWM period and then start the duty adjustment at
                                                     2nd PWM period.                                                           */
    } ctrl_b;
  } ;
  
  union {
    __IOM uint32_t timing_ctrl;                 /*!< (@ 0x00000004) PWM Timing Control Register                                */
    
    struct {
      __IOM uint32_t period     : 12;           /*!< [11..0] The period of PWM pulse. The time unit is configured
                                                     by the GTIMER which is specified by the clk_sel field.
                                                     It can be written at any time, but the HW will apply the
                                                     changing at PWM enable time or at the end of PWM period.                  */
      __IM  uint32_t            : 4;
      __IOM uint32_t duty_start : 12;           /*!< [27..16] The start of ON duration of PWM pulse in the period.
                                                     The time unit is the same as PWM period. It can be written
                                                     at any time, but HW change setting only at PWM enable and
                                                     the end of period.                                                        */
    } timing_ctrl_b;
  } ;
  
  union {
    __IOM uint32_t auto_adj_ctrl;               /*!< (@ 0x00000008) PWM Duty Auto Adjustment Control Register                  */
    
    struct {
      __IOM uint32_t duty_dec_step : 10;        /*!< [9..0] The Duty Decreasing Step size of the Duty Auto Adjustment.         */
      __IM  uint32_t            : 2;
      __IOM uint32_t duty_inc_step : 10;        /*!< [21..12] The Duty Increasing Step size of the Duty Auto Adjustment        */
      __IM  uint32_t            : 5;
      __IOM uint32_t duty_dn_lim_ie : 1;        /*!< [27..27] This bit is used to enable the Interrupt of the Duty
                                                     Auto Adjustment. 0: Disable 1: Enable If the Interrupt
                                                     is enabled, issue an interrupt when the Adjusted Duty reach
                                                     the Down Limit.                                                           */
      __IOM uint32_t duty_up_lim_ie : 1;        /*!< [28..28] This bit is used to enable the Interrupt of the Duty
                                                     Auto Adjustment. 0: Disable 1: Enable If the Interrupt
                                                     is enabled, issue an interrupt when the Adjusted Duty reach
                                                     the Up Limit.                                                             */
      __IOM uint32_t adj_loop_en : 1;           /*!< [29..29] This bit is used to enable the Duty Auto Adjustment
                                                     Loop mode. 0: Disable 1: Enable If the Loop Mode is enabled,
                                                     reverse the Duty Auto Adjustment direction when the adjusted
                                                     Duty reach the Up Limit or the Down Limit.                                */
      __IOM uint32_t adj_dir    : 1;            /*!< [30..30] This bit is used to set the Duty Ato Adjustment direction.
                                                     0: Decrease Duty 1: Increase Duty                                         */
      __IOM uint32_t adj_en     : 1;            /*!< [31..31] This bit is used to enable the Duty Ato Adjustment.
                                                     0: Disable 1: Enable PS. If this bit is 1, the duty of
                                                     the auto adjustment will override the duty setting in the
                                                     pwm_ctrl register.                                                        */
    } auto_adj_ctrl_b;
  } ;
  
  union {
    __IOM uint32_t auto_adj_limit;              /*!< (@ 0x0000000C) PWM Duty Auto Adjustment Limit Register                    */
    
    struct {
      __IOM uint32_t duty_adj_dn_lim : 12;      /*!< [11..0] The down limit (in ticks) of the duty period for the
                                                     duty ratio auto adjustment                                                */
      __IM  uint32_t            : 4;
      __IOM uint32_t duty_adj_up_lim : 12;      /*!< [27..16] The up limit of the duty period for the duty ratio
                                                     auto adjustment                                                           */
    } auto_adj_limit_b;
  } ;
  
  union {
    __IOM uint32_t auto_adj_cycle;              /*!< (@ 0x00000010) PWM Duty Auto Adjustment Cycle Count Register              */
    
    struct {
      __IOM uint32_t adj_cycles : 12;           /*!< [11..0] The Cycle Count of the Duty Auto Adjustment. The Duty
                                                     size will be increased/decreased with a step size every
                                                     Cycle Count of PWM period                                                 */
    } auto_adj_cycle_b;
  } ;
} PWM0_Type;                                    /*!< Size = 20 (0x14)                                                          */



/* =========================================================================================================================== */
/* ================                                          LPCRAM                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Low Pin Count PSRAM controller (LPCRAM)
  */

typedef struct {                                /*!< (@ 0x40600000) LPCRAM Structure                                           */
  
  union {
    __IOM uint32_t ccr;                         /*!< (@ 0x00000000) Configuration Control Register                             */
    
    struct {
      __IOM uint32_t init       : 1;            /*!< [0..0] Start to issue PSRAM initialization sequence. Write 0
                                                     : Disable PSRAM initialization function. Write 1 : Enable
                                                     PSRAM initialization function. Read 0 : PSRAM initialization
                                                     function is still active. Read 1 : PSRAM initialization
                                                     function is done (INIT_DONE).                                             */
      __IM  uint32_t            : 2;
      __IOM uint32_t dpin       : 1;            /*!< [3..3] start to set PSRAM command function Wrtie 0 : Not to
                                                     start PSRAM DPIN function. Wrtie 1 : Start to execute DPIN
                                                     function. Read 0 : DPIN function is still active. Read
                                                     1 : DPIN function to PSRAM is done (DPIN_DONE)                            */
      __IM  uint32_t            : 4;
      __IOM uint32_t flush_fifo : 1;            /*!< [8..8] Flush all FIFO in PSRAM_LPC_CTRL Write 0 : Not to flush
                                                     FIFO Write 1 : Start to flush FIFO Read 0 : Flushing FIFO
                                                     operation is done. Read 1 : It is sitll active to flush
                                                     FIFO.                                                                     */
      __IM  uint32_t            : 22;
      __IOM uint32_t cr_update  : 1;            /*!< [31..31] Update the internal timing control registers or Quick
                                                     INIT done.                                                                */
    } ccr_b;
  } ;
  __IM  uint32_t  RESERVED;
  
  union {
    __IOM uint32_t iocr0;                       /*!< (@ 0x00000008) IO Configuration Control Register 0                        */
    
    struct {
      __IOM uint32_t dfi_cs_wr_dly : 4;         /*!< [3..0] Setting the latency contrast between PHY read data enable
                                                     path latency and PHY command path latency. The smallest
                                                     value is 0                                                                */
      __IOM uint32_t dfi_cs_rd_dly : 4;         /*!< [7..4] Setting the latency contrast between PHY write data path
                                                     latency and PHY command path latency. The smallest value
                                                     is 0.                                                                     */
      __IM  uint32_t            : 4;
      __IOM uint32_t tphy_wrdata : 5;           /*!< [16..12] Setting the delay latency from DFI write command to
                                                     DFI write data. The smallest value is 1.                                  */
      __IM  uint32_t            : 2;
      __IOM uint32_t fix_tphy_lat : 1;          /*!< [19..19] PSRAM_LPC_CTRL uses TPHY_WRDATA or TPHY_RDDATA only.
                                                     0 : Disable 1 : Enable                                                    */
      __IOM uint32_t tphy_rddata_en : 5;        /*!< [24..20] Setting the delay latency from DFI read command to
                                                     dri_rddata_en signal. The smallest value is 1.                            */
      __IOM uint32_t dfi_path_dly : 5;          /*!< [29..25] Select which TPHY_WRDATA/TPHY RDDATA cycle to sample
                                                     dfi_latency_en (dfi_latency_en_mux), the value should be
                                                     no less than 2.                                                           */
    } iocr0_b;
  } ;
  
  union {
    __IOM uint32_t csr;                         /*!< (@ 0x0000000C) Controller Status Register                                 */
    
    struct {
      __IM  uint32_t            : 8;
      __IOM uint32_t mem_idle   : 1;            /*!< [8..8] Disable memory access state. Write to set memory access
                                                     idle state. 0 : Enable memory access state. 1 : Set memory
                                                     access idel state, disable memory access. Read to check
                                                     if memory access state is in idel. 0 : Access PSRAM is
                                                     allowed. 1 : Memory state is idle and user cannot access
                                                     PSRAM through data bus.                                                   */
      __IM  uint32_t            : 8;
      __IOM uint32_t dpin_mode  : 2;            /*!< [18..17] DPIN mode decode : 00 : DPIN read data mode 01 : DPIN
                                                     write data mode 01 DPIN write data mode with iocr0[19]
                                                     for register write                                                        */
    } csr_b;
  } ;
  
  union {
    __IOM uint32_t drr;                         /*!< (@ 0x00000010) Device Refresh Power Up Register                           */
    
    struct {
      __IOM uint32_t tcph       : 4;            /*!< [3..0] PSRAM CS# pin HIGH cycles between subsequent command.              */
      __IOM uint32_t tcem       : 11;           /*!< [14..4] Maximum average refresh commands delay cycles.                    */
      __IOM uint32_t tpu        : 7;            /*!< [21..15] For PSRAM initialization flow, it has to wait this
                                                     period until the first access.                                            */
    } drr_b;
  } ;
  __IM  uint32_t  RESERVED1[4];
  
  union {
    __IOM uint32_t cmd_dpin_ndge;               /*!< (@ 0x00000024) Device Cmd Addr Pin Register (Negative Edge)               */
    
    struct {
      __IOM uint32_t addr       : 24;           /*!< [23..0] ADDR = {CA[39:32], CA[23:16], CA[7:0]}                            */
    } cmd_dpin_ndge_b;
  } ;
  
  union {
    __IOM uint32_t cmd_dpin;                    /*!< (@ 0x00000028) Device Cmd Addr Pin Register (Positive Edge)               */
    
    struct {
      __IOM uint32_t addr       : 24;           /*!< [23..0] ADDR = {CA[47:40], CA[31:24], CA[15:8]}                           */
    } cmd_dpin_b;
  } ;
  
  union {
    __IOM uint32_t cr_tdpin;                    /*!< (@ 0x0000002C) Tie DPIN Register                                          */
    
    struct {
      __IOM uint32_t dfi_reset_n : 1;           /*!< [0..0] This is tie-dpin function. Software can use this bit
                                                     to control dfi_reset_n to active or inactive. 1 : dfi_reset_n
                                                     inactive. 0 : dfi_reset_n active.                                         */
    } cr_tdpin_b;
  } ;
  
  union {
    __IOM uint32_t mr_info;                     /*!< (@ 0x00000030) Mode Latency Information Register                          */
    
    struct {
      __IOM uint32_t wl         : 5;            /*!< [4..0] Indicate PSRAM write latency counter. Refer to PSRAM
                                                     spec CR0 register altency counter field.                                  */
      __IOM uint32_t rl         : 5;            /*!< [9..5] Indicate PSRAM read latency counter. Refer to PSRAM spec
                                                     CR0 register altency counter field.                                       */
    } mr_info_b;
  } ;
  
  union {
    __IOM uint32_t mr0;                         /*!< (@ 0x00000034) Device CR0 Register                                        */
    
    struct {
      __IOM uint32_t burst_length : 2;          /*!< [1..0] Burst length per transaction. 00 : 128 bytes 01 : 64
                                                     bytes 10 : 16 bytes 11 : 32 bytes                                         */
      __IOM uint32_t burst_type : 1;            /*!< [2..2] Wrapped burst sequences in legacy wrapped burst manner             */
      __IOM uint32_t fixed_latency_en : 1;      /*!< [3..3] Latency mode control. 0 : variable initial latency, 1
                                                     or 2 times initial latency depending on RWDS during CA
                                                     cycles. 1 : fixed 2 times initial latency.                                */
      __IOM uint32_t ini_latency : 4;           /*!< [7..4] Initial Latency Count. 0000 : 5 clocks latency 0001 :
                                                     6 clocks latency 1110 : 3 clocks latency 1111 : 4 clocks
                                                     latency                                                                   */
      __IM  uint32_t            : 4;
      __IOM uint32_t drive_strength : 3;        /*!< [14..12] 000 : 50 ohms 001 : 35 ohms 010 : 100 ohms 011 : 200
                                                     ohms                                                                      */
      __IOM uint32_t deep_power_down_en : 1;    /*!< [15..15] Enable Deep Power Down mode. 0 : Enter Deep Power Down
                                                     mode. 1 : Normal operation.                                               */
    } mr0_b;
  } ;
  
  union {
    __IOM uint32_t mr1;                         /*!< (@ 0x00000038) Device CR1 Register                                        */
    
    struct {
      __IOM uint32_t pasr       : 3;            /*!< [2..0] Partial array self refresh. 000 : full array 001 : bottom
                                                     1/2 array 010 : bottom 1/4 array 011 : bottom 1/8 array
                                                     100 : none 101 : top 1/2 array 110 : top 1/4 array 111
                                                     : top 1/8 array                                                           */
      __IM  uint32_t            : 2;
      __IOM uint32_t hybrid_sleep_en : 1;       /*!< [5..5] Enter Hybird Sleep mode control. 0 : not in hybrid sleep
                                                     mode. 1 : entering hybrid sleep mode.                                     */
      __IOM uint32_t refresh_rate : 1;          /*!< [6..6] Refresh Multiplier Indicator. 0 : refresh the internal
                                                     cell array using faster rate. 1 : refresh the internal
                                                     cell array using normal rate.                                             */
    } mr1_b;
  } ;
  __IM  uint32_t  RESERVED2[9];
  
  union {
    __IOM uint32_t dpdri;                       /*!< (@ 0x00000060) DPIN Data Index Register                                   */
    
    struct {
      __IOM uint32_t dpin_data_index : 4;       /*!< [3..0] Indicate select which DPIN DATA register. Index 0~3 :
                                                     dpin read data. Index 4~7 : dpin write data. Index 8 :
                                                     dpin write data byteen.                                                   */
    } dpdri_b;
  } ;
  
  union {
    __IOM uint32_t dpdr;                        /*!< (@ 0x00000064) DPIN Data Register                                         */
    
    struct {
      __IOM uint32_t dpin_data  : 32;           /*!< [31..0] Indicate the data which will be written to PSRAM or
                                                     the data read from PSRAM.                                                 */
    } dpdr_b;
  } ;
  __IM  uint32_t  RESERVED3[35];
  
  union {
    __IM  uint32_t pctl_svn_id;                 /*!< (@ 0x000000F4) PSRAM_LPC_CTRL Version Numbers                             */
    
    struct {
      __IM  uint32_t release_date : 16;         /*!< [15..0] Indicate PSRAM Controller released date.                          */
      __IM  uint32_t git_cnt    : 16;           /*!< [31..16] Indicate the Git counter of the released date.                   */
    } pctl_svn_id_b;
  } ;
  
  union {
    __IM  uint32_t pctl_idr;                    /*!< (@ 0x000000F8) PSRAM_LPC_CTRL Identification Register                     */
    
    struct {
      __IM  uint32_t cr_pctl_def : 16;          /*!< [15..0] Main support PSRAM type.                                          */
      __IM  uint32_t cr_ver     : 16;           /*!< [31..16] The control register version number.                             */
    } pctl_idr_b;
  } ;
  __IM  uint32_t  RESERVED4[193];
  
  union {
    __IOM uint32_t user0_index;                 /*!< (@ 0x00000400) User Extended Index                                        */
    
    struct {
      __IOM uint32_t index_map_addr : 32;       /*!< [31..0] The address index of the indirect access register.                */
    } user0_index_b;
  } ;
  
  union {
    __IOM uint32_t user0_data;                  /*!< (@ 0x00000404) User Extended Data                                         */
    
    struct {
      __IOM uint32_t data_map_addr : 32;        /*!< [31..0] The data to be written to the indirect access register.           */
    } user0_data_b;
  } ;
} LPCRAM_Type;                                  /*!< Size = 1032 (0x408)                                                       */



/* =========================================================================================================================== */
/* ================                                           SPIC                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief SPI Controller to control 4IO & 8IO DTR Flash (SPIC)
  */

typedef struct {                                /*!< (@ 0x40020000) SPIC Structure                                             */
  
  union {
    __IOM uint32_t ctrlr0;                      /*!< (@ 0x00000000) SPIC Control Register 0                                    */
    
    struct {
      __IM  uint32_t            : 6;
      __IOM uint32_t scph       : 1;            /*!< [6..6] Serial Clock Phase.                                                */
      __IOM uint32_t scpol      : 1;            /*!< [7..7] Serial Clock Polarity.                                             */
      __IOM uint32_t tmod       : 2;            /*!< [9..8] Transfer mode.                                                     */
      __IM  uint32_t            : 6;
      __IOM uint32_t addr_ch    : 2;            /*!< [17..16] Indicate channel number of address phase in transmitting
                                                     or receiving data. Data phase is used to send data after
                                                     address phase. 0 : single channel, 1 : dual channels, 2
                                                     : quad channels, 3 : octal channel.                                       */
      __IOM uint32_t data_ch    : 2;            /*!< [19..18] Indicate channel number of data phase in transmitting
                                                     or receiving data. Data phase is used to send data after
                                                     address phase. 0 : single channel, 1 : dual channels, 2
                                                     : quad channels, 3 : octal channel.                                       */
      __IOM uint32_t cmd_ch     : 2;            /*!< [21..20] Indicate channel number of command phase in transmitting
                                                     or receiving data. Data phase is used to send data after
                                                     address phase. 0 : single channel, 1 : dual channels, 2
                                                     : quad channels, 3 : octal channel.                                       */
      __IOM uint32_t fast_rd    : 1;            /*!< [22..22] Indicate to use fast read command in user mode. If
                                                     setting to 1, SPIC would use FBAUDR to derive spi_sclk.                   */
      __IOM uint32_t ck_mtimes  : 5;            /*!< [27..23] Indicate the check time.                                         */
      __IOM uint32_t addr_ddr_en : 1;           /*!< [28..28] Enable address phase ddr mode.                                   */
      __IOM uint32_t data_ddr_en : 1;           /*!< [29..29] Enable data phase ddr mode.                                      */
      __IOM uint32_t cmd_ddr_en : 1;            /*!< [30..30] Enable command phase ddr mode. Always 2-byte command
                                                     type.                                                                     */
    } ctrlr0_b;
  } ;
  
  union {
    __IOM uint32_t ctrlr1;                      /*!< (@ 0x00000004) SPIC Control Register 1                                    */
    
    struct {
      __IOM uint32_t ndf        : 12;           /*!< [11..0] ndf                                                               */
    } ctrlr1_b;
  } ;
  
  union {
    __IOM uint32_t ssienr;                      /*!< (@ 0x00000008) SPIC Enable Register                                       */
    
    struct {
      __IOM uint32_t spic_en    : 1;            /*!< [0..0] Enable or disable SPIC.                                            */
      __OM  uint32_t atck_cmd   : 1;            /*!< [1..1] Set to enable ATCK_CMD implementation. After this bit
                                                     is set, SPIC would not accept any command until checking
                                                     flash is not busy or timeout.                                             */
    } ssienr_b;
  } ;
  __IM  uint32_t  RESERVED;
  
  union {
    __IOM uint32_t ser;                         /*!< (@ 0x00000010) Slave Enable Register                                      */
    
    struct {
      __IOM uint32_t ser        : 1;            /*!< [0..0] SPIC only has one slave select line. This bit should
                                                     be always set.                                                            */
    } ser_b;
  } ;
  
  union {
    __IOM uint32_t baudr;                       /*!< (@ 0x00000014) Baud Rate Select Register                                  */
    
    struct {
      __IOM uint32_t sckdv      : 12;           /*!< [11..0] This register controls the frequency of spi_sclk. spi_sclk
                                                     = frequency of bus_clk / (2*sckdv)                                        */
    } baudr_b;
  } ;
  
  union {
    __IOM uint32_t txftlr;                      /*!< (@ 0x00000018) Transmit FIFO Threshold Level                              */
    
    struct {
      __IOM uint32_t tft        : 8;            /*!< [7..0] Transmit FIFO Threshold. Controls the level of entries
                                                     (or below) at which the transmit FIFO controller triggers
                                                     an interrupt.                                                             */
    } txftlr_b;
  } ;
  
  union {
    __IOM uint32_t rxftlr;                      /*!< (@ 0x0000001C) Receive FIFO Threshold Level                               */
    
    struct {
      __IOM uint32_t rft        : 8;            /*!< [7..0] Receive FIFO Threshold. Controls the level of entries
                                                     (or above) at which the receive FIFO controller triggers
                                                     an interrupt.                                                             */
    } rxftlr_b;
  } ;
  
  union {
    __IM  uint32_t txflr;                       /*!< (@ 0x00000020) Transmit FIFO Level Register                               */
    
    struct {
      __IM  uint32_t txtfl      : 8;            /*!< [7..0] Transmit FIFO Level. Contains the number of valid data
                                                     entries in the transmit FIFO.                                             */
    } txflr_b;
  } ;
  
  union {
    __IM  uint32_t rxflr;                       /*!< (@ 0x00000024) Receive FIFO Level Register                                */
    
    struct {
      __IM  uint32_t rxtfl      : 8;            /*!< [7..0] Receive FIFO Level. Contains the number of valid data
                                                     entries in the receive FIFO.                                              */
    } rxflr_b;
  } ;
  
  union {
    __IM  uint32_t sr;                          /*!< (@ 0x00000028) Status Register                                            */
    
    struct {
      __IM  uint32_t busy       : 1;            /*!< [0..0] SPIC Busy Flag. When set, indicates that a serial transfer
                                                     is in progress; when cleared indicates that the SPIC is
                                                     idle or disabled.                                                         */
      __IM  uint32_t tfnf       : 1;            /*!< [1..1] Transmit FIFO Not Full. Set when the transmit FIFO contains
                                                     one or more empty locations, and is cleared when the FIFO
                                                     is full. 0 : Transmit FIFO is full 1 : Transmit FIFO is
                                                     not full                                                                  */
      __IM  uint32_t tfe        : 1;            /*!< [2..2] Transmit FIFO Empty. When the transmit FIFO is completely
                                                     empty, this bit is set. When the transmit FIFO contains
                                                     one or more valid entries, this bit is cleared. This bit
                                                     field does not request an interrupt. 0 : Transmit FIFO
                                                     is not empty 1 : Transmit FIFO is empty                                   */
      __IM  uint32_t rfne       : 1;            /*!< [3..3] Receive FIFO Not Empty. Set when the receive FIFO contains
                                                     one or more entries and is cleared when the receive FIFO
                                                     is empty. This bit can be polled by software to completely
                                                     empty the receive FIFO. 0 : Receive FIFO is empty 1 : Receive
                                                     FIFO is not empty                                                         */
      __IM  uint32_t rff        : 1;            /*!< [4..4] Receive FIFO Full. When the receive FIFO is completely
                                                     full, this bit is set. When the receive FIFO contains one
                                                     or more empty location, this bit is cleared. 0 : Receive
                                                     FIFO is not full 1 : Receive FIFO is full                                 */
      __IM  uint32_t txe        : 1;            /*!< [5..5] Transmission Error. Set if the transmit FIFO is empty
                                                     when a transfer is started. This bit can be set only when
                                                     the DW_apb_ssi is configured as a slave device. Data from
                                                     the previous transmission is resent on the txd line. This
                                                     bit is cleared when read. 0 : No error 1 : Transmission
                                                     error                                                                     */
      __IM  uint32_t dcol       : 1;            /*!< [6..6] Transmitting Status. This bit is set when SPIC is transmitting
                                                     command, address or data to the data register. By observing
                                                     this bit, users can avoid reading wrong data at the wrong
                                                     time if data is not ready to be read.                                     */
    } sr_b;
  } ;
  
  union {
    __IOM uint32_t imr;                         /*!< (@ 0x0000002C) Interrupt Mask Register                                    */
    
    struct {
      __IOM uint32_t txeim      : 1;            /*!< [0..0] Transmit FIFO Empty Interrupt Mask 0 : spi_txeir_r interrupt
                                                     is masked 1 : spi_txeir_r interrupt is not masked                         */
      __IOM uint32_t txoim      : 1;            /*!< [1..1] Transmit FIFO Overflow Interrupt Mask 0 : spi_txoir_r
                                                     interrupt is masked 1 : spi_txoir_r interrupt is not masked               */
      __IOM uint32_t rxuim      : 1;            /*!< [2..2] Receive FIFO Underflow Interrupt Mask 0 : spi_rxuir_r
                                                     interrupt is masked 1 : spi_rxuir_r interrupt is not masked               */
      __IOM uint32_t rxoim      : 1;            /*!< [3..3] Receive FIFO Overflow Interrupt Mask 0 : spi_rxoir_r
                                                     interrupt is masked 1 : spi_rxoir_r interrupt is not masked               */
      __IOM uint32_t rxfim      : 1;            /*!< [4..4] Receive FIFO Full Interrupt Mask 0 : spi_rxfir_r interrupt
                                                     is masked 1 : spi_rxfir_r interrupt is not masked                         */
      __IOM uint32_t fseim      : 1;            /*!< [5..5] FIFO Size Error Interrupt Mask. 0 : spi_fseir_r interrupt
                                                     is masked 1 : spi_fseir_r interrupt is not masked                         */
      __IOM uint32_t wbeim      : 1;            /*!< [6..6] Write Burst Error Interrupt Mask. 0 : spi_wbier_r interrupt
                                                     is masked 1 : spi_wbier_r interrupt is not masked                         */
      __IOM uint32_t byeim      : 1;            /*!< [7..7] Byte Enable Error Interrupt Mask 0 : spi_byeir_r interrupt
                                                     is masked 1 : spi_byeir_r interrupt is not masked                         */
      __IOM uint32_t aceim      : 1;            /*!< [8..8] Auto-check Timeout Error Interrupt Mask. 0 : spi_aceir_r
                                                     interrupt is masked 1 : spi_aceir_r interrupt is not masked               */
      __IOM uint32_t txsim      : 1;            /*!< [9..9] Transmit Split Interrupt Mask. 0 : spi_tx_sir_r interrupt
                                                     is masked 1 : spi_tx_sir_r interrupt is not masked                        */
    } imr_b;
  } ;
  
  union {
    __IM  uint32_t isr;                         /*!< (@ 0x00000030) Interrupt Status Register                                  */
    
    struct {
      __IM  uint32_t txeis      : 1;            /*!< [0..0] Transmit FIFO Empty Interrupt Status after Masking 0
                                                     : spi_txeir_r interrupt is not active after masking 1 :
                                                     spi_txeir_r interrupt is active after masking                             */
      __IM  uint32_t txois      : 1;            /*!< [1..1] Transmit FIFO Overflow Interrupt Status after Masking
                                                     0 : spi_txoir_r interrupt is not active after masking 1
                                                     : spi_txoir_r interrupt is active after masking                           */
      __IM  uint32_t rxuis      : 1;            /*!< [2..2] Receive FIFO Underflow Interrupt Status after Masking
                                                     0 : spi_rxuir_r interrupt is not active after masking 1
                                                     : spi_rxuir_r interrupt is active after masking                           */
      __IM  uint32_t rxois      : 1;            /*!< [3..3] Receive FIFO Overflow Interrupt Status after Masking
                                                     0 : spi_rxoir_r interrupt is not active after masking 1
                                                     : spi_rxoir_r interrupt is active after masking                           */
      __IM  uint32_t rxfis      : 1;            /*!< [4..4] Receive FIFO Full Interrupt Status after Masking 0 :
                                                     spi_rxfir_r interrupt is not active after masking 1 : spi_rxfir_r
                                                     interrupt is active after masking                                         */
      __IM  uint32_t fseis      : 1;            /*!< [5..5] FIFO Size Error Interrupt Status after Masking. 0 : spi_fseir_r
                                                     interrupt is not active after masking 1 : spi_fseir_r interrupt
                                                     is active after masking                                                   */
      __IM  uint32_t wbeis      : 1;            /*!< [6..6] Write Burst Error Interrupt Status after Masking. 0 :
                                                     spi_wbier_r interrupt is not active after masking 1 : spi_wbier_r
                                                     interrupt is active after masking                                         */
      __IM  uint32_t byeis      : 1;            /*!< [7..7] Byte Enable Error Interrupt Status after Masking 0 :
                                                     spi_byeir_r interrupt is not active after masking 1 : spi_byeir_r
                                                     interrupt is active after masking                                         */
      __IM  uint32_t aceis      : 1;            /*!< [8..8] Auto-check Timeout Error Interrupt Status after Masking.
                                                     0 : spi_aceir_r interrupt is not active after masking 1
                                                     : spi_aceir_r interrupt is active after masking                           */
      __IM  uint32_t txsis      : 1;            /*!< [9..9] Transmit Split Interrupt Status after Masking. 0 : spi_tx_sir_r
                                                     interrupt is not active after masking 1 : spi_tx_sir_r
                                                     interrupt is active after masking                                         */
      __IM  uint32_t rxsis      : 1;            /*!< [10..10] Receive Split Interrupt Status after Masking. 0 : spi_rx_sir_r
                                                     interrupt is not active after masking 1 : spi_rx_sir_r
                                                     interrupt is active after masking                                         */
    } isr_b;
  } ;
  
  union {
    __IM  uint32_t risr;                        /*!< (@ 0x00000034) Raw Interrupt Status Register                              */
    
    struct {
      __IM  uint32_t txeir      : 1;            /*!< [0..0] Transmit FIFO Empty Interrupt Raw Status before Masking
                                                     0 : spi_txeir_r interrupt is not acitve before masking
                                                     1 : spi_txeir_r interrupt is acitve before masking                        */
      __IM  uint32_t txoir      : 1;            /*!< [1..1] Transmit FIFO Overflow Interrupt Raw Status before Masking
                                                     0 : spi_txoir_r interrupt is not acitve before masking
                                                     1 : spi_txoir_r interrupt is acitve before masking                        */
      __IM  uint32_t rxuir      : 1;            /*!< [2..2] Receive FIFO Underflow Interrupt Raw Status before Masking
                                                     0 : spi_rxuir_r interrupt is not acitve before masking
                                                     1 : spi_rxuir_r interrupt is acitve before masking                        */
      __IM  uint32_t rxoir      : 1;            /*!< [3..3] Receive FIFO Overflow Interrupt Raw Status before Masking
                                                     0 : spi_rxoir_r interrupt is not acitve before masking
                                                     1 : spi_rxoir_r interrupt is acitve before masking                        */
      __IM  uint32_t rxfir      : 1;            /*!< [4..4] Receive FIFO Full Interrupt Raw Status before Masking
                                                     0 : spi_rxfir_r interrupt is not acitve before masking
                                                     1 : spi_rxfir_r interrupt is acitve before masking                        */
      __IM  uint32_t fseir      : 1;            /*!< [5..5] FIFO Size Error Interrupt Raw Status before Masking.
                                                     0 : spi_fseir_r interrupt is not acitve before masking
                                                     1 : spi_fseir_r interrupt is acitve before masking                        */
      __IM  uint32_t wbeir      : 1;            /*!< [6..6] Write Burst Error Interrupt Raw Status before Masking.
                                                     0 : spi_wbier_r interrupt is not acitve before masking
                                                     1 : spi_wbier_r interrupt is acitve before masking                        */
      __IM  uint32_t byeir      : 1;            /*!< [7..7] Byte Enable Error Interrupt Raw Status before Masking
                                                     0 : spi_byeir_r interrupt is not acitve before masking
                                                     1 : spi_byeir_r interrupt is acitve before masking                        */
      __IM  uint32_t aceir      : 1;            /*!< [8..8] Auto-check Timeout Error Interrupt Raw Status before
                                                     Masking. 0 : spi_aceir_r interrupt is not acitve before
                                                     masking 1 : spi_aceir_r interrupt is acitve before masking                */
    } risr_b;
  } ;
  
  union {
    __IM  uint32_t txoicr;                      /*!< (@ 0x00000038) Transmit FIFO Overflow Interrupt Clear Register            */
    
    struct {
      __IM  uint32_t txoicr     : 1;            /*!< [0..0] Clear Transmit FIFO Overflow Interrupt. This register
                                                     reflects the status of the interrupt. A read from this
                                                     register clears the ssi_txo_intr interrupt; writing has
                                                     no effect.                                                                */
    } txoicr_b;
  } ;
  
  union {
    __IM  uint32_t rxoicr;                      /*!< (@ 0x0000003C) Receive FIFO Overflow Interrupt Clear Register             */
    
    struct {
      __IM  uint32_t rxoicr     : 1;            /*!< [0..0] Clear Receive FIFO Overflow Interrupt. This register
                                                     reflects the status of the interrupt. A read from this
                                                     register clears the ssi_rxo_intr interrupt; writing has
                                                     no effect.                                                                */
    } rxoicr_b;
  } ;
  
  union {
    __IM  uint32_t rxuicr;                      /*!< (@ 0x00000040) Receive FIFO Underflow Interrupt Clear Register            */
    
    struct {
      __IM  uint32_t rxuicr     : 1;            /*!< [0..0] Clear Receive FIFO Underflow Interrupt. This register
                                                     reflects the status of the interrupt. A read from this
                                                     register clears the ssi_rxu_intr interrupt; writing has
                                                     no effect.                                                                */
    } rxuicr_b;
  } ;
  
  union {
    __IM  uint32_t faeicr;                      /*!< (@ 0x00000044) Frame Alignment Interrupt Clear Register                   */
    
    struct {
      __IM  uint32_t faeicr     : 1;            /*!< [0..0] Clear Frame Alignment Interrupt. This register reflects
                                                     the status of the interrupt. A read from this register
                                                     clears the ssi_fae_intr interrupt; writing has no effect.                 */
    } faeicr_b;
  } ;
  
  union {
    __IM  uint32_t icr;                         /*!< (@ 0x00000048) Interrupt Clear Register                                   */
    
    struct {
      __IM  uint32_t icr        : 1;            /*!< [0..0] Clear Interrupts. This register is set if any of the
                                                     interrupts below are active. A read clears the ssi_txu_intr,
                                                     ssi_txo_intr, ssi_rxu_intr, ssi_rxo_intr, and the ssi_fae_intr
                                                     interrupts. Writing to this register has no effect.                       */
    } icr_b;
  } ;
  
  union {
    __IOM uint32_t dmacr;                       /*!< (@ 0x0000004C) DMA Control Register                                       */
    
    struct {
      __IOM uint32_t rx_dmac_en : 1;            /*!< [0..0] Receive DMA Enable. This bit enables/disables the receive
                                                     FIFO DMA channel 0 : Receive DMA disabled 1 : Receive DMA
                                                     enabled                                                                   */
      __IOM uint32_t tx_dmac_en : 1;            /*!< [1..1] Transmit DMA Enable. This bit enables/disables the transmit
                                                     FIFO DMA channel. 0 : Transmit DMA disabled 1 : Transmit
                                                     DMA enabled                                                               */
    } dmacr_b;
  } ;
  
  union {
    __IOM uint32_t dmatdlr;                     /*!< (@ 0x00000050) DMA Transmit Data Level Register                           */
    
    struct {
      __IOM uint32_t dmatdl     : 8;            /*!< [7..0] Transmit Data Level. This bit field controls the level
                                                     at which a DMA request is made by the transmit logic. It
                                                     is equal to the watermark level; that is, the dma_tx_req
                                                     signal is generated when the number of valid data entries
                                                     in the transmit FIFO is equal to or below this field value,
                                                     and tx_dmac_en = 1.                                                       */
    } dmatdlr_b;
  } ;
  
  union {
    __IOM uint32_t dmardlr;                     /*!< (@ 0x00000054) DMA Receive Data Level Register                            */
    
    struct {
      __IOM uint32_t dmardl     : 8;            /*!< [7..0] Receive Data Level. This bit field controls the level
                                                     at which a DMA request is made by the receive logic. The
                                                     watermark level = DMARDL+1; that is, dma_rx_req is generated
                                                     when the number of valid data entries in the receive FIFO
                                                     is equal to or above this field value + 1, and rx_dmac_en
                                                     = 1.                                                                      */
    } dmardlr_b;
  } ;
  __IM  uint32_t  RESERVED1[2];
  
  union {
    union {
      __IOM uint32_t dr_word;                   /*!< (@ 0x00000060) Data Register                                              */
      
      struct {
        __IOM uint32_t word     : 32;           /*!< [31..0] Access FIFO as if its width is 4 byte per data item               */
      } dr_word_b;
    } ;
    
    union {
      __IOM uint16_t dr_half_word;              /*!< (@ 0x00000060) Data Register                                              */
      
      struct {
        __IOM uint16_t half_word : 16;          /*!< [15..0] Access FIFO as if its width is 2 byte per data item               */
      } dr_half_word_b;
    } ;
    
    union {
      __IOM uint8_t dr_byte;                    /*!< (@ 0x00000060) Data Register                                              */
      
      struct {
        __IOM uint8_t byte      : 8;            /*!< [7..0] Access FIFO as if its width is 1 byte per data item                */
      } dr_byte_b;
    } ;
  };
  __IM  uint32_t  RESERVED2[31];
  
  union {
    union {
      __IOM uint32_t read_fast_single;          /*!< (@ 0x000000E0) Fast Read Command Register                                 */
      
      struct {
        __IOM uint32_t frd_cmd  : 8;            /*!< [7..0] Fast read command.                                                 */
      } read_fast_single_b;
    } ;
    
    union {
      __IOM uint32_t rd_octal_io;               /*!< (@ 0x000000E0) Fast Read Command Register                                 */
      
      struct {
        __IOM uint32_t frd_octal_cmd : 16;      /*!< [15..0] Fast read command for Octal IO mode.                              */
      } rd_octal_io_b;
    } ;
  };
  
  union {
    __IOM uint32_t read_dual_data;              /*!< (@ 0x000000E4) Dual Read Command Register                                 */
    
    struct {
      __IOM uint32_t rd_dual_o_cmd : 8;         /*!< [7..0] Dual data read command, 1-1-2 mode.                                */
    } read_dual_data_b;
  } ;
  
  union {
    __IOM uint32_t read_dual_addr_data;         /*!< (@ 0x000000E8) Dual IO Read Command Register                              */
    
    struct {
      __IOM uint32_t rd_dual_io_cmd : 8;        /*!< [7..0] Dual address and data read command, 1-2-2 mode.                    */
    } read_dual_addr_data_b;
  } ;
  
  union {
    __IOM uint32_t read_quad_data;              /*!< (@ 0x000000EC) Quad Read Command Register                                 */
    
    struct {
      __IOM uint32_t rd_quad_o_cmd : 8;         /*!< [7..0] Quad data read command, 1-1-4 mode.                                */
    } read_quad_data_b;
  } ;
  
  union {
    __IOM uint32_t read_quad_addr_data;         /*!< (@ 0x000000F0) Quad IO Read Command Register                              */
    
    struct {
      __IOM uint32_t rd_quad_io_cmd : 8;        /*!< [7..0] Quad address and data read command, 1-4-4 mode.                    */
      __IM  uint32_t            : 8;
      __IOM uint32_t prm_value  : 8;            /*!< [23..16] High Performance Read Mode Control Value.                        */
    } read_quad_addr_data_b;
  } ;
  
  union {
    union {
      __IOM uint32_t write_single;              /*!< (@ 0x000000F4) Single IO Page Program Command Register                    */
      
      struct {
        __IOM uint32_t wr_cmd   : 8;            /*!< [7..0] One bit mode page program command.                                 */
      } write_single_b;
    } ;
    
    union {
      __IOM uint32_t write_octal_io;            /*!< (@ 0x000000F4) Octal IO Page Program Command Register                     */
      
      struct {
        __IOM uint32_t wr_octal_cmd : 16;       /*!< [15..0] Octal IO page program command.                                    */
      } write_octal_io_b;
    } ;
  };
  
  union {
    __IOM uint32_t write_dual_data;             /*!< (@ 0x000000F8) Dual Page Program Command Register                         */
    
    struct {
      __IOM uint32_t rd_dual_io_cmd : 8;        /*!< [7..0] Dual page program command, 1-1-2 mode.                             */
    } write_dual_data_b;
  } ;
  
  union {
    __IOM uint32_t write_dual_addr_data;        /*!< (@ 0x000000FC) Dual IO Page Program Command Register                      */
    
    struct {
      __IOM uint32_t wr_dual_ii_cmd : 8;        /*!< [7..0] Dual IO page program command, 1-2-2 mode.                          */
    } write_dual_addr_data_b;
  } ;
  
  union {
    __IOM uint32_t write_quad_data;             /*!< (@ 0x00000100) Quad Page Program Command Register                         */
    
    struct {
      __IOM uint32_t wr_quad_i_cmd : 8;         /*!< [7..0] Quad page program command, 1-1-4 mode.                             */
    } write_quad_data_b;
  } ;
  
  union {
    __IOM uint32_t write_quad_addr_data;        /*!< (@ 0x00000104) Quad IO Page Program Command Register                      */
    
    struct {
      __IOM uint32_t wr_quad_ii_cmd : 8;        /*!< [7..0] Quad IO page program command, 1-4-4 mode.                          */
    } write_quad_addr_data_b;
  } ;
  
  union {
    __IOM uint32_t write_enable;                /*!< (@ 0x00000108) Write Enable Command Register                              */
    
    struct {
      __IOM uint32_t wr_en_cmd  : 16;           /*!< [15..0] Write Enable Command. The second command byte is for
                                                     DTR mode.                                                                 */
    } write_enable_b;
  } ;
  
  union {
    __IOM uint32_t read_status;                 /*!< (@ 0x0000010C) Read Status Command Register                               */
    
    struct {
      __IOM uint32_t rd_st_cmd  : 16;           /*!< [15..0] Read flash status register command.                               */
    } read_status_b;
  } ;
  
  union {
    __IOM uint32_t ctrlr2;                      /*!< (@ 0x00000110) SPIC Control Register 2                                    */
    
    struct {
      __IOM uint32_t so_dnum    : 1;            /*!< [0..0] Indicate SO input pin of SPI Flash is connected to spi_sout[0]
                                                     or spi_sout[1]. Set 1 to support multi-channels connection
                                                     in default.                                                               */
      __IM  uint32_t            : 2;
      __IOM uint32_t seq_en     : 1;            /*!< [3..3] Set to enable data-split program / read.                           */
      __IOM uint32_t tx_fifo_entry : 4;         /*!< [7..4] Indicate the valid entry of transmit FIFO.                         */
      __IOM uint32_t rx_fifo_entry : 4;         /*!< [11..8] Indicate the valid entry of receive FIFO.                         */
      __IOM uint32_t cs_active_hold : 2;        /*!< [13..12] For flash chip select active hold time after SCLK resing
                                                     edge.                                                                     */
    } ctrlr2_b;
  } ;
  
  union {
    __IOM uint32_t fbaudr;                      /*!< (@ 0x00000114) Fast Read Baud Rate Select Register                        */
    
    struct {
      __IOM uint32_t fsckdv     : 12;           /*!< [11..0] This register controls the frequency of spi_sclk for
                                                     fast read command. spi_sclk = frequency of bus_clk / (2*fsckdv)           */
    } fbaudr_b;
  } ;
  
  union {
    __IOM uint32_t addr_length;                 /*!< (@ 0x00000118) Address Byte Length Register                               */
    
    struct {
      __IOM uint32_t addr_phase_length : 3;     /*!< [2..0] Indicate the number of bytes in address phase. addr_phase_length
                                                     [2] is an extended bit for 4-Byte Address with PRM mode.
                                                     Set to 5, SPIC can send 4 byte address and 1 byte PRM mode
                                                     value. 3-Byte Address with PRM mode need to set this bit
                                                     to 0, SPIC can send 3byte address and 1byte PRM mode value.
                                                     1 : One byte address, 2 : Two byte address, 3 : Three byte
                                                     address, 4: Four byte address with PRM value, 0 : Four
                                                     byte address / Three bytee addree with PRM value.                         */
    } addr_length_b;
  } ;
  
  union {
    union {
      __IOM uint32_t auto_length;               /*!< (@ 0x0000011C) Auto Mode Address Byte Length Register                     */
      
      struct {
        __IOM uint32_t rd_dummy_length : 12;    /*!< [11..0] Indicate dummy cycles for receiving data. It is referenced
                                                     by bus_clk.                                                               */
        __IM  uint32_t          : 4;
        __IOM uint32_t auto_addr_length : 2;    /*!< [17..16] Number of address bytes in read/write command in auto
                                                     mode                                                                      */
        __IOM uint32_t auto_dum_len : 8;        /*!< [25..18] Dummy cycle is used to check flash status in auto_write
                                                     operation if delay time of read data 1 cycle.                             */
        __IOM uint32_t cs_h_rd_dum_len : 2;     /*!< [27..26] Dummy cycle between sending read command to SPI flash.
                                                     Using the dummy cycles can avoid the timing violation of
                                                     CS high time.                                                             */
        __IOM uint32_t cs_h_wr_dum_len : 4;     /*!< [31..28] Dummy cycle between sending write command to SPI flash.
                                                     Using the dummy cycles can avoid the timing violation of
                                                     CS high time.                                                             */
      } auto_length_b;
    } ;
    
    union {
      __IOM uint32_t auto_length_seq;           /*!< (@ 0x0000011C) Sequential Auto Mode Address Byte Length Register          */
      
      struct {
        __IOM uint32_t rd_dummy_length : 12;    /*!< [11..0] Indicate dummy cycles for receiving data. It is referenced
                                                     by bus_clk.                                                               */
        __IOM uint32_t in_physical_cyc : 4;     /*!< [15..12] Indicate how many SPIC clk cycles from pad to internal
                                                     SPIC.                                                                     */
        __IOM uint32_t auto_addr_length : 2;    /*!< [17..16] Number of address bytes in read/write command in auto
                                                     mode                                                                      */
        __IOM uint32_t spic_cyc_per_byte : 8;   /*!< [25..18] Indicate how many SPIC clk cycles for one byte. Formula
                                                     = BAUD*2*Byte / CH, the maximum value is 256                              */
        __IOM uint32_t cs_h_rd_dum_len : 2;     /*!< [27..26] Dummy cycle between sending read command to SPI flash.
                                                     Using the dummy cycles can avoid the timing violation of
                                                     CS high time.                                                             */
        __IOM uint32_t cs_h_wr_dum_len : 4;     /*!< [31..28] Dummy cycle between sending write command to SPI flash.
                                                     Using the dummy cycles can avoid the timing violation of
                                                     CS high time.                                                             */
      } auto_length_seq_b;
    } ;
  };
  
  union {
    __IOM uint32_t valid_cmd;                   /*!< (@ 0x00000120) Valid Command Register                                     */
    
    struct {
      __IOM uint32_t frd_single : 1;            /*!< [0..0] Execute fast read for auto read mode.                              */
      __IOM uint32_t rd_dual_i  : 1;            /*!< [1..1] Execute dual data write for auto read mode. (1-1-2)                */
      __IOM uint32_t rd_dual_io : 1;            /*!< [2..2] Execute dual address data read for auto read mode. (1-2-2)         */
      __IOM uint32_t rd_quad_o  : 1;            /*!< [3..3] Execute quad data write for auto read mode. (1-1-4)                */
      __IOM uint32_t rd_quad_io : 1;            /*!< [4..4] Execute quad address data read for auto read mode. (1-4-4)         */
      __IOM uint32_t wr_dual_i  : 1;            /*!< [5..5] Execute dual data write for auto write mode. (1-1-2)               */
      __IOM uint32_t wr_dual_ii : 1;            /*!< [6..6] Execute dual address data write for auto write mode.
                                                     (1-2-2)                                                                   */
      __IOM uint32_t wr_quad_i  : 1;            /*!< [7..7] Execute quad data write for auto write mode. (1-1-4)               */
      __IOM uint32_t wr_quad_ii : 1;            /*!< [8..8] Execute quad address data write for auto write mode.
                                                     (1-4-4)                                                                   */
      __IOM uint32_t wr_blocking : 1;           /*!< [9..9] Accept next operation after the write data push to FIFO
                                                     and FIFO is pop data to empty by SPIC. Should always be
                                                     1.                                                                        */
      __IM  uint32_t            : 1;
      __IOM uint32_t prm_en     : 1;            /*!< [11..11] Enable SPIC performance read mode in auto mode.                  */
      __IOM uint32_t ctrlr0_ch  : 1;            /*!< [12..12] Set this bit, then SPIC refers cmd_ch / data_ch / addr_en
                                                     / cmd_ddr_en / data_ddr_en / addr_ddr_en bit fields in
                                                     Control Register 0 in auto mode.                                          */
      __IM  uint32_t            : 1;
      __IOM uint32_t seq_trans_en : 1;          /*!< [14..14] Set 1 to enable read sequential transaction determination
                                                     function. If the auto read address is sequenctial, users
                                                     can save command phase and address phase under this mode.                 */
    } valid_cmd_b;
  } ;
  
  union {
    __IOM uint32_t flash_size;                  /*!< (@ 0x00000124) Write Enable Command Register                              */
    
    struct {
      __IOM uint32_t flash_size : 4;            /*!< [3..0] The size of flash size to select the target SPI flash
                                                     in auto mode.                                                             */
    } flash_size_b;
  } ;
  
  union {
    __IOM uint32_t flush_fifo;                  /*!< (@ 0x00000128) Read Status Command Register                               */
    
    struct {
      __OM  uint32_t flush_fifio : 1;           /*!< [0..0] Write to flush SPIC FIFO.                                          */
    } flush_fifo_b;
  } ;
} SPIC_Type;                                    /*!< Size = 300 (0x12c)                                                        */



/* =========================================================================================================================== */
/* ================                                           UART0                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief UART port 0, 7/8 bit frame, 1/2 stop bit, up to 4000000 baud rate (UART0)
  */

typedef struct {                                /*!< (@ 0x40003000) UART0 Structure                                            */
  
  union {
    __IOM uint32_t dll;                         /*!< (@ 0x00000000) Divisor Latch (LS) Register                                */
    
    struct {
      __IOM uint32_t dll        : 8;            /*!< [7..0] Baud rate divisor-low register, accessable only when
                                                     DLAB = 1                                                                  */
    } dll_b;
  } ;
  
  union {
    union {
      __IOM uint32_t dlm;                       /*!< (@ 0x00000004) Divisor Latch (MS) Register                                */
      
      struct {
        __IOM uint32_t dlm      : 8;            /*!< [7..0] Baud rate divisor-high register, accessable only when
                                                     DLAB = 1                                                                  */
      } dlm_b;
    } ;
    
    union {
      __IOM uint32_t ier;                       /*!< (@ 0x00000004) Interrupt Enable Register                                  */
      
      struct {
        __IOM uint32_t erbi     : 1;            /*!< [0..0] Enable Received Data Available Interrupt (ERBFI) (rx
                                                     trigger)                                                                  */
        __IOM uint32_t etbei    : 1;            /*!< [1..1] Enable Transmitter FIFO Empty interrupt (ETBEI) (tx fifo
                                                     empty)                                                                    */
        __IOM uint32_t elsi     : 1;            /*!< [2..2] Enable Receiver Line Status Interrupt (ELSI) (receiver
                                                     line status)                                                              */
        __IOM uint32_t edssi    : 1;            /*!< [3..3] Enable Modem Status Interrupt (EDSSI) (modem status transition)    */
      } ier_b;
    } ;
  };
  
  union {
    union {
      __IM  uint32_t iir;                       /*!< (@ 0x00000008) Interrupt Identification Register                          */
      
      struct {
        __IM  uint32_t int_pend : 1;            /*!< [0..0] Indicates that an interrupt is pending when it's logic
                                                     0. When it is 1, no interrupt is pending                                  */
        __IM  uint32_t int_id   : 3;            /*!< [3..1] Bit1 and Bit2 the two bits of the IIR are used to identify
                                                     the highest priority interrupt pending as indicated in
                                                     the following table Bit3: In the FIFO mode this bit is
                                                     set along with bit 2 when a timeout interrupt is pending.                 */
      } iir_b;
    } ;
    
    union {
      __IOM uint32_t fcr;                       /*!< (@ 0x00000008) FIFO Control Register                                      */
      
      struct {
        __OM  uint32_t en_rxfifo_err : 1;       /*!< [0..0] Set as 1 to enable the report of Error in RCVR FIFO field
                                                     in LSR bit [7]                                                            */
        __OM  uint32_t clear_rxfifo : 1;        /*!< [1..1] Writing a Logic 1 to Bit 1 clears the Receiver FIFO and
                                                     resets its logic. But it doesn't clear the shift register.
                                                     The 1 that is written to this bit position is self-clearing.              */
        __OM  uint32_t clear_txfifo : 1;        /*!< [2..2] Write 1 to this bit clears the Transmitter FIFO and resets
                                                     its logic. But the shift register is not cleared, The 1
                                                     that is written to this bit position is self-clearing.                    */
        __OM  uint32_t dma_mode : 1;            /*!< [3..3] Support DMA mode. (cooperate with DW DDMA in the data
                                                     path)                                                                     */
        __IM  uint32_t          : 1;
        __IOM uint32_t txfifo_low_level : 1;    /*!< [5..5] Define the Transmission FIFO Low Water Level Interrupt
                                                     trigger. 0: 4 byte 1: 8 bytes                                             */
        __IOM uint32_t rxfifo_trigger_level : 2;/*!< [7..6] Define the 32-entries Receiver FIFO Interrupt trigger
                                                     level 0~31 bytes 00: 1 byte 01: 8 bytes 10: 16 bytes 11:
                                                     30 bytes (for some device detect RTS de-assertion slower,
                                                     reserve more RX FIFO space to prevent RX FIFO overflow
                                                     )                                                                         */
      } fcr_b;
    } ;
  };
  
  union {
    __IOM uint32_t lcr;                         /*!< (@ 0x0000000C) Line Control Register                                      */
    
    struct {
      __IOM uint32_t wls0       : 1;            /*!< [0..0] Word length selection,                                             */
      __IM  uint32_t            : 1;
      __IOM uint32_t stb        : 1;            /*!< [2..2] This bit specifies the number of Stop bits transmitted
                                                     and received in each serial character. 0: 1 stop bit. 1:
                                                     2 stop bits. Note that the receiver always checks the first
                                                     stop bit only.                                                            */
      __IOM uint32_t parity_en  : 1;            /*!< [3..3] Parity Enable                                                      */
      __IOM uint32_t even_parity_sel : 1;       /*!< [4..4] Even Parity select                                                 */
      __IOM uint32_t stick_parity_en : 1;       /*!< [5..5] Stick Parity enable control. LCR[5:4]: 00: Odd Parity
                                                     01: Even Parity 10: Stick Parity as 0 11: Stick Parity
                                                     as 1                                                                      */
      __IOM uint32_t break_ctrl : 1;            /*!< [6..6] Break Control bit. Break control bit causes a break condition
                                                     to be transmitted to the receiving UART.                                  */
      __IOM uint32_t dlab       : 1;            /*!< [7..7] Divisor Latch Access bit Note: DLL/DLM only can be access
                                                     when dlab bit = 1, IER only can be access when dlab bit
                                                     = 0. THR/RBR don't care about dlab bit value                              */
    } lcr_b;
  } ;
  
  union {
    __IOM uint32_t mcr;                         /*!< (@ 0x00000010) Modem Control Register                                     */
    
    struct {
      __IOM uint32_t dtr        : 1;            /*!< [0..0] Data Terminal Ready (DTR) signal control 0::DTR is logic
                                                     1 1::DTR is logic 0                                                       */
      __IOM uint32_t rts        : 1;            /*!< [1..1] Request to Send (RTS) signal control 0: RTS is logic
                                                     1 1: RTS is logic 0 The RTS output is controlled as following
                                                     equation: RTS_output = rts_en ? (~rts|FIFO_FlowCtrl):~rts                 */
      __IOM uint32_t out1       : 1;            /*!< [2..2] This bit controls the Output 1 (OUT1_) signal, which
                                                     is an auxiliary user-designated output.                                   */
      __IOM uint32_t out2       : 1;            /*!< [3..3] This bit controls the output 2 (OUT2_) signal, which
                                                     is an auxiliary user-designated output.                                   */
      __IOM uint32_t loopback_en : 1;           /*!< [4..4] LoopBack mode. This bit provides a local loopback feature
                                                     for diagnostic testing of the UART.                                       */
      __IOM uint32_t cts_en     : 1;            /*!< [5..5] CTS flow control enable (CTSE) This Bit (CTSE) is the
                                                     auto CTS flow control enable. When set (1), the auto CTS
                                                     flow control as described in the detailed description is
                                                     enabled.                                                                  */
      __IOM uint32_t rts_en     : 1;            /*!< [6..6] RTS flow control enable (RTSE) This Bit (RTSE) is the
                                                     auto RTS flow control enables. When set (1), the auto RTS
                                                     flow control as described in the detailed description is
                                                     enabled.                                                                  */
      __IOM uint32_t sw_cts     : 1;            /*!< [7..7] Software controlled CTS. The software can use this bit
                                                     to pause the UART transmission, just like the HW flow control.This
                                                     bit setting will effects the CTS flow-control: CTS = cts_en
                                                     ? (sw_cts | CTS_input) : sw_cts                                           */
    } mcr_b;
  } ;
  
  union {
    __IM  uint32_t lsr;                         /*!< (@ 0x00000014) Line Status Register                                       */
    
    struct {
      __IM  uint32_t rxfifo_datardy : 1;        /*!< [0..0] Data Ready (DR) indicator This bit is 1 when at least
                                                     one character has been received and transferred into the
                                                     FIFO. It be reset to logic 0 by reading all of the data
                                                     in the Receiver Buffer Register or the RX FIFO.                           */
      __IM  uint32_t overrun_err : 1;           /*!< [1..1] Overrun Error (OE) indicator. This bit is set (1) to
                                                     indicates that data in the RX FIFO was not read by the
                                                     CPU before the next character was transferred into the
                                                     RX FIFO,                                                                  */
      __IM  uint32_t parity_err : 1;            /*!< [2..2] Parity Error (PE) indicator. This bit is set to indicates
                                                     that the received data character does not have the correct
                                                     even or odd parity, as selected by the even-parity-select
                                                     bit.                                                                      */
      __IM  uint32_t framing_err : 1;           /*!< [3..3] Framing Error (FE) indicator. This bit is set when the
                                                     received character at the top of the FIFO did not have
                                                     a valid stop bit.                                                         */
      __IM  uint32_t break_err_int : 1;         /*!< [4..4] Break Interrupt (BI) indicator. This bit is set to logic
                                                     1 whenever the received data input is held in the Spacing
                                                     (logic 0) state for a longer than a full word transmission
                                                     time.                                                                     */
      __IM  uint32_t txfifo_empty : 1;          /*!< [5..5] TXFIFO empty indicator. It indicates that the Transmitter
                                                     FIFO is empty. This bit is set when the Transmitter FIFO
                                                     is empty; it is cleared when at least 1 byte is written
                                                     to the Transmitter FIFO.                                                  */
      __IM  uint32_t            : 1;
      __IM  uint32_t rxfifo_err : 1;            /*!< [7..7] Uart_rx_error. This bit is set when there is at least
                                                     on parity error, framing error or break indication in the
                                                     FIFO. It is clear when the CPU reads the LSR, if there
                                                     are no subsequent errors in the FIFO                                      */
    } lsr_b;
  } ;
  
  union {
    __IM  uint32_t msr;                         /*!< (@ 0x00000018) Modem Status Register                                      */
    
    struct {
      __IM  uint32_t d_cts      : 1;            /*!< [0..0] Delta Clear to Send (DCTS) indicator                               */
      __IM  uint32_t d_dsr      : 1;            /*!< [1..1] Delta Data Set Ready (DDSR) indicator                              */
      __IM  uint32_t teri       : 1;            /*!< [2..2] Trailing Edge of Ring Indicator (TERI) detector. The
                                                     RI line has changed its state from low to high state.                     */
      __IM  uint32_t d_dcd      : 1;            /*!< [3..3] Delta Data Carrier Detect (DDCD) indicator.                        */
      __IM  uint32_t r_cts      : 1;            /*!< [4..4] Complement of the CTS input or equals to RTS in loopback
                                                     mode.                                                                     */
      __IM  uint32_t r_dsr      : 1;            /*!< [5..5] Complement of the DSR input or equals to DTR in loopback
                                                     mode.                                                                     */
      __IM  uint32_t r_ri       : 1;            /*!< [6..6] Complement of the RI input or equals to Out1 in loopback
                                                     mode.                                                                     */
      __IM  uint32_t r_dcd      : 1;            /*!< [7..7] Complement of the DCD input or equals to Out2 in loopback
                                                     mode.                                                                     */
    } msr_b;
  } ;
  
  union {
    __IOM uint32_t scr;                         /*!< (@ 0x0000001C) Scratch Pad Register                                       */
    
    struct {
      __IM  uint32_t            : 3;
      __IOM uint32_t pin_lb_test : 1;           /*!< [3..3] For uart IP txd/rxd/rts/cts pin loopback test                      */
      __IM  uint32_t fl_frame_err : 1;          /*!< [4..4] Frame error flag                                                   */
      __IM  uint32_t fl_set_bi_err : 1;         /*!< [5..5] set_bi_err flag                                                    */
      __IOM uint32_t rx_break_int_en : 1;       /*!< [6..6] Rx break signal interrupt enable                                   */
      __IOM uint32_t rx_break_int_sts : 1;      /*!< [7..7] Rx break signal interrupt status, write 1 to this bit
                                                     will clear the interrupt pending status                                   */
      __IOM uint32_t dbg_sel    : 4;            /*!< [11..8] Debug port selection                                              */
      __IM  uint32_t            : 4;
      __IOM uint32_t xfactor_adj : 11;          /*!< [26..16] The ovsr_adj, one of factors of baud rate calculation            */
    } scr_b;
  } ;
  
  union {
    __IOM uint32_t stsr;                        /*!< (@ 0x00000020) STS Register                                               */
    
    struct {
      __IM  uint32_t            : 3;
      __IOM uint32_t reset_rcv  : 1;            /*!< [3..3] Reset Uart Receiver                                                */
      __IOM uint32_t xfactor    : 4;            /*!< [7..4] Factor of Baud rate calculation, the ovsr[3:0]                     */
      __IM  uint32_t            : 16;
      __IM  uint32_t dma_mode   : 1;            /*!< [24..24] dma_mode field of FCR bit[3]                                     */
      __IM  uint32_t fifo_en    : 1;            /*!< [25..25] fifo_en field of FCR bit[0]                                      */
      __IM  uint32_t txfifo_low_level : 1;      /*!< [26..26] txfifo_low_level in FCR bit[5], Define the Transmission
                                                     FIFO Low Water Level Interrupt trigger. 0: 4 byte 1: 8
                                                     bytes                                                                     */
      __IM  uint32_t rxfifo_trigger_level : 2;  /*!< [28..27] rxfifo_trigger_level in FCR bit[7:6], Define the 32-entries
                                                     Receiver FIFO Interrupt trigger level 0~31 bytes 00: 1
                                                     byte 01: 8 bytes 10: 16 bytes 11: 28 bytes (for some device
                                                     detect RTS de-assertion slower, reserve more RX FIFO space
                                                     to prevent RX FIFO overflow )                                             */
    } stsr_b;
  } ;
  
  union {
    union {
      __IM  uint32_t rbr;                       /*!< (@ 0x00000024) Receiver Buffer Register                                   */
      
      struct {
        __IM  uint32_t rxdata   : 8;            /*!< [7..0] Rx data. Bit 0 is the least significant bit. It is the
                                                     first bit serially received.                                              */
      } rbr_b;
    } ;
    
    union {
      __OM  uint32_t thr;                       /*!< (@ 0x00000024) Transmitter Holder Register                                */
      
      struct {
        __OM  uint32_t txdata   : 8;            /*!< [7..0] Tx data. Bit 0 is the least significant bit. It is the
                                                     first bit serially transmitted.                                           */
      } thr_b;
    } ;
  };
  
  union {
    __IOM uint32_t miscr;                       /*!< (@ 0x00000028) MISC Control Register                                      */
    
    struct {
      __IOM uint32_t irda_enable : 1;           /*!< [0..0] IRDA mode enable control. When set this bit as 1, the
                                                     UART is co-work with IRDA SIR mode. i.e., txd/rxd are irda
                                                     signals.                                                                  */
      __IOM uint32_t txdma_en   : 1;            /*!< [1..1] TX DMA enable control. (valid when dma_mode in FCR is
                                                     1)                                                                        */
      __IOM uint32_t rxdma_en   : 1;            /*!< [2..2] RX DMA enable control. (valid when dma_mode in FCR is
                                                     1)                                                                        */
      __IOM uint32_t txdma_burstsize : 5;       /*!< [7..3] Txdma burstsize                                                    */
      __IOM uint32_t rxdma_burstsize : 6;       /*!< [13..8] Rxdma burstsize                                                   */
      __IOM uint32_t irda_tx_inv : 1;           /*!< [14..14] Invert irda_tx_o when this bit is 1.                             */
      __IOM uint32_t irda_rx_inv : 1;           /*!< [15..15] Invert irda_rx_i when this bit is 1.                             */
      __IOM uint32_t tx_en      : 1;            /*!< [16..16] The UART TX function.enable control                              */
    } miscr_b;
  } ;
  
  union {
    __IOM uint32_t txplsr;                      /*!< (@ 0x0000002C) IRDA SIR TX Pulse Width Control 0 Register                 */
    
    struct {
      __IOM uint32_t txpulse_lowbound_shiftval : 15;/*!< [14..0] The shift value of SIR tx pulse's left edge position.         */
      __IOM uint32_t lowbound_shiftright : 1;   /*!< [15..15] SIR TX pulse lower bond shift control.                           */
      __IOM uint32_t txpulse_upperbound_shiftval : 15;/*!< [30..16] The shift value of SIR tx pulse's right edge position.     */
      __IOM uint32_t Upperbound_shiftright : 1; /*!< [31..31] SIR TX pulse upper bond shift control.                           */
    } txplsr_b;
  } ;
  __IM  uint32_t  RESERVED;
  
  union {
    __IOM uint32_t baudmonr;                    /*!< (@ 0x00000034) Baud Monitor Register                                      */
    
    struct {
      __IM  uint32_t min_fall_space : 12;       /*!< [11..0] Min_fall_space                                                    */
      __IM  uint32_t min_low_period : 12;       /*!< [23..12] Min_low_period                                                   */
      __IOM uint32_t falling_thresh : 6;        /*!< [29..24] Falling_thresh                                                   */
      __IM  uint32_t mon_data_vld : 1;          /*!< [30..30] The monitor data valid indication                                */
      __IOM uint32_t toggle_mon_en : 1;         /*!< [31..31] Baud monitor toggle bit enable.                                  */
    } baudmonr_b;
  } ;
  __IM  uint32_t  RESERVED1;
  
  union {
    __IM  uint32_t dbg2;                        /*!< (@ 0x0000003C) Debug Register                                             */
    
    struct {
      __IM  uint32_t dbg_uart   : 32;           /*!< [31..0] The debug port output value, depend on dbg_sel value
                                                     in SCR[2:0].                                                              */
    } dbg2_b;
  } ;
  
  union {
    __IOM uint32_t rfcr;                        /*!< (@ 0x00000040) RX Filter Control Register                                 */
    
    struct {
      __IOM uint32_t rf_len     : 1;            /*!< [0..0] Set the length of received data to be check. 0/1 = 1bytes/2bytes   */
      __IOM uint32_t rf_mask_en : 1;            /*!< [1..1] Enable the mask operation for received data.                       */
      __IOM uint32_t rf_cmp_op  : 2;            /*!< [3..2] Set the RX filter comparing rule. The matched condition
                                                     is listed as following table: RF_LEN = 0: RF_CMP_OP = 0
                                                     (AND) 1st byte = Magic Pattern1 1 (OR) (1st byte = Magic
                                                     Pattern1) OR (1st byte = Magic Pattern2) 2 (XOR) (1st byte
                                                     != Magic Pattern1) AND (1st byte != Magic Pattern2) RF_LEN
                                                     = 1: RF_CMP_OP = 0 (AND) (1st byte = Magic Pattern1) AND
                                                     (2nd byte = Magic Pattern2) 1 (OR) (2nd byte = Magic Pattern1)
                                                     OR (2nd byte = Magic Pattern2) 2 (XOR) (1st byte != Magic
                                                     Pattern1) AND (2nd byte != Magic Patte                                    */
      __IM  uint32_t            : 3;
      __IOM uint32_t rf_en      : 1;            /*!< [7..7] RX Filter enable control                                           */
    } rfcr_b;
  } ;
  
  union {
    __IOM uint32_t rfmpr;                       /*!< (@ 0x00000044) RX Filter Magic Pattern Register                           */
    
    struct {
      __IOM uint32_t rf_mp1     : 8;            /*!< [7..0] The magic pattern1 for the 1st received byte checking.             */
      __IOM uint32_t rf_mp2     : 8;            /*!< [15..8] The magic pattern2 for the 2nd received byte checking.            */
    } rfmpr_b;
  } ;
  
  union {
    __IOM uint32_t rfmvr;                       /*!< (@ 0x00000048) RX Filter Mask Value Register                              */
    
    struct {
      __IOM uint32_t rf_mv1     : 8;            /*!< [7..0] The mask value for the 1st received byte.                          */
      __IOM uint32_t rf_mv2     : 8;            /*!< [15..8] The mask value for the 2nd received byte.                         */
    } rfmvr_b;
  } ;
  
  union {
    __IOM uint32_t rftor;                       /*!< (@ 0x0000004C) RX Filter Timeout Register                                 */
    
    struct {
      __IOM uint32_t rf_timeout : 20;           /*!< [19..0] Set the timeout value of the RX filter idle detection.
                                                     This value is number of ticks. A tick time is equal to
                                                     a UART bit time.                                                          */
    } rftor_b;
  } ;
  
  union {
    __IOM uint32_t rflvr;                       /*!< (@ 0x00000050) RX FIFO Level Register                                     */
    
    struct {
      __IM  uint32_t rx_fifo_lv : 6;            /*!< [5..0] The level of the RX FIFO. This value indicates the number
                                                     of data bytes in the RX FIFO.                                             */
    } rflvr_b;
  } ;
  
  union {
    __IOM uint32_t tflvr;                       /*!< (@ 0x00000054) TX FIFO Level Register                                     */
    
    struct {
      __IM  uint32_t tx_fifo_lv : 5;            /*!< [4..0] The level of the TX FIFO. This value indicates the number
                                                     of data bytes in the TX FIFO.                                             */
    } tflvr_b;
  } ;
  
  union {
    __IOM uint32_t visr;                        /*!< (@ 0x00000058) Vendor Interrupt Status Register                           */
    
    struct {
      __IOM uint32_t rf_match_patt : 1;         /*!< [0..0] The interrupt status of RX filter pattern checking matched.
                                                     Write 1 to clear this interrupt status. 0: Interrupt is
                                                     not pending. 1: Interrupt is pending.                                     */
      __IOM uint32_t rf_timeout : 1;            /*!< [1..1] This bit indicates the interrupt pending status of the
                                                     RX filter timeout occurred. The RX idle detection mechanism
                                                     is used to check whether the receiving is in idle state
                                                     for re-aquire pattern matching. This mechanism uses a timer
                                                     to monitor new data receiving. This timer will reload the
                                                     initial value whenever a new byte is received. If the timeout
                                                     occurred (timer value countdown to 0), the RX filter will
                                                     be reset to the initialed state and restart the first received
                                                     1 or 2 bytes checking.                                                    */
      __IOM uint32_t tx_fifo_lv : 1;            /*!< [2..2] This bit indicates the interrupt pending status of the
                                                     TX FIFO water level equal to the level setting. The software
                                                     can use this interrupt to know the TX FIFO water level
                                                     is low and refill the TX FIFO. To enable this interrupt,
                                                     IER bit[5] should be written as 1. Write 1 to this bit
                                                     will clear the pending status.                                            */
      __IOM uint32_t rx_idle_timeout : 1;       /*!< [3..3] This bit indicate the receiver idle timeout interrupt
                                                     pending status. Write 1 to this bit will clear the pending
                                                     status.                                                                   */
    } visr_b;
  } ;
  
  union {
    __IOM uint32_t vier;                        /*!< (@ 0x0000005C) Vendor Interrupt Enabling Control Register                 */
    
    struct {
      __IOM uint32_t rf_match_int_en : 1;       /*!< [0..0] The Rx filter pattern matched interrupt enabling control:
                                                     1: enable 0: disable                                                      */
      __IOM uint32_t rf_timeout_int_en : 1;     /*!< [1..1] The Rx filter idle timeout interrupt enabling control:
                                                     1: enable 0: disable                                                      */
      __IOM uint32_t tx_fifo_lv_int_en : 1;     /*!< [2..2] The TX FIFO water level interrupt enabling control: 1:
                                                     enable 0: disable                                                         */
      __IOM uint32_t rx_idle_timeout_en : 1;    /*!< [3..3] The RX idle timeout interrupt enabling control: 1: enable
                                                     0: disable                                                                */
    } vier_b;
  } ;
  
  union {
    __IOM uint32_t ritor;                       /*!< (@ 0x00000060) RX Idle Timeout Register                                   */
    
    struct {
      __IOM uint32_t rxidle_timeout_value : 4;  /*!< [3..0] Time unit is the duration of a UART bit, depends on the
                                                     baud-rate setting. Default 0. 0: 8 bit time. (1*8) 1: 16
                                                     bit time. (2*8) 2: 32 bit time. (2^2*8) 3: 64 bit time.
                                                     (2^3*8) 4: 128 bit time. (2^4*8) 5: 256 bit time. (2^5*8)
                                                     6: 512 bit time. (2^6*8) 7: 1024 bit time. (2^7*8) 8: 2048
                                                     bit time. (2^8*8) 9: 4096 bit time. (2^9*8) 10: 8192 bit
                                                     time. (2^10*8) 11: 16384 bit time. (2^11*8) 12: 32768 bit
                                                     time. (2^12*8) 13: 65535 bit time. (2^13*8) 14: 131072
                                                     bit time. (2^14*8) 15: 262144 bit time. (2^15*8)                          */
      __IM  uint32_t            : 27;
      __IOM uint32_t rx_idle_timeout_en : 1;    /*!< [31..31] RX idle timeout enable, default 0.                               */
    } ritor_b;
  } ;
} UART0_Type;                                   /*!< Size = 100 (0x64)                                                         */



/* =========================================================================================================================== */
/* ================                                           SSI0                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief SSI supports 8 bit and 16 bit frame format with different combination of clock phase and clock polarity(mode 0 ~ mode 3). SSI0 is a full funtion device that can be a master or a slave device. (SSI0)
  */

typedef struct {                                /*!< (@ 0x40042000) SSI0 Structure                                             */
  
  union {
    __IOM uint32_t ctrlr0;                      /*!< (@ 0x00000000) SSI Control Register 0                                     */
    
    struct {
      __IOM uint32_t dfs        : 4;            /*!< [3..0] Data frame size                                                    */
      __IOM uint32_t frf        : 2;            /*!< [5..4] Frame format                                                       */
      __IOM uint32_t scph       : 1;            /*!< [6..6] Serial Clock Phase. Valid when the frame format (FRF)
                                                     is set to Motorola SPI. The serial clock phase selects
                                                     the relationship of the serial clock with the slave select
                                                     signal. When SCPH = 0, data are captured on the first edge
                                                     of the serial clock. When SCPH = 1, the serial clock starts
                                                     toggling one cycle after the slave select line is activated,
                                                     and data are captured on the second edge of the serial
                                                     clock. 0: Serial clock toggles in middle of first data
                                                     bit 1: Serial clock toggles at start of first data bi                     */
      __IOM uint32_t scpol      : 1;            /*!< [7..7] Serial Clock Polarity. Valid when the frame format (FRF)
                                                     is set to Motorola SPI. Used to select the polarity of
                                                     the inactive serial clock, which is held inactive when
                                                     the DW_apb_ssi master is not actively transferring data
                                                     on the serial bus. 0 : Inactive state of serial clock is
                                                     low 1 : Inactive state of serial clock is high                            */
      __IOM uint32_t tmod       : 2;            /*!< [9..8] Transfer mode                                                      */
      __IOM uint32_t slv_oe     : 1;            /*!< [10..10] Slave ouput enable. Relevant only when the device is
                                                     a slave                                                                   */
      __IM  uint32_t            : 1;
      __IOM uint32_t cfs        : 4;            /*!< [15..12] Control frame size for Microwire frame format                    */
      __IM  uint32_t            : 5;
      __IOM uint32_t tx_byte_swap : 1;          /*!< [21..21] Reverse every transmit byte                                      */
      __IOM uint32_t tx_bit_swap : 1;           /*!< [22..22] Reverse every transmit bit                                       */
      __IOM uint32_t rx_byte_swap : 1;          /*!< [23..23] Reverse every received byte                                      */
      __IOM uint32_t rx_bit_swap : 1;           /*!< [24..24] Reverse every received bit                                       */
      __IM  uint32_t            : 6;
      __IOM uint32_t ss_t       : 1;            /*!< [31..31] SSI master chooses to toggle between successive frames
                                                     or not.                                                                   */
    } ctrlr0_b;
  } ;
  
  union {
    __IOM uint32_t ctrlr1;                      /*!< (@ 0x00000004) SSI Control Register 1                                     */
    
    struct {
      __IOM uint32_t ndf        : 16;           /*!< [15..0] Number of data frame. Only valid when SSI device is
                                                     a master                                                                  */
    } ctrlr1_b;
  } ;
  
  union {
    __IOM uint32_t ssienr;                      /*!< (@ 0x00000008) SSI Enable Register                                        */
    
    struct {
      __IOM uint32_t ssi_en     : 1;            /*!< [0..0] SSI Enable. Enables and disables all DW_apb_ssi operations.
                                                     When disabled, all serial transfers are halted immediately.
                                                     Transmit and receive FIFO buffers are cleared when the
                                                     device is disabled. It is impossible to program some of
                                                     the DW_apb_ssi control registers when enabled. When disabled,
                                                     the ssi_sleep output is set (after delay) to inform the
                                                     system that it is safe to remove the ssi_clk, thus saving
                                                     power consumption in the system                                           */
    } ssienr_b;
  } ;
  
  union {
    __IOM uint32_t mwcr;                        /*!< (@ 0x0000000C) Microwire Control Register                                 */
    
    struct {
      __IOM uint32_t mwmod      : 1;            /*!< [0..0] Microwire Transfer Mode. Defines the transfer is sequential
                                                     or not.                                                                   */
      __IOM uint32_t mdd        : 1;            /*!< [1..1] Microwire Control. Defines the direction of the data
                                                     word when the Microwire serial protocol is used.                          */
      __IOM uint32_t mhs        : 1;            /*!< [2..2] Microwire Handshaking. Only valide when SSI device is
                                                     a slave.                                                                  */
    } mwcr_b;
  } ;
  
  union {
    __IOM uint32_t ser;                         /*!< (@ 0x00000010) Slave Enable Register                                      */
    
    struct {
      __IOM uint32_t ser        : 8;            /*!< [7..0] This register is only valid when the device is configured
                                                     as a master device. It is used to select which slave devices
                                                     it would like to communicate with.                                        */
    } ser_b;
  } ;
  
  union {
    __IOM uint32_t baudr;                       /*!< (@ 0x00000014) Baud Rate Select Register                                  */
    
    struct {
      __IOM uint32_t sckdv      : 16;           /*!< [15..0] This register is only valid when the device is configured
                                                     as a master device. It is used to change the operating
                                                     frequency of SPI device.                                                  */
    } baudr_b;
  } ;
  
  union {
    __IOM uint32_t txftlr;                      /*!< (@ 0x00000018) Transmit FIFO Threshold Level                              */
    
    struct {
      __IOM uint32_t tft        : 8;            /*!< [7..0] Transmit FIFO Threshold. Controls the level of entries
                                                     (or below) at which the transmit FIFO controller triggers
                                                     an interrupt.                                                             */
    } txftlr_b;
  } ;
  
  union {
    __IOM uint32_t rxftlr;                      /*!< (@ 0x0000001C) Receive FIFO Threshold Level                               */
    
    struct {
      __IOM uint32_t rft        : 8;            /*!< [7..0] Receive FIFO Threshold. Controls the level of entries
                                                     (or above) at which the receive FIFO controller triggers
                                                     an interrupt.                                                             */
    } rxftlr_b;
  } ;
  
  union {
    __IOM uint32_t txflr;                       /*!< (@ 0x00000020) Transmit FIFO Level Register                               */
    
    struct {
      __IM  uint32_t txtfl      : 8;            /*!< [7..0] Transmit FIFO Level. Contains the number of valid data
                                                     entries in the transmit FIFO.                                             */
    } txflr_b;
  } ;
  
  union {
    __IM  uint32_t rxflr;                       /*!< (@ 0x00000024) Receive FIFO Level Register                                */
    
    struct {
      __IM  uint32_t rxtfl      : 8;            /*!< [7..0] Receive FIFO Level. Contains the number of valid data
                                                     entries in the receive FIFO.                                              */
    } rxflr_b;
  } ;
  
  union {
    __IM  uint32_t sr;                          /*!< (@ 0x00000028) Status Register                                            */
    
    struct {
      __IM  uint32_t busy       : 1;            /*!< [0..0] SSI Busy Flag. When set, indicates that a serial transfer
                                                     is in progress; when cleared indicates that the DW_apb_ssi
                                                     is idle or disabled.                                                      */
      __IM  uint32_t tfnf       : 1;            /*!< [1..1] Transmit FIFO Not Full. Set when the transmit FIFO contains
                                                     one or more empty locations, and is cleared when the FIFO
                                                     is full. 0 : Transmit FIFO is full 1 : Transmit FIFO is
                                                     not full                                                                  */
      __IM  uint32_t tfe        : 1;            /*!< [2..2] Transmit FIFO Empty. When the transmit FIFO is completely
                                                     empty, this bit is set. When the transmit FIFO contains
                                                     one or more valid entries, this bit is cleared. This bit
                                                     field does not request an interrupt. 0 : Transmit FIFO
                                                     is not empty 1 : Transmit FIFO is empty                                   */
      __IM  uint32_t rfne       : 1;            /*!< [3..3] Receive FIFO Not Empty. Set when the receive FIFO contains
                                                     one or more entries and is cleared when the receive FIFO
                                                     is empty. This bit can be polled by software to completely
                                                     empty the receive FIFO. 0 : Receive FIFO is empty 1 : Receive
                                                     FIFO is not empty                                                         */
      __IM  uint32_t rff        : 1;            /*!< [4..4] Receive FIFO Full. When the receive FIFO is completely
                                                     full, this bit is set. When the receive FIFO contains one
                                                     or more empty location, this bit is cleared. 0 : Receive
                                                     FIFO is not full 1 : Receive FIFO is full                                 */
      __IM  uint32_t txe        : 1;            /*!< [5..5] Transmission Error. Set if the transmit FIFO is empty
                                                     when a transfer is started. This bit can be set only when
                                                     the DW_apb_ssi is configured as a slave device. Data from
                                                     the previous transmission is resent on the txd line. This
                                                     bit is cleared when read. 0 : No error 1 : Transmission
                                                     error                                                                     */
    } sr_b;
  } ;
  
  union {
    __IOM uint32_t imr;                         /*!< (@ 0x0000002C) Interrupt Mask Register                                    */
    
    struct {
      __IOM uint32_t txeim      : 1;            /*!< [0..0] Transmit FIFO Empty Interrupt Mask 0 : ssi_txe_intr interrupt
                                                     is masked 1 : ssi_txe_intr interrupt is not masked                        */
      __IOM uint32_t txoim      : 1;            /*!< [1..1] Transmit FIFO Overflow Interrupt Mask 0 : ssi_txo_intr
                                                     interrupt is masked 1 : ssi_txo_intr interrupt is not masked              */
      __IOM uint32_t rxuim      : 1;            /*!< [2..2] Receive FIFO Underflow Interrupt Mask 0 : ssi_rxu_intr
                                                     interrupt is masked 1 : ssi_rxu_intr interrupt is not masked              */
      __IOM uint32_t rxoim      : 1;            /*!< [3..3] Receive FIFO Overflow Interrupt Mask 0 : ssi_rxo_intr
                                                     interrupt is masked 1 : ssi_rxo_intr interrupt is not masked              */
      __IOM uint32_t rxfim      : 1;            /*!< [4..4] Receive FIFO Full Interrupt Mask 0 : ssi_rxf_intr interrupt
                                                     is masked 1 : ssi_rxf_intr interrupt is not masked                        */
      __IOM uint32_t mstim      : 1;            /*!< [5..5] Multi-Master Contention Interrupt Mask. This bit field
                                                     is not present if the deice is a slave. 0 : ssi_mst_intr
                                                     interrupt is masked 1 : ssi_mst_intr interrupt is not masked              */
      __IOM uint32_t txuim      : 1;            /*!< [6..6] Transmit FIFO Under Flow Interrupt Status. Should not
                                                     be set when the device is a master and not under SPI mode.
                                                     0 : ssi_txu_intr interrupt is masked 1 : ssi_txu_intr interrupt
                                                     is not masked                                                             */
      __IOM uint32_t ssrim      : 1;            /*!< [7..7] SS_N Rising Edge Detect Interrupt Mask 0 : ssi_ssr_intr
                                                     interrupt is masked 1 : ssi_ssr_intr interrupt is not masked              */
    } imr_b;
  } ;
  
  union {
    __IM  uint32_t isr;                         /*!< (@ 0x00000030) Interrupt Status Register                                  */
    
    struct {
      __IM  uint32_t txeis      : 1;            /*!< [0..0] Transmit FIFO Empty Interrupt Status 0 = ssi_txe_intr
                                                     interrupt is not active after masking 1 = ssi_txe_intr
                                                     interrupt is active after masking                                         */
      __IM  uint32_t txois      : 1;            /*!< [1..1] Transmit FIFO Overflow Interrupt Status 0 = ssi_txo_intr
                                                     interrupt is not active after masking 1 = ssi_txo_intr
                                                     interrupt is active after masking                                         */
      __IM  uint32_t rxuis      : 1;            /*!< [2..2] Receive FIFO Underflow Interrupt Status 0 = ssi_rxu_intr
                                                     interrupt is not active after masking 1 = ssi_rxu_intr
                                                     interrupt is active after masking                                         */
      __IM  uint32_t rxois      : 1;            /*!< [3..3] Receive FIFO Overflow Interrupt Status 0 = ssi_rxo_intr
                                                     interrupt is not active after masking 1 = ssi_rxo_intr
                                                     interrupt is active after masking                                         */
      __IM  uint32_t rxfis      : 1;            /*!< [4..4] Receive FIFO Full Interrupt Status 0 = ssi_rxf_intr interrupt
                                                     is not active after masking 1 = ssi_rxf_intr interrupt
                                                     is full after masking                                                     */
      __IM  uint32_t mstis      : 1;            /*!< [5..5] Multi-Master Contention Interrupt. This bit field is
                                                     not present if the deice is a slave. 0 = ssi_mst_intr interrupt
                                                     not active after masking 1 = ssi_mst_intr interrupt is
                                                     active after masking                                                      */
      __IM  uint32_t txuis      : 1;            /*!< [6..6] Transmit FIFO Under Flow Interrupt Status 0 = ssi_txu_intr
                                                     interrupt is not active after masking 1 = ssi_txu_intr
                                                     interrupt is active after masking                                         */
      __IM  uint32_t ssris      : 1;            /*!< [7..7] SS_N Rising Edge Detect Interrupt Status 0 = ssi_ssr_intr
                                                     interrupt is not active after masking 1 = ssi_ssr_intr
                                                     interrupt is active after masking                                         */
    } isr_b;
  } ;
  
  union {
    __IM  uint32_t risr;                        /*!< (@ 0x00000034) Raw Interrupt Status Register                              */
    
    struct {
      __IM  uint32_t txeir      : 1;            /*!< [0..0] Transmit FIFO Empty Raw Interrupt Status 0 = ssi_txe_intr
                                                     interrupt is not active prior to masking 1 = ssi_txe_intr
                                                     interrupt is active prior to masking                                      */
      __IM  uint32_t txoir      : 1;            /*!< [1..1] Transmit FIFO Overflow Raw Interrupt Status 0 = ssi_txo_intr
                                                     interrupt is not active prior to masking 1 = ssi_txo_intr
                                                     interrupt is active prior to masking                                      */
      __IM  uint32_t rxuir      : 1;            /*!< [2..2] Receive FIFO Underflow Raw Interrupt Status 0 = ssi_rxu_intr
                                                     interrupt is not active prior to masking 1 = ssi_rxu_intr
                                                     interrupt is active prior to masking                                      */
      __IM  uint32_t rxoir      : 1;            /*!< [3..3] Receive FIFO Overflow Raw Interrupt Status 0 = ssi_rxo_intr
                                                     interrupt is not active prior to masking 1 = ssi_rxo_intr
                                                     interrupt is active prior to masking                                      */
      __IM  uint32_t rxfir      : 1;            /*!< [4..4] Receive FIFO Full Raw Interrupt Status 0 = ssi_rxf_intr
                                                     interrupt is not active prior to masking 1 = ssi_rxf_intr
                                                     interrupt is full prior to masking                                        */
      __IM  uint32_t mstir      : 1;            /*!< [5..5] Multi-Master Contention Raw Interrupt Status. This bit
                                                     field is not present if the deice is a slave. 0 = ssi_mst_intr
                                                     interrupt not active prior to masking 1 = ssi_mst_intr
                                                     interrupt is active prior to masking                                      */
      __IM  uint32_t txuir      : 1;            /*!< [6..6] Transmit FIFO Under Flow Raw Interrupt Status 0 = ssi_txu_intr
                                                     interrupt is not active prior to masking 1 = ssi_txu_intr
                                                     interrupt is active prior to masking                                      */
      __IM  uint32_t ssrir      : 1;            /*!< [7..7] SS_N Rising Edge Detect Raw Interrupt Status 0 = ssi_ssr_intr
                                                     interrupt is not active prior to masking 1 = ssi_ssr_intr
                                                     interrupt is active prior to masking                                      */
    } risr_b;
  } ;
  
  union {
    __IM  uint32_t txoicr;                      /*!< (@ 0x00000038) Transmit FIFO Overflow Interrupt Clear Register            */
    
    struct {
      __IM  uint32_t txoicr     : 1;            /*!< [0..0] Clear Transmit FIFO Overflow Interrupt. This register
                                                     reflects the status of the interrupt. A read from this
                                                     register clears the ssi_txo_intr interrupt; writing has
                                                     no effect.                                                                */
    } txoicr_b;
  } ;
  
  union {
    __IM  uint32_t rxoicr;                      /*!< (@ 0x0000003C) Receive FIFO Overflow Interrupt Clear Register             */
    
    struct {
      __IM  uint32_t rxoicr     : 1;            /*!< [0..0] Clear Receive FIFO Overflow Interrupt. This register
                                                     reflects the status of the interrupt. A read from this
                                                     register clears the ssi_rxo_intr interrupt; writing has
                                                     no effect.                                                                */
    } rxoicr_b;
  } ;
  
  union {
    __IM  uint32_t rxuicr;                      /*!< (@ 0x00000040) Receive FIFO Underflow Interrupt Clear Register            */
    
    struct {
      __IM  uint32_t rxuicr     : 1;            /*!< [0..0] Clear Receive FIFO Underflow Interrupt. This register
                                                     reflects the status of the interrupt. A read from this
                                                     register clears the ssi_rxu_intr interrupt; writing has
                                                     no effect.                                                                */
    } rxuicr_b;
  } ;
  
  union {
    __IM  uint32_t msticr;                      /*!< (@ 0x00000044) Multi-Master Interrupt Clear Register                      */
    
    struct {
      __IM  uint32_t msticr     : 1;            /*!< [0..0] Clear Multi-Master Contention Interrupt. This register
                                                     reflects the status of the interrupt. A read from this
                                                     register clears the ssi_mst_intr interrupt; writing has
                                                     no effect.                                                                */
    } msticr_b;
  } ;
  
  union {
    __IM  uint32_t icr;                         /*!< (@ 0x00000048) Interrupt Clear Register                                   */
    
    struct {
      __IM  uint32_t icr        : 1;            /*!< [0..0] Clear Interrupts. This register is set if any of the
                                                     interrupts below are active. A read clears the ssi_txu_intr,
                                                     ssi_txo_intr, ssi_rxu_intr, ssi_rxo_intr, and ssi_ssr_intr
                                                     interrupts. Writing to this register has no effect.                       */
    } icr_b;
  } ;
  
  union {
    __IOM uint32_t dmacr;                       /*!< (@ 0x0000004C) DMA Control Register                                       */
    
    struct {
      __IOM uint32_t rdmae      : 1;            /*!< [0..0] Receive DMA Enable. This bit enables/disables the receive
                                                     FIFO DMA channel 0 : Receive DMA disabled 1 : Receive DMA
                                                     enabled                                                                   */
      __IOM uint32_t tdmae      : 1;            /*!< [1..1] Transmit DMA Enable. This bit enables/disables the transmit
                                                     FIFO DMA channel. 0 : Transmit DMA disabled 1 : Transmit
                                                     DMA enabled                                                               */
    } dmacr_b;
  } ;
  
  union {
    __IOM uint32_t dmatdlr;                     /*!< (@ 0x00000050) DMA Transmit Data Level Register                           */
    
    struct {
      __IOM uint32_t dmatdl     : 8;            /*!< [7..0] Transmit Data Level. This bit field controls the level
                                                     at which a DMA request is made by the transmit logic. It
                                                     is equal to the watermark level; that is, the dma_tx_req
                                                     signal is generated when the number of valid data entries
                                                     in the transmit FIFO is equal to or below this field value,
                                                     and TDMAE = 1.                                                            */
    } dmatdlr_b;
  } ;
  
  union {
    __IOM uint32_t dmardlr;                     /*!< (@ 0x00000054) DMA Receive Data Level Register                            */
    
    struct {
      __IM  uint32_t            : 7;
      __IOM uint32_t dmardl     : 1;            /*!< [7..7] Receive Data Level. This bit field controls the level
                                                     at which a DMA request is made by the receive logic. The
                                                     watermark level = DMARDL+1; that is, dma_rx_req is generated
                                                     when the number of valid data entries in the receive FIFO
                                                     is equal to or above this field value + 1, and RDMAE=1.                   */
    } dmardlr_b;
  } ;
  
  union {
    __IM  uint32_t txuicr;                      /*!< (@ 0x00000058) Transmit FIFO Underflow Interrupt Clear Register           */
    
    struct {
      __IM  uint32_t txuicr     : 1;            /*!< [0..0] Clear Transmit FIFO Underflow Interrupt. This register
                                                     reflects the status of the interrupt. A read from this
                                                     register clears the ssi_txu_intr interrupt; writing has
                                                     no effect.                                                                */
    } txuicr_b;
  } ;
  
  union {
    __IM  uint32_t ssricr;                      /*!< (@ 0x0000005C) SS_N Rising Edge Detect Interrupt Clear Register           */
    
    struct {
      __IM  uint32_t ssiicr     : 1;            /*!< [0..0] Clear SS_N Rinsing Edge Detect Interrupt. This register
                                                     reflects the status of the interrupt. A read from this
                                                     register clears the ssi_ssr_intr interrupt; writing has
                                                     no effect.                                                                */
    } ssricr_b;
  } ;
  
  union {
    __IOM uint16_t dr;                          /*!< (@ 0x00000060) Data Register                                              */
    
    struct {
      __IOM uint16_t dr         : 16;           /*!< [15..0] Data register is a 16-bit read/write buffer for the
                                                     transmit/receive FIFOs. When the register is read, data
                                                     in the receive FIFO buffer is accessed. When it is written
                                                     to, data are moved into the transmit FIFO buffer; a write
                                                     can occur only when SSI_EN = 1. FIFOs are reset when SSI_EN
                                                     = 0.When writing to this register, you must right-justify
                                                     the data. Read data are automatically right-justified.
                                                     Read : Receive FIFO buffer Write : Transmit FIFO buffer                   */
    } dr_b;
  } ;
  __IM  uint16_t  RESERVED;
  __IM  uint32_t  RESERVED1[35];
  
  union {
    __IOM uint32_t rx_sample_dly;               /*!< (@ 0x000000F0) Rx Sample Delay Register                                   */
    
    struct {
      __IOM uint32_t rsd        : 8;            /*!< [7..0] Receive Data Sample Delay. This register is used to delay
                                                     the sample of the rxd input signal. Each value represents
                                                     a single ssi_clk delay on the sample of the rxd signal.
                                                     If this register is programmed with a value that exceed
                                                     the depth of the internal shift register, a zero delay
                                                     will be applied to the rxd sample.                                        */
    } rx_sample_dly_b;
  } ;
} SSI0_Type;                                    /*!< Size = 244 (0xf4)                                                         */



/* =========================================================================================================================== */
/* ================                                           I2C0                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief I2C with 7-bit/10-bit SS/FS/HS mode in master and slave mode transmission (I2C0)
  */

typedef struct {                                /*!< (@ 0x40044000) I2C0 Structure                                             */
  
  union {
    __IOM uint32_t con;                         /*!< (@ 0x00000000) I2C Control Register                                       */
    
    struct {
      __IOM uint32_t mst_mod    : 1;            /*!< [0..0] This bit controls whether the I2C Module master is enabled.        */
      __IOM uint32_t spd        : 2;            /*!< [2..1] These bits control at which speed the I2C Module operates.         */
      __IOM uint32_t slv_10bit_addr : 1;        /*!< [3..3] When acting as a slave, this bit controls whether the
                                                     I2C Module responds to 7- or 10-bit addresses.                            */
      __IOM uint32_t mst_10bit_addr : 1;        /*!< [4..4] This bit controls whether the I2C Module starts its transfers
                                                     in 7- or 10-bit addressing mode when acting as a master.                  */
      __IOM uint32_t rstrt_en   : 1;            /*!< [5..5] This bit determines whether RESTART conditions may be
                                                     sent when acting as a master.                                             */
      __IOM uint32_t slv_dis    : 1;            /*!< [6..6] This bit controls whether I2C has its slave 0 disabled.            */
      __IOM uint32_t slv_dis_1  : 1;            /*!< [7..7] This bit controls whether I2C has its slave 1 disabled.            */
    } con_b;
  } ;
  
  union {
    __IOM uint32_t tar;                         /*!< (@ 0x00000004) I2C Target Address Register                                */
    
    struct {
      __IOM uint32_t tar        : 10;           /*!< [9..0] This is the target address for any master transaction.             */
      __IOM uint32_t gc_start_byte : 1;         /*!< [10..10] If bit 11 (SPECIAL) is set to 1, then this bit indicates
                                                     whether a General Call or START byte command is to be performed
                                                     by the I2C Module. 0: General Call 1: START BYTE                          */
      __IOM uint32_t spec       : 1;            /*!< [11..11] This bit indicates whether software performs a General
                                                     Call or START BYTE command.                                               */
      __IOM uint32_t tar_10bit_addr : 1;        /*!< [12..12] This bit controls whether the I2C Module starts its
                                                     transfers in 7-or 10-bit addressing mode when acting as
                                                     a master.                                                                 */
    } tar_b;
  } ;
  
  union {
    __IOM uint32_t sar;                         /*!< (@ 0x00000008) I2C Slave Address Register                                 */
    
    struct {
      __IOM uint32_t sar        : 10;           /*!< [9..0] The sar holds the slave address when the I2C is operating
                                                     as a slave.                                                               */
    } sar_b;
  } ;
  
  union {
    __IOM uint32_t hs_maddr;                    /*!< (@ 0x0000000C) I2C High Speed Master Code Address Register                */
    
    struct {
      __IOM uint32_t hs_maddr   : 3;            /*!< [2..0] This bit field holds the value of the I2C HS mode master
                                                     code                                                                      */
    } hs_maddr_b;
  } ;
  
  union {
    __IOM uint32_t dat_cmd;                     /*!< (@ 0x00000010) I2C Data Buffer and Command Register                       */
    
    struct {
      __IOM uint32_t dat        : 8;            /*!< [7..0] This register contains the data to be transmitted or
                                                     received on the I2C bus.                                                  */
      __OM  uint32_t cmd        : 1;            /*!< [8..8] This bit controls whether a read or a write is performed.          */
      __OM  uint32_t stp        : 1;            /*!< [9..9] This bit controls whether a STOP is issued after the
                                                     byte is sent or received.                                                 */
      __OM  uint32_t rstrt      : 1;            /*!< [10..10] This bit controls whether a RESTART is issued before
                                                     the byte is sent or received.                                             */
      __OM  uint32_t null_dat   : 1;            /*!< [11..11] This bit controls whether to transfer slave address
                                                     only.                                                                     */
    } dat_cmd_b;
  } ;
  
  union {
    __IOM uint32_t ss_scl_hcnt;                 /*!< (@ 0x00000014) Standard Speed I2C Clock SCL High Count Register           */
    
    struct {
      __IOM uint32_t hcnt       : 16;           /*!< [15..0] This register sets the SCL clock high-period count for
                                                     standard speed.                                                           */
    } ss_scl_hcnt_b;
  } ;
  
  union {
    __IOM uint32_t ss_scl_lcnt;                 /*!< (@ 0x00000018) Standard Speed I2C Clock SCL Low Count Register            */
    
    struct {
      __IOM uint32_t lcnt       : 16;           /*!< [15..0] This register sets the SCL clock low period count for
                                                     standard speed.                                                           */
    } ss_scl_lcnt_b;
  } ;
  
  union {
    __IOM uint32_t fs_scl_hcnt;                 /*!< (@ 0x0000001C) Fast Speed I2C Clock SCL High Count Register               */
    
    struct {
      __IOM uint32_t hcnt       : 16;           /*!< [15..0] This register sets the SCL clock high-period count for
                                                     fast speed.                                                               */
    } fs_scl_hcnt_b;
  } ;
  
  union {
    __IOM uint32_t fs_scl_lcnt;                 /*!< (@ 0x00000020) Fast Speed I2C Clock SCL Low Count Register                */
    
    struct {
      __IOM uint32_t lcnt       : 16;           /*!< [15..0] This register sets the SCL clock low period count for
                                                     fast speed.                                                               */
    } fs_scl_lcnt_b;
  } ;
  
  union {
    __IOM uint32_t hs_scl_hcnt;                 /*!< (@ 0x00000024) High Speed I2C Clock SCL High Count Register               */
    
    struct {
      __IOM uint32_t hcnt       : 16;           /*!< [15..0] This register sets the SCL clock high period count for
                                                     high speed.                                                               */
    } hs_scl_hcnt_b;
  } ;
  
  union {
    __IOM uint32_t hs_scl_lcnt;                 /*!< (@ 0x00000028) High Speed I2C Clock SCL Low Count Register                */
    
    struct {
      __IOM uint32_t lcnt       : 16;           /*!< [15..0] This register sets the SCL clock low period count for
                                                     high speed.                                                               */
    } hs_scl_lcnt_b;
  } ;
  
  union {
    __IM  uint32_t intr_stat;                   /*!< (@ 0x0000002C) I2C Interrupt Status Register                              */
    
    struct {
      __IM  uint32_t rx_under   : 1;            /*!< [0..0] Set if the processor attempts to read the receive buffer
                                                     when it is empty by reading from the data_cmd register.                   */
      __IM  uint32_t rx_over    : 1;            /*!< [1..1] Set if the receive buffer is completely filled to RX_BUFFER_DEPTH
                                                     and an additional byte is received from an external I2C
                                                     device.                                                                   */
      __IM  uint32_t rx_full    : 1;            /*!< [2..2] Set when the receive buffer reaches or goes above the
                                                     rx_tl threshold in the rx_tl register                                     */
      __IM  uint32_t tx_over    : 1;            /*!< [3..3] Set during transmit if the transmit buffer is filled
                                                     to TX_BUFFER_DEPTH and the processor attempts to issue
                                                     another I2C command by writing to the DATA_CMD register.                  */
      __IM  uint32_t tx_empty   : 1;            /*!< [4..4] This bit is set to 1 when the transmit buffer is at or
                                                     below the threshold value set in the TX_TL register.                      */
      __IM  uint32_t rd_req     : 1;            /*!< [5..5] This bit is set to 1 when I2C Module is acting as a slave
                                                     and another I2C master is attempting to read data from
                                                     I2C Module.                                                               */
      __IM  uint32_t tx_abrt    : 1;            /*!< [6..6] This bit indicates if I2C Module, as an I2C transmitter,
                                                     is unable to complete the intended actions on the contents
                                                     of the transmit FIFO.                                                     */
      __IM  uint32_t rx_done    : 1;            /*!< [7..7] When the I2C Module is acting as a slave-transmitter,
                                                     this bit is set to 1 if the master does not acknowledge
                                                     a transmitted byte. This occurs on the last byte of the
                                                     transmission, indicating that the transmission is done.                   */
      __IM  uint32_t act        : 1;            /*!< [8..8] This bit captures I2C Module activity and stays set until
                                                     it is cleared. There are four ways to clear it: - Disabling
                                                     the I2C Module - Reading the CLR_ACTIVITY register - Reading
                                                     the CLR_INTR register - System reset Once this bit is set,
                                                     it stays set unless one of the four methods is used to
                                                     clear it. Even if the I2C Module module is idle, this bit
                                                     remains set until cleared, indicating that there was activity
                                                     on the bus.                                                               */
      __IM  uint32_t stp_det    : 1;            /*!< [9..9] Indicates whether a STOP condition has occurred on the
                                                     I2C interface regardless of whether I2C Module is operating
                                                     in slave or master mode.                                                  */
      __IM  uint32_t strt_det   : 1;            /*!< [10..10] Indicates whether a START or RESTART condition has
                                                     occurred on the I2C interface regardless of whether I2C
                                                     Module is operating in slave or master mode.                              */
      __IM  uint32_t gen_call   : 1;            /*!< [11..11] Set only when a General Call address is received and
                                                     it is acknowledged.                                                       */
      __IM  uint32_t addr0_match : 1;           /*!< [12..12] Indicates whether an address matches with slave address
                                                     0 when acting as a slave.                                                 */
      __IM  uint32_t addr1_match : 1;           /*!< [13..13] Indicates whether an address matches with slave address
                                                     1 when acting as a slave.                                                 */
      __IM  uint32_t ms_code_det : 1;           /*!< [14..14] Indicates whether master code is detected.                       */
      __IM  uint32_t dma_i2c_done : 1;          /*!< [15..15] Indicates whether I2C DMA operation is done.                     */
    } intr_stat_b;
  } ;
  
  union {
    __IOM uint32_t intr_msk;                    /*!< (@ 0x00000030) I2C Interrupt Mask Register                                */
    
    struct {
      __IOM uint32_t rx_under   : 1;            /*!< [0..0] Correspond to intr_sts                                             */
      __IOM uint32_t rx_over    : 1;            /*!< [1..1] Correspond to intr_sts                                             */
      __IOM uint32_t rx_full    : 1;            /*!< [2..2] Correspond to intr_sts                                             */
      __IOM uint32_t tx_over    : 1;            /*!< [3..3] Correspond to intr_sts                                             */
      __IOM uint32_t tx_empty   : 1;            /*!< [4..4] Correspond to intr_sts                                             */
      __IOM uint32_t rd_req     : 1;            /*!< [5..5] Correspond to intr_sts                                             */
      __IOM uint32_t tx_abrt    : 1;            /*!< [6..6] Correspond to intr_sts                                             */
      __IOM uint32_t rx_done    : 1;            /*!< [7..7] Correspond to intr_sts                                             */
      __IOM uint32_t act        : 1;            /*!< [8..8] Correspond to intr_sts                                             */
      __IOM uint32_t stp_det    : 1;            /*!< [9..9] Correspond to intr_sts                                             */
      __IOM uint32_t strt_det   : 1;            /*!< [10..10] Correspond to intr_sts                                           */
      __IOM uint32_t gen_call   : 1;            /*!< [11..11] Correspond to intr_sts                                           */
      __IOM uint32_t addr0_match : 1;           /*!< [12..12] Correspond to intr_sts                                           */
      __IOM uint32_t addr1_match : 1;           /*!< [13..13] Correspond to intr_sts                                           */
      __IOM uint32_t ms_code_det : 1;           /*!< [14..14] Correspond to intr_sts                                           */
      __IOM uint32_t dma_i2c_done : 1;          /*!< [15..15] Correspond to intr_sts                                           */
    } intr_msk_b;
  } ;
  
  union {
    __IM  uint32_t raw_intr_stat;               /*!< (@ 0x00000034) I2C Raw Interrupt Status Register                          */
    
    struct {
      __IM  uint32_t rx_under   : 1;            /*!< [0..0] Set if the processor attempts to read the receive buffer
                                                     when it is empty by reading from the data_cmd register.                   */
      __IM  uint32_t rx_over    : 1;            /*!< [1..1] Set if the receive buffer is completely filled to RX_BUFFER_DEPTH
                                                     and an additional byte is received from an external I2C
                                                     device.                                                                   */
      __IM  uint32_t rx_full    : 1;            /*!< [2..2] Set when the receive buffer reaches or goes above the
                                                     rx_tl threshold in the rx_tl register                                     */
      __IM  uint32_t tx_over    : 1;            /*!< [3..3] Set during transmit if the transmit buffer is filled
                                                     to TX_BUFFER_DEPTH and the processor attempts to issue
                                                     another I2C command by writing to the DATA_CMD register.                  */
      __IM  uint32_t tx_empty   : 1;            /*!< [4..4] This bit is set to 1 when the transmit buffer is at or
                                                     below the threshold value set in the TX_TL register.                      */
      __IM  uint32_t rd_req     : 1;            /*!< [5..5] This bit is set to 1 when I2C Module is acting as a slave
                                                     and another I2C master is attempting to read data from
                                                     I2C Module.                                                               */
      __IM  uint32_t tx_abrt    : 1;            /*!< [6..6] This bit indicates if I2C Module, as an I2C transmitter,
                                                     is unable to complete the intended actions on the contents
                                                     of the transmit FIFO.                                                     */
      __IM  uint32_t rx_done    : 1;            /*!< [7..7] When the I2C Module is acting as a slave-transmitter,
                                                     this bit is set to 1 if the master does not acknowledge
                                                     a transmitted byte. This occurs on the last byte of the
                                                     transmission, indicating that the transmission is done.                   */
      __IM  uint32_t act        : 1;            /*!< [8..8] This bit captures I2C Module activity and stays set until
                                                     it is cleared. There are four ways to clear it: - Disabling
                                                     the I2C Module - Reading the CLR_ACTIVITY register - Reading
                                                     the CLR_INTR register - System reset Once this bit is set,
                                                     it stays set unless one of the four methods is used to
                                                     clear it. Even if the I2C Module module is idle, this bit
                                                     remains set until cleared, indicating that there was activity
                                                     on the bus.                                                               */
      __IM  uint32_t stp_det    : 1;            /*!< [9..9] Indicates whether a STOP condition has occurred on the
                                                     I2C interface regardless of whether I2C Module is operating
                                                     in slave or master mode.                                                  */
      __IM  uint32_t strt_det   : 1;            /*!< [10..10] Indicates whether a START or RESTART condition has
                                                     occurred on the I2C interface regardless of whether I2C
                                                     Module is operating in slave or master mode.                              */
      __IM  uint32_t gen_call   : 1;            /*!< [11..11] Set only when a General Call address is received and
                                                     it is acknowledged.                                                       */
      __IM  uint32_t addr0_match : 1;           /*!< [12..12] Indicates whether an address matches with slave address
                                                     0 when acting as a slave.                                                 */
      __IM  uint32_t addr1_match : 1;           /*!< [13..13] Indicates whether an address matches with slave address
                                                     1 when acting as a slave.                                                 */
      __IM  uint32_t ms_code_det : 1;           /*!< [14..14] Indicates whether master code is detected.                       */
      __IM  uint32_t dma_i2c_done : 1;          /*!< [15..15] Indicates whether I2C DMA operation is done.                     */
    } raw_intr_stat_b;
  } ;
  
  union {
    __IOM uint32_t rx_tl;                       /*!< (@ 0x00000038) I2C Receive FIFO Threshold Register                        */
    
    struct {
      __IOM uint32_t rx_tl      : 8;            /*!< [7..0] Receive FIFO Threshold Level                                       */
    } rx_tl_b;
  } ;
  
  union {
    __IOM uint32_t tx_tl;                       /*!< (@ 0x0000003C) I2C Transmit FIFO Threshold Register                       */
    
    struct {
      __IOM uint32_t tx_tl      : 8;            /*!< [7..0] Transmit FIFO Threshold Level                                      */
    } tx_tl_b;
  } ;
  
  union {
    __IOM uint32_t clr_intr;                    /*!< (@ 0x00000040) Clear Combined and Individual Interrupt Register           */
    
    struct {
      __IM  uint32_t clr_intr   : 1;            /*!< [0..0] Read this register to clear the combined interrupt, all
                                                     individual interrupts, and the TX_ABRT_SOURCE register.                   */
    } clr_intr_b;
  } ;
  
  union {
    __IOM uint32_t clr_rx_under;                /*!< (@ 0x00000044) Clear RX_UNDER Interrupt Register                          */
    
    struct {
      __IM  uint32_t clr_rx_under : 1;          /*!< [0..0] Read this register to clear the rx_under interrupt (bit
                                                     0) of the raw_intr_stat register                                          */
    } clr_rx_under_b;
  } ;
  
  union {
    __IOM uint32_t clr_rx_over;                 /*!< (@ 0x00000048) Clear RX_OVER Interrupt Register                           */
    
    struct {
      __IM  uint32_t clr_rx_over : 1;           /*!< [0..0] Read this register to clear the rx_over interrupt (bit
                                                     1) of the raw_intr_stat register                                          */
    } clr_rx_over_b;
  } ;
  
  union {
    __IOM uint32_t clr_tx_over;                 /*!< (@ 0x0000004C) Clear TX_OVER Interrupt Register                           */
    
    struct {
      __IM  uint32_t clr_tx_over : 1;           /*!< [0..0] Read this register to clear the tx_over interrupt (bit
                                                     3) of the raw_intr_stat register.                                         */
    } clr_tx_over_b;
  } ;
  
  union {
    __IOM uint32_t clr_rd_req;                  /*!< (@ 0x00000050) Clear RD_REQ Interrupt Register                            */
    
    struct {
      __IM  uint32_t clr_rd_req : 1;            /*!< [0..0] Read this register to clear the rd_req interrupt (bit
                                                     5) of the raw_intr_stat register                                          */
    } clr_rd_req_b;
  } ;
  
  union {
    __IOM uint32_t clr_tx_abrt;                 /*!< (@ 0x00000054) Clear TX_ABRT Interrupt Register                           */
    
    struct {
      __IM  uint32_t clr_tx_abrt : 1;           /*!< [0..0] Read this register to clear the tx_abrt interrupt (bit
                                                     6) of the raw_intr_stat register, and the tx_abrt_src register.This
                                                     also releases the tx fifo from the flushed/reset state,
                                                     allowing more writes to the TX FIFO. Refer to Bit 9 of
                                                     the tx_abrt_src register for an exception to clearing tx_abrt_src.        */
    } clr_tx_abrt_b;
  } ;
  
  union {
    __IOM uint32_t clr_rx_done;                 /*!< (@ 0x00000058) Clear RX_DONE Interrupt Register                           */
    
    struct {
      __IM  uint32_t clr_rx_done : 1;           /*!< [0..0] Read this register to clear the rx_done interrupt (bit
                                                     7) of the raw_intr_stat register                                          */
    } clr_rx_done_b;
  } ;
  
  union {
    __IOM uint32_t clr_act;                     /*!< (@ 0x0000005C) Clear ACTIVITY Interrupt Register                          */
    
    struct {
      __IM  uint32_t clr_act    : 1;            /*!< [0..0] Reading this register clears the activity interrupt if
                                                     the I2C is not active anymore. If the I2C module is still
                                                     active on the bus, the activity interrupt bit continues
                                                     to be set. It is automatically cleared by hardware if the
                                                     module is disabled and if there is no further activity
                                                     on the bus. The value read from this register to get status
                                                     of the activity interrupt (bit 8) of the raw_intr_stat
                                                     register.                                                                 */
    } clr_act_b;
  } ;
  
  union {
    __IOM uint32_t clr_stp_det;                 /*!< (@ 0x00000060) Clear STOP_DET Interrupt Register                          */
    
    struct {
      __IM  uint32_t clr_stp_det : 1;           /*!< [0..0] Read this register to clear the stop_det interrupt (bit
                                                     9) of the raw_intr_stat register.                                         */
    } clr_stp_det_b;
  } ;
  
  union {
    __IOM uint32_t clr_strt_det;                /*!< (@ 0x00000064) Clear START_DET Interrupt Register                         */
    
    struct {
      __IM  uint32_t clr_strt_det : 1;          /*!< [0..0] Read this register to clear the start_det interrupt (bit
                                                     10) of the raw_intr_stat register.                                        */
    } clr_strt_det_b;
  } ;
  
  union {
    __IOM uint32_t clr_gen_call;                /*!< (@ 0x00000068) Clear GEN_CALL Interrupt Register                          */
    
    struct {
      __IM  uint32_t clr_gen_call : 1;          /*!< [0..0] Read this register to clear the gen_call interrupt (bit
                                                     11) of raw_intr_stat register                                             */
    } clr_gen_call_b;
  } ;
  
  union {
    __IOM uint32_t enable;                      /*!< (@ 0x0000006C) I2C Enable Register                                        */
    
    struct {
      __IOM uint32_t en         : 1;            /*!< [0..0] Controls whether the I2C Module is enabled.                        */
      __IOM uint32_t abrt       : 1;            /*!< [1..1] Abort I2C current transfer is done w/o flush Tx/Rx FIFO            */
    } enable_b;
  } ;
  
  union {
    __IOM uint32_t sts;                         /*!< (@ 0x00000070) I2C Status Reigster                                        */
    
    struct {
      __IM  uint32_t act        : 1;            /*!< [0..0] I2C Activity Status.                                               */
      __IM  uint32_t tfnf       : 1;            /*!< [1..1] Transmit FIFO Not Full. Set when the transmit FIFO contains
                                                     one or more empty locations, and is cleared when the FIFO
                                                     is full.                                                                  */
      __IM  uint32_t tfe        : 1;            /*!< [2..2] Transmit FIFO Completely Empty. When the transmit FIFO
                                                     is completely empty, this bit is set. When it contains
                                                     one or morevalid entries, this bit is cleared. This bit
                                                     field does not request an interrupt.                                      */
      __IM  uint32_t rfne       : 1;            /*!< [3..3] Receive FIFO Not Empty. This bit is set when the receive
                                                     FIFO contains one or more entries; it is cleared when the
                                                     receive FIFO is empty.                                                    */
      __IM  uint32_t rff        : 1;            /*!< [4..4] Receive FIFO CompletelyFull. When the receive FIFO iscompletely
                                                     full, this bit is set. When the receive FIFO contains one
                                                     or more empty location, this bit is cleared.                              */
      __IM  uint32_t mst_act    : 1;            /*!< [5..5] Master FSM Activity Status                                         */
      __IM  uint32_t slv_act    : 1;            /*!< [6..6] Slave FSM Activity Status                                          */
      __IM  uint32_t mst_hold_tx_empty : 1;     /*!< [7..7] I2C module is holding I2C bus low (clock stretch) because
                                                     of TX FIFO empty in master mode.                                          */
      __IM  uint32_t mst_hold_rx_full : 1;      /*!< [8..8] I2C module is holding I2C bus low (clock stretch) because
                                                     of RX FIFO full in master mode.                                           */
      __IM  uint32_t slv_hold_tx_empty : 1;     /*!< [9..9] I2C module is holding I2C bus low (clock stretch) because
                                                     of TX FIFO empty in slave mode.                                           */
      __IM  uint32_t slv_hold_rx_full : 1;      /*!< [10..10] I2C module is holding I2C bus low (clock stretch) because
                                                     of RX FIFO full in slave mode.                                            */
      __IOM uint32_t bus_sts    : 2;            /*!< [12..11] Show current I2C bus status                                      */
    } sts_b;
  } ;
  
  union {
    __IM  uint32_t txflr;                       /*!< (@ 0x00000074) I2C Transmit FIFO Level Register                           */
    
    struct {
      __IM  uint32_t txflr      : 5;            /*!< [4..0] Transmit FIFO Level. Contains the number of valid data
                                                     entries in the transmit FIFO.                                             */
    } txflr_b;
  } ;
  
  union {
    __IM  uint32_t rxflr;                       /*!< (@ 0x00000078) I2C Receive FIFO Level Register                            */
    
    struct {
      __IM  uint32_t rxflr      : 5;            /*!< [4..0] Receive FIFO Level. Contains the number of valid data
                                                     entries in the receive FIFO.                                              */
    } rxflr_b;
  } ;
  
  union {
    __IOM uint32_t sda_hold;                    /*!< (@ 0x0000007C) I2C SDA Hold Time Length Register                          */
    
    struct {
      __IOM uint32_t sda_hold   : 16;           /*!< [15..0] Sets the required SDA hold timein units of clk period.            */
    } sda_hold_b;
  } ;
  
  union {
    __IOM uint32_t tx_abrt_src;                 /*!< (@ 0x00000080) I2C Transmit Abort Source Register                         */
    
    struct {
      __IM  uint32_t addr_7bit_nack : 1;        /*!< [0..0] 1: Master is in 7-bit addressing mode and the address
                                                     sent was not acknowledged by any slave.                                   */
      __IM  uint32_t addr1_10bit_nack : 1;      /*!< [1..1] 1: Master is in 10-bit address mode and the first 10-bit
                                                     address byte was not acknowledged by any slave.                           */
      __IM  uint32_t addr2_10bit_nack : 1;      /*!< [2..2] 1: Master is in 10-bit address mode and the second address
                                                     byte of the 10-bit address was not acknowledged by any
                                                     slave.                                                                    */
      __IM  uint32_t txdat_nack : 1;            /*!< [3..3] 1: This is a master-mode only bit. Master has received
                                                     an acknowledgement for the address, but when it sent data
                                                     byte(s) following the address, it did not receive an acknowledge
                                                     from the remote slave(s).                                                 */
      __IM  uint32_t gcall_nack : 1;            /*!< [4..4] 1: I2C Module in master mode sent a General Call and
                                                     no slave on the bus acknowledged the General Call.                        */
      __IM  uint32_t gcall_rd   : 1;            /*!< [5..5] 1: I2C Module in master mode sent a General Call but
                                                     the user programmed the byte following the General Call
                                                     to be a read from the bus (dat_cmd[9] is set to 1).                       */
      __IM  uint32_t hs_ackdet  : 1;            /*!< [6..6] 1: Master is in High Speed mode and the High Speed Master
                                                     code was acknowledged (wrong behavior).                                   */
      __IM  uint32_t sbyte_ackdet : 1;          /*!< [7..7] 1: Master has sent a START Byte and the START Byte was
                                                     acknowledged (wrong behavior).                                            */
      __IM  uint32_t norstrt_hs : 1;            /*!< [8..8] 1: The restart is disabled (rstrt_en bit (con[5]) = 0)
                                                     and the user is trying to use the master to transfer data
                                                     in High Speed mode.                                                       */
      __IM  uint32_t norstrt_sbyte : 1;         /*!< [9..9] 1: The restart is disabled (rstrt bit con[5]) = 0) and
                                                     the user is trying to send a START Byte.                                  */
      __IM  uint32_t norstrt_10bit_rd : 1;      /*!< [10..10] 1: The restart is disabled (rstrt_en bit (con[5]) =
                                                     0) and the master sends a read command in 10-bit addressing
                                                     mode.                                                                     */
      __IM  uint32_t mst_dis    : 1;            /*!< [11..11] 1: User tries to initiate a Master operation with the
                                                     Master mode disabled.                                                     */
      __IM  uint32_t arb_lost   : 1;            /*!< [12..12] 1: Master has lost arbitration, or if tx_abrt_src[14]
                                                     is also set, then the slave transmitter has lost arbitration.             */
      __IM  uint32_t slvflush_txfifo : 1;       /*!< [13..13] 1: Slave has received a read command and some data
                                                     exists in the TX FIFO so the slave issues a tx_abrt interrupt
                                                     to flush old data in TX FIFO.                                             */
      __IM  uint32_t slv_arblost : 1;           /*!< [14..14] 1: Slave lost the bus while transmitting data to a
                                                     remote master. Tx_abrt_src[12] is set at the same time.                   */
      __IM  uint32_t slvrd_intx : 1;            /*!< [15..15] 1: When the processor side responds to a slave mode
                                                     request for data to be transmitted to a remote master and
                                                     user writes a 1 in cmd(bit 8) of dat_cmd register.                        */
    } tx_abrt_src_b;
  } ;
  
  union {
    __IOM uint32_t slv_dat_nack;                /*!< (@ 0x00000084) I2C Generate Slave Data NACK Register                      */
    
    struct {
      __IOM uint32_t slv_dat_nack : 1;          /*!< [0..0] Generate NACK. This NACK generation only occurs when
                                                     I2C Module is a slavereceiver. If this register is set
                                                     to a value of 1, it can only generate a NACK after a data
                                                     byte is received; hence, the data transfer is aborted and
                                                     the data received is not pushed to the receive buffer.
                                                     When the register is set to a value of 0, it generates
                                                     NACK/ACK, depending on normal criteria.                                   */
    } slv_dat_nack_b;
  } ;
  
  union {
    __IOM uint32_t dma_cr;                      /*!< (@ 0x00000088) I2C DMA Control Reigster                                   */
    
    struct {
      __IOM uint32_t rdmae      : 1;            /*!< [0..0] Receive DMA Enable. This bit enables/disables the receive
                                                     FIFO DMA channel.                                                         */
      __IOM uint32_t tdmae      : 1;            /*!< [1..1] Transmit DMA Enable. This bit enables/disables the transmit
                                                     FIFO DMA channel.                                                         */
    } dma_cr_b;
  } ;
  
  union {
    __IOM uint32_t dma_tdlr;                    /*!< (@ 0x0000008C) I2C DMA Transmit Data Level Register                       */
    
    struct {
      __IOM uint32_t tdlr       : 4;            /*!< [3..0] Transmit Data Level. This bit field controls the level
                                                     at which a DMA request is made by the transmit logic. It
                                                     is equal to the watermark level; that is, the dma_tx_req
                                                     signal is generated when the number of valid data entries
                                                     in the transmit FIFO is equal to or below this field value,
                                                     and tdmae= 1.                                                             */
    } dma_tdlr_b;
  } ;
  
  union {
    __IOM uint32_t dma_rdlr;                    /*!< (@ 0x00000090) I2C DMA Receive Data Level Register                        */
    
    struct {
      __IOM uint32_t rdlr       : 4;            /*!< [3..0] Receive Data Level.                                                */
    } dma_rdlr_b;
  } ;
  
  union {
    __IOM uint32_t sda_setup;                   /*!< (@ 0x00000094) I2C SDA Setup Register                                     */
    
    struct {
      __IOM uint32_t sda_setup  : 8;            /*!< [7..0] SDA Setup. It is recommended that if the required delay
                                                     is 1000ns, then for an clk frequency of 10 MHz, sda_setup
                                                     should be programmed to a value of 11. sda_setup must be
                                                     programmed with a minimum value of 2.                                     */
    } sda_setup_b;
  } ;
  
  union {
    __IOM uint32_t ack_gen_call;                /*!< (@ 0x00000098) I2C ACK General Call Register                              */
    
    struct {
      __IOM uint32_t ack_gen_call : 1;          /*!< [0..0] ACK General Call. When set to 1, I2C Module responds
                                                     with a ACK (by asserting data_oe) when it receives a General
                                                     Call. When set to 0, the I2C Module does not generate General
                                                     Call interrupts.                                                          */
    } ack_gen_call_b;
  } ;
  
  union {
    __IOM uint32_t en_sts;                      /*!< (@ 0x0000009C) I2C Enable Status Register                                 */
    
    struct {
      __IM  uint32_t en         : 1;            /*!< [0..0] Enable Status.                                                     */
      __IM  uint32_t slv_dis_in_busy : 1;       /*!< [1..1] Slave Disabled While Busy (Transmit, Receive). This bit
                                                     indicates if a potential or active Slave operation has
                                                     been aborted due to the setting of the ENABLE register
                                                     from 1 to 0.                                                              */
      __IM  uint32_t slv_rx_dat_lost : 1;       /*!< [2..2] Slave Received Data Lost. This bit indicates if a Slave-Receiver
                                                     operation has been aborted with at least one data byte
                                                     received from an I2C transfer due to the setting of enable
                                                     from 1 to 0.                                                              */
      __IM  uint32_t dma_dis_sts : 2;           /*!< [4..3] DMA_DISABLE_WHILE_BUSY. 00: No ill disable event is active
                                                     01: I2C is disable while busy in legacy mode 10: I2C is
                                                     disable while busy in DMA mode 11: I2C is disable while
                                                     busy in Descriptor mode                                                   */
    } en_sts_b;
  } ;
  
  union {
    __IOM uint32_t dma_cmd;                     /*!< (@ 0x000000A0) I2C DMA Command Register                                   */
    
    struct {
      __IOM uint32_t en         : 1;            /*!< [0..0] Set to enable DMA mode.                                            */
      __IM  uint32_t            : 4;
      __IOM uint32_t cmd        : 1;            /*!< [5..5] This bit controls whether a read or a write is performed.
                                                     This bit does not control the direction when the I2C Module
                                                     acts as a slave. It controls only the direction when it
                                                     acts as a master. 1 = Read 0 = Write                                      */
      __IOM uint32_t stp        : 1;            /*!< [6..6] This bit controls whether a STOP is issued after the
                                                     byte is sent or received.                                                 */
      __IOM uint32_t rstrt      : 1;            /*!< [7..7] This bit controls whether a RESTART is issued before
                                                     the byte is sent or received when DMA mode is enabled.                    */
    } dma_cmd_b;
  } ;
  
  union {
    __IOM uint32_t dma_len;                     /*!< (@ 0x000000A4) I2C DMA Transfer Data Length Register                      */
    
    struct {
      __IOM uint32_t len        : 16;           /*!< [15..0] DMA transfer data length(R/W)                                     */
      __IM  uint32_t tr_len     : 16;           /*!< [31..16] DMA mode transfer bytes(Read only)                               */
    } dma_len_b;
  } ;
  
  union {
    __IOM uint32_t dma_mod;                     /*!< (@ 0x000000A8) I2C DMA Mode Register                                      */
    
    struct {
      __IOM uint32_t dma_mod    : 2;            /*!< [1..0] DMA operation mode                                                 */
    } dma_mod_b;
  } ;
  
  union {
    __IOM uint32_t slp;                         /*!< (@ 0x000000AC) I2C Sleep Control Register                                 */
    
    struct {
      __IOM uint32_t clk_ctrl   : 1;            /*!< [0..0] I2C clock control, write 1 controller would gate I2C
                                                     clock until I2C slave is enable and reset synchronized
                                                     register procedure is done                                                */
      __IM  uint32_t slp_clk_gated : 1;         /*!< [1..1] I2C clock has been gated (Read Only)                               */
    } slp_b;
  } ;
  __IM  uint32_t  RESERVED[2];
  
  union {
    __IOM uint32_t dat_fltr_rsts_l;             /*!< (@ 0x000000B8) Data Filter Resistor Low Register                          */
    
    struct {
      __IOM uint32_t dat_fltr_rsts_l : 20;      /*!< [19..0] Data Filter Resistor Low                                          */
    } dat_fltr_rsts_l_b;
  } ;
  
  union {
    __IOM uint32_t dat_fltr_rsts_m;             /*!< (@ 0x000000BC) Data Filter Resistor Main Register                         */
    
    struct {
      __IOM uint32_t dat_fltr_rsts_m : 20;      /*!< [19..0] Data Filter Resistor Main                                         */
    } dat_fltr_rsts_m_b;
  } ;
  
  union {
    __IOM uint32_t clk_fltr_rsts_l;             /*!< (@ 0x000000C0) Clock Filter Resistor Low Register                         */
    
    struct {
      __IOM uint32_t clk_fltr_rsts_l : 20;      /*!< [19..0] Clock Filter Resistor Low                                         */
    } clk_fltr_rsts_l_b;
  } ;
  
  union {
    __IOM uint32_t clk_fltr_rsts_m;             /*!< (@ 0x000000C4) Clock Filter Resistor Main Register                        */
    
    struct {
      __IOM uint32_t clk_fltr_rsts_m : 20;      /*!< [19..0] Clock Filter Resistor Main                                        */
    } clk_fltr_rsts_m_b;
  } ;
  
  union {
    __IOM uint32_t dat_fltr_cap_l;              /*!< (@ 0x000000C8) Data Filter Capacitor Low Register                         */
    
    struct {
      __IOM uint32_t dat_fltr_cap_l : 20;       /*!< [19..0] Data Filter Capacitor Low                                         */
    } dat_fltr_cap_l_b;
  } ;
  
  union {
    __IOM uint32_t dat_fltr_cap_m;              /*!< (@ 0x000000CC) Data Filter Capacitor Main Register                        */
    
    struct {
      __IOM uint32_t dat_fltr_cap_m : 5;        /*!< [4..0] Data Filter Capacitor Main                                         */
    } dat_fltr_cap_m_b;
  } ;
  
  union {
    __IOM uint32_t clk_fltr_cap_l;              /*!< (@ 0x000000D0) Clock Filter Capacitor Low Register                        */
    
    struct {
      __IOM uint32_t clk_fltr_cap_l : 20;       /*!< [19..0] Clock Filter Capacitor Low                                        */
    } clk_fltr_cap_l_b;
  } ;
  
  union {
    __IOM uint32_t clk_fltr_cap_m;              /*!< (@ 0x000000D4) Clock Filter Capacitor Main Register                       */
    
    struct {
      __IOM uint32_t clk_fltr_cap_m : 5;        /*!< [4..0] Clock Filter Capacitor Main                                        */
    } clk_fltr_cap_m_b;
  } ;
  __IM  uint32_t  RESERVED1[3];
  
  union {
    __IOM uint32_t clr_addr_match;              /*!< (@ 0x000000E4) Clear I2C ADDR_MATCH Interrupt Register                    */
    
    struct {
      __IOM uint32_t clr_addr_match : 1;        /*!< [0..0] Clear address match interrupts raw status, and it's read
                                                     clear.                                                                    */
    } clr_addr_match_b;
  } ;
  
  union {
    __IOM uint32_t clr_dma_done;                /*!< (@ 0x000000E8) Clear I2C DMA_DONE Interrupt Register                      */
    
    struct {
      __IOM uint32_t clr_dma_done : 1;          /*!< [0..0] Clear dma_i2c_done_intr interrupts raw status, and it's
                                                     read clear.                                                               */
    } clr_dma_done_b;
  } ;
  
  union {
    __IOM uint32_t fltr;                        /*!< (@ 0x000000EC) I2C Bus Filter Register                                    */
    
    struct {
      __IOM uint32_t dig_fltr_deg : 4;          /*!< [3..0] I2C module digital filter degree                                   */
      __IM  uint32_t            : 4;
      __IOM uint32_t dig_fltr_en : 1;           /*!< [8..8] I2C module digital filter slection (enable)                        */
    } fltr_b;
  } ;
  __IM  uint32_t  RESERVED2;
  
  union {
    __IOM uint32_t sar1;                        /*!< (@ 0x000000F4) I2C Slave Address 1 Register                               */
    
    struct {
      __IOM uint32_t sar1       : 7;            /*!< [6..0] I2C Second Slave Address                                           */
    } sar1_b;
  } ;
  __IM  uint32_t  RESERVED3;
  
  union {
    __IM  uint32_t ver;                         /*!< (@ 0x000000FC) I2C Component Version Register                             */
    
    struct {
      __IM  uint32_t ver        : 32;           /*!< [31..0] I2C module version number                                         */
    } ver_b;
  } ;
} I2C0_Type;                                    /*!< Size = 256 (0x100)                                                        */



/* =========================================================================================================================== */
/* ================                                         SDIO_DEV                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief SDIO Device (SDIO_DEV)
  */

typedef struct {                                /*!< (@ 0x40050000) SDIO_DEV Structure                                         */
  __IM  uint32_t  RESERVED[40];
  
  union {
    __IOM uint32_t txbd_addr;                   /*!< (@ 0x000000A0) TX BD(Buffer Descriptor) Address Register                  */
    
    struct {
      __IOM uint32_t tx_bd_addr : 32;           /*!< [31..0] The base address of TXBD The value of this register
                                                     should be configure by CPU It should be 4 byte alignment
                                                     (Because TXBD Size is 8 Byte).                                            */
    } txbd_addr_b;
  } ;
  
  union {
    __IOM uint32_t txbd_num;                    /*!< (@ 0x000000A4) TX BD Number Register                                      */
    
    struct {
      __IOM uint32_t tx_bd_num  : 16;           /*!< [15..0] The Number of TXBD. Unit: Number The value of this register
                                                     should be configured at SDIO device HAL initialization                    */
    } txbd_num_b;
  } ;
  
  union {
    __IOM uint32_t txbd_wptr;                   /*!< (@ 0x000000A8) TX BD Write Pointer Register                               */
    
    struct {
      __IOM uint32_t tx_bd_h2c_wptr : 16;       /*!< [15..0] When the packet has been sent from Host to TX Buffer,
                                                     this index should be updated by SDIO Device HAL driver                    */
    } txbd_wptr_b;
  } ;
  
  union {
    __IOM uint32_t txbd_rptr;                   /*!< (@ 0x000000AC) TX BD Read Pointer Register                                */
    
    struct {
      __IOM uint32_t tx_bd_h2c_rptr : 16;       /*!< [15..0] When the TX packet has been processed and moved to MAC
                                                     TX FIFO, this index should be updated by HAL driver.                      */
    } txbd_rptr_b;
  } ;
  
  union {
    __IOM uint32_t rxbd_addr;                   /*!< (@ 0x000000B0) RX BD Address Register                                     */
    
    struct {
      __IOM uint32_t rx_bd_addr : 32;           /*!< [31..0] The base address of RX BD. The HAL driver should configure
                                                     this register at initial. It should be a 8-Byte aligned
                                                     address.                                                                  */
    } rxbd_addr_b;
  } ;
  
  union {
    __IOM uint16_t rxbd_num;                    /*!< (@ 0x000000B4) RX BD Number Register                                      */
    
    struct {
      __IOM uint16_t rx_bd_num  : 16;           /*!< [15..0] The total number of RX BD This register should be configured
                                                     by HAL driver at initialization.                                          */
    } rxbd_num_b;
  } ;
  
  union {
    __IOM uint16_t rxbd_wptr;                   /*!< (@ 0x000000B6) RX BD Write Pointer Register                               */
    
    struct {
      __IOM uint16_t rx_bd_c2h_wptr : 16;       /*!< [15..0] When the packet has been processed and has been moved
                                                     to host TX FIFO, this index should be updated by the HAL
                                                     driver.                                                                   */
    } rxbd_wptr_b;
  } ;
  
  union {
    __IOM uint16_t rxbd_rptr;                   /*!< (@ 0x000000B8) RX BD Read Pointer Register                                */
    
    struct {
      __IOM uint16_t rx_bd_c2h_rptr : 16;       /*!< [15..0] When the packet has been processed and has been transfered
                                                     to host, the HW will update this RX BD index.                             */
    } rxbd_rptr_b;
  } ;
  
  union {
    __IOM uint8_t hci_rx_ctrl;                  /*!< (@ 0x000000BA) HCI RX Control Register                                    */
    
    struct {
      __IOM uint8_t rx_req      : 1;            /*!< [0..0] HAL driver triggers this bit to enable SDIO IP HW to
                                                     fetch RX BD info. SDIO HW fetch RX BD to get the RX length
                                                     and address and then start to transfer RX packet to SDIO
                                                     Host. This bit will be cleared when all RX BD transfer
                                                     is done.                                                                  */
    } hci_rx_ctrl_b;
  } ;
  
  union {
    __IOM uint8_t sdio_ctrl;                    /*!< (@ 0x000000BB) SDIO HW Control Register                                   */
    
    struct {
      __IOM uint8_t sdio_dat_edge_inv : 1;      /*!< [0..0] Set this bit to invert the SDIO data latch clock.                  */
      __IM  uint8_t             : 6;
      __IOM uint8_t sdio_dma_rst : 1;           /*!< [7..7] The HAL driver can set this bit to reset SDIO DMA HW.
                                                     This bit will be cleared automatically by the HW.                         */
    } sdio_ctrl_b;
  } ;
  
  union {
    __IOM uint32_t rx_req_addr;                 /*!< (@ 0x000000BC) RX Request Address Register                                */
    
    struct {
      __IOM uint32_t rx_req_addr : 32;          /*!< [31..0] The address of the requested RX packet. This register
                                                     is discarded for Ameba.                                                   */
    } rx_req_addr_b;
  } ;
  
  union {
    __IOM uint16_t int_mask;                    /*!< (@ 0x000000C0) Interrupt Mask Register                                    */
    
    struct {
      __IOM uint16_t txbd_h2c_ovf : 1;          /*!< [0..0] Set this bit to enable the H2C TX BD overflow interrupt.           */
      __IOM uint16_t h2c_bus_res_fail : 1;      /*!< [1..1] Set this bit to enable the H2C bus resource failed interrupt.      */
      __IOM uint16_t h2c_dma_ok : 1;            /*!< [2..2] Set this bit to enable the H2C DMA done interrupt.                 */
      __IOM uint16_t c2h_dma_ok : 1;            /*!< [3..3] Set this bit to enable the C2H DMA done interrupt.                 */
      __IOM uint16_t h2c_msg    : 1;            /*!< [4..4] Set this bit to enable the H2C message interrupt.                  */
      __IOM uint16_t rpwm1      : 1;            /*!< [5..5] Set this bit to enable the RPWM interrupt.                         */
      __IOM uint16_t rpwm2      : 1;            /*!< [6..6] Set this bit to enable the RPWM2 interrupt.                        */
      __IOM uint16_t sdio_rst_cmd : 1;          /*!< [7..7] Set this bit to enable the SDIO reset command interrupt            */
      __IOM uint16_t rx_bd_err  : 1;            /*!< [8..8] Set this bit to enable the RX BD error interrupt.                  */
      __IOM uint16_t rx_bd_avai : 1;            /*!< [9..9] Set this bit to enable the RX BD available interrupt.              */
      __IOM uint16_t host_wake  : 1;            /*!< [10..10] Set this bit to enable the SDIO host wake event interrupt.       */
      __IOM uint16_t host_cmd11 : 1;            /*!< [11..11] Set this bit to enable the SDIO host CMD11(3.3v ->
                                                     1.8v) interrupt.                                                          */
    } int_mask_b;
  } ;
  
  union {
    __IOM uint16_t int_sts;                     /*!< (@ 0x000000C2) Interrupt Status Register                                  */
    
    struct {
      __IOM uint16_t txbd_h2c_ovf : 1;          /*!< [0..0] If there is not enough TX_BD for TX Packet, this interrupt
                                                     will be raised. The HAL driver write 1 to this bit to clear
                                                     this interript status.                                                    */
      __IOM uint16_t h2c_bus_res_fail : 1;      /*!< [1..1] If SDIO is going to move packet to TX FIFO and fails
                                                     to get bus resource, this interrupt raise. HAL driver write
                                                     1 to this bit to clear this interrupt status.                             */
      __IOM uint16_t h2c_dma_ok : 1;            /*!< [2..2] Trigger by SDIO HW for the event of packet is sent from
                                                     Host to TXFIFO                                                            */
      __IOM uint16_t c2h_dma_ok : 1;            /*!< [3..3] Trigger by SDIO HW for the event of packet is sent from
                                                     RXFIFO to Host                                                            */
      __IOM uint16_t h2c_msg    : 1;            /*!< [4..4] Trigger by SDIO HW for the event of H2C_MSG_INT occurs(REG_SDIO_H2C_MSG
                                                     is written)                                                               */
      __IOM uint16_t rpwm1      : 1;            /*!< [5..5] Trigger by SDIO HW for the event of the RPWM1 occurs(HRPWM2
                                                     is written) CPU should be able to receive this interrupt
                                                     even CPU clock is gated; therefore, this interrupt should
                                                     be connected to System On circuit.                                        */
      __IOM uint16_t rpwm2      : 1;            /*!< [6..6] Trigger by SDIO HW for the event of RPWM2 occurs (HRPWM
                                                     is toggled) CPU should be able to receive this interrupt
                                                     even CPU clock is gated; therefore, this interrupt should
                                                     be connected to System On circuit.                                        */
      __IOM uint16_t sdio_rst_cmd : 1;          /*!< [7..7] Trigger by SDIO HW when SDIO is reset. CPU should be
                                                     able to receive this interrupt even CPU clock is gated;
                                                     therefore, this interrupt should be connected to System
                                                     On circuit.                                                               */
      __IOM uint16_t rx_bd_err  : 1;            /*!< [8..8] Trigger by SDIO to CPU when detect RX_BD error                     */
      __IOM uint16_t rx_bd_avai : 1;            /*!< [9..9] If the free RXBD Number become larger than FREE_RXBD_COUNT(0xD8),
                                                     trigger this interrupt. This interrupt trigger only once
                                                     when free RXBD number cross FREE_RXBD_COUNT                               */
      __IOM uint16_t host_wake  : 1;            /*!< [10..10] When Host Send TRX CMD53 while CPU is not ready (SYSTEM_CPU_RDY_IND=0
                                                     or CPU_RDY_IND=0), trigger this interrupt to wake CPU,
                                                     and then indicate BUSY status to host. CPU should be able
                                                     to receive this interrupt even CPU clock is gated; therefore,
                                                     this interrupt should be connected to System On circuit.                  */
      __IOM uint16_t host_cmd11 : 1;            /*!< [11..11] When Host sends CMD11 to notify that the signal voltage
                                                     level is going to switch to 1.8v, the HW should issue this
                                                     interrupt to notify the local CPU to do the LDO power voltage
                                                     level switch.                                                             */
    } int_sts_b;
  } ;
  
  union {
    __IOM uint8_t ccpwm;                        /*!< (@ 0x000000C4) CCPWM Register (CPU domain Sync to HCPWM register)         */
    
    struct {
      __IM  uint8_t             : 1;
      __IOM uint8_t wlan_trx    : 1;            /*!< [1..1] 1: WLAN On; 0: WLAN Off.                                           */
      __IOM uint8_t rps_st      : 1;            /*!< [2..2] 1: AP Register Active State; 0: AP Register Sleep State;           */
      __IOM uint8_t wwlan       : 1;            /*!< [3..3] 1: Wake On WLAN State; 0: Normal State;                            */
      __IM  uint8_t             : 3;
      __IOM uint8_t toggle      : 1;            /*!< [7..7] Toggling Bit: this is the one bit sequence number field.
                                                     Interrupt is issued when this bit is changed from 1 to
                                                     0 or from 0 to 1.                                                         */
    } ccpwm_b;
  } ;
  
  union {
    __IOM uint8_t sys_ind;                      /*!< (@ 0x000000C5) System Indication Register                                 */
    
    struct {
      __IOM uint8_t sys_cpu_rdy_ind : 1;        /*!< [0..0] Used to indicate the SDIO NIC driver that local CPU is
                                                     ready for TRX. Default: 0 This bit is synchronized to CPU_RDY_IND(Offset
                                                     0x87)                                                                     */
    } sys_ind_b;
  } ;
  
  union {
    __IOM uint16_t ccpwm2;                      /*!< (@ 0x000000C6) CCPWM2 Register (CPU domain Sync to HCPWM2 register)       */
    
    struct {
      __IOM uint16_t active     : 1;            /*!< [0..0] 1: indicate that the SDIO device is in the activate state.         */
      __IOM uint16_t dstandby   : 1;            /*!< [1..1] 1: indicates that the SDIO device is in the deep-standby
                                                     state.                                                                    */
      __IOM uint16_t fboot      : 1;            /*!< [2..2] 1: indicates that the SDIO device boot from the fast
                                                     boot                                                                      */
      __IOM uint16_t inic_fw_rdy : 1;           /*!< [3..3] Indicates the FW mode of the SDIO device: 1: iNIC firmware;
                                                     0: SDIO boot firmware.                                                    */
      __IM  uint16_t            : 11;
      __IOM uint16_t toggle     : 1;            /*!< [15..15] Toggling Bit: this is the one bit sequence number field.
                                                     Interrupt is issued when this bit is changed from 1 to
                                                     0 or from 0 to 1.                                                         */
    } ccpwm2_b;
  } ;
  
  union {
    __IM  uint32_t h2c_msg;                     /*!< (@ 0x000000C8) CPU H2C Message Register (CPU domain Sync from
                                                                    SDIO_H2C_MSG register)                                     */
    
    struct {
      __IM  uint32_t h2c_msg    : 31;           /*!< [30..0] The message from SDIO host side driver.                           */
      __IM  uint32_t toggle     : 1;            /*!< [31..31] Toggling Bit: this is the one bit sequence number field.
                                                     Interrupt is issued when this bit is changed from 1 to
                                                     0 or from 0 to 1.                                                         */
    } h2c_msg_b;
  } ;
  
  union {
    __IOM uint32_t c2h_msg;                     /*!< (@ 0x000000CC) CPU C2H Message Register (CPU domain Sync to
                                                                    SDIO_C2H_MSG register)                                     */
    
    struct {
      __IOM uint32_t c2h_msg    : 31;           /*!< [30..0] The message from local HAL driver to SDIO host side
                                                     driver.                                                                   */
      __IOM uint32_t toggle     : 1;            /*!< [31..31] Toggling Bit: this is the one bit sequence number field.
                                                     Interrupt is issued when this bit is changed from 1 to
                                                     0 or from 0 to 1.                                                         */
    } c2h_msg_b;
  } ;
  
  union {
    __IM  uint16_t crpwm;                       /*!< (@ 0x000000D0) CRPWM Register (SDIO host side driver to local
                                                                    HAL driver, Sync from HRPWM register)                      */
    
    struct {
      __IM  uint16_t            : 1;
      __IM  uint16_t wlan_trx   : 1;            /*!< [1..1] 1: WLAN On; 0: WLAN Off.                                           */
      __IM  uint16_t rps_st     : 1;            /*!< [2..2] 1: AP Register Active State; 0: AP Register Sleep State;           */
      __IM  uint16_t wwlan      : 1;            /*!< [3..3] 1: Wake On WLAN State; 0: Normal State;                            */
      __IM  uint16_t            : 3;
      __IM  uint16_t toggle     : 1;            /*!< [7..7] Toggling Bit: this is the one bit sequence number field.
                                                     Interrupt is issued when this bit is changed from 1 to
                                                     0 or from 0 to 1.                                                         */
    } crpwm_b;
  } ;
  
  union {
    __IM  uint16_t crpwm2;                      /*!< (@ 0x000000D2) CRPWM2 Register (SDIO host side driver to local
                                                                    HAL driver, Sync from HRPWM register)                      */
    
    struct {
      __IM  uint16_t resv       : 15;           /*!< [14..0] Reserved                                                          */
      __IM  uint16_t toggle     : 1;            /*!< [15..15] Toggling Bit: this is the one bit sequence number field.
                                                     Interrupt is issued when this bit is changed from 1 to
                                                     0 or from 0 to 1.                                                         */
    } crpwm2_b;
  } ;
  
  union {
    __IOM uint32_t ahb_dma_ctrl;                /*!< (@ 0x000000D4) AHB DMA Control Register                                   */
    
    struct {
      __IOM uint32_t spdio_txff_wlevel : 7;     /*!< [6..0] SPDIO FIFO TX water level Range 1~126, it can be modified
                                                     only when AHB_DMA_CS = 000                                                */
      __IM  uint32_t            : 1;
      __IOM uint32_t spdio_rxff_wlevel : 7;     /*!< [14..8] SPDIO FIFO RX water level Range 1~126, it can be modified
                                                     only when AHB_DMA_CS = 000                                                */
      __IM  uint32_t            : 1;
      __IM  uint32_t ahb_dma_state : 4;         /*!< [19..16] AHB DMA state                                                    */
      __IM  uint32_t            : 1;
      __IM  uint32_t ahbm_spdio_ready : 1;      /*!< [21..21] SPDIO AHB Master HREADY signal                                   */
      __IM  uint32_t ahbm_spdio_trans : 2;      /*!< [23..22] SPDIO AHB Master HTRANS signal                                   */
      __IOM uint32_t rx_ahb_busy_wait_cnt : 4;  /*!< [27..24] When SPDIO RX transfer, AHB controller will wait BUSY
                                                     counter for AHB access target not response READY signal.
                                                     If timeout, AHB controller will issue AHB_BUS_RES_FAIL
                                                     INT to CPU.                                                               */
      __IOM uint32_t ahb_burst_type : 3;        /*!< [30..28] This field is used to control to SPDIO AHB support
                                                     Burst type. 3'b100: Support Burst 16 DW 3'b010: Support
                                                     Burst 8 DW 3'b001: Support Burst 4 DW Default is 3'b111,
                                                     all support.                                                              */
      __IOM uint32_t dispatch_txagg_pkt : 1;    /*!< [31..31] Enable SPDIO to dispatch the Aggregated TX packet.               */
    } ahb_dma_ctrl_b;
  } ;
  
  union {
    __IOM uint32_t free_rxbd_cnt;               /*!< (@ 0x000000D8) Free RX BD Count Register                                  */
    
    struct {
      __IOM uint32_t fifo_cnt   : 7;            /*!< [6..0] The SPDIO Local FIFO counter, for debug usage.                     */
      __IM  uint32_t            : 1;
      __IOM uint32_t tx_buf_unit_size : 8;      /*!< [15..8] The Size of each single TX Buffer which is addressed
                                                     by TX_BD Unit: 64Byte Ex: 0x01=>64Byte 0x10=>1024Byte                     */
      __IOM uint32_t free_rx_bd_cnt : 16;       /*!< [31..16] If SPDIO_RXBD_C2H_RPTR is updated and the free RXBD
                                                     Number is larger than FREE_RXBD_COUNT, trigger RX_BD_AVAI_INT
                                                     interrupt.                                                                */
    } free_rxbd_cnt_b;
  } ;
  
  union {
    __IM  uint32_t h2c_msg_ext;                 /*!< (@ 0x000000DC) CPU H2C Extension Message Register (CPU domain
                                                                    Sync from SDIO_H2C_MSG_EXT register)                       */
    
    struct {
      __IM  uint32_t h2c_msg_ext : 31;          /*!< [30..0] The message from SDIO host side driver to the local
                                                     HAL driver.                                                               */
      __IM  uint32_t toggle     : 1;            /*!< [31..31] Toggling Bit: this is the one bit sequence number field.
                                                     Interrupt is issued when this bit is changed from 1 to
                                                     0 or from 0 to 1.                                                         */
    } h2c_msg_ext_b;
  } ;
  
  union {
    __IOM uint32_t c2h_msg_ext;                 /*!< (@ 0x000000E0) CPU C2H Extension Message Register (CPU domain
                                                                    Sync to SDIO_C2H_MSG_EXT register)                         */
    
    struct {
      __IOM uint32_t c2h_msg_ext : 31;          /*!< [30..0] The message from local HAL driver to SDIO host side
                                                     driver.                                                                   */
      __IOM uint32_t toggle     : 1;            /*!< [31..31] Toggling Bit: this is the one bit sequence number field.
                                                     Interrupt is issued when this bit is changed from 1 to
                                                     0 or from 0 to 1.                                                         */
    } c2h_msg_ext_b;
  } ;
} SDIO_DEV_Type;                                /*!< Size = 228 (0xe4)                                                         */



/* =========================================================================================================================== */
/* ================                                           GDMA0                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief GDMA IP in low power platform with AXI interface. Only support up to 4092 data items. Common register struct for all channels (GDMA0)
  */

typedef struct {                                /*!< (@ 0x400602C0) GDMA0 Structure                                            */
  
  union {
    __IM  uint32_t raw_tfr;                     /*!< (@ 0x00000000) IntTfr Raw Interrupt Status Register                       */
    
    struct {
      __IM  uint32_t raw_tfr    : 6;            /*!< [5..0] Raw interrupt status of transfer complete                          */
    } raw_tfr_b;
  } ;
  __IM  uint32_t  RESERVED;
  
  union {
    __IM  uint32_t raw_block;                   /*!< (@ 0x00000008) IntBlock Raw Interrupt Status Register                     */
    
    struct {
      __IM  uint32_t raw_block  : 6;            /*!< [5..0] Raw interrupt status of one block transfer complete                */
    } raw_block_b;
  } ;
  __IM  uint32_t  RESERVED1;
  
  union {
    __IM  uint32_t raw_src_tran;                /*!< (@ 0x00000010) IntSrcTran Raw Interrupt Status Register                   */
    
    struct {
      __IM  uint32_t raw_src_tran : 6;          /*!< [5..0] Raw interrupt status of source transfer complete                   */
    } raw_src_tran_b;
  } ;
  __IM  uint32_t  RESERVED2;
  
  union {
    __IM  uint32_t raw_dst_tran;                /*!< (@ 0x00000018) IntDstTran Raw Interrupt Status Register                   */
    
    struct {
      __IM  uint32_t raw_dst_tran : 6;          /*!< [5..0] Raw interrupt status of destination transfer complete              */
    } raw_dst_tran_b;
  } ;
  __IM  uint32_t  RESERVED3;
  
  union {
    __IM  uint32_t raw_err;                     /*!< (@ 0x00000020) IntErr Raw Interrupt Status Register                       */
    
    struct {
      __IM  uint32_t raw_err    : 6;            /*!< [5..0] Raw interrupt status of transfer error                             */
    } raw_err_b;
  } ;
  __IM  uint32_t  RESERVED4;
  
  union {
    __IM  uint32_t status_tfr;                  /*!< (@ 0x00000028) IntTfr Interrupt Status Register                           */
    
    struct {
      __IM  uint32_t status_tfr : 6;            /*!< [5..0] Interrupt status of transfer complete                              */
    } status_tfr_b;
  } ;
  __IM  uint32_t  RESERVED5;
  
  union {
    __IM  uint32_t status_block;                /*!< (@ 0x00000030) IntBlock Interrupt Status Register                         */
    
    struct {
      __IM  uint32_t status_block : 6;          /*!< [5..0] Interrupt status of one block transfer complete                    */
    } status_block_b;
  } ;
  __IM  uint32_t  RESERVED6;
  
  union {
    __IM  uint32_t status_src_tran;             /*!< (@ 0x00000038) IntSrcTran Interrupt Status Register                       */
    
    struct {
      __IM  uint32_t status_src_tran : 6;       /*!< [5..0] Interrupt status of source transfer complete                       */
    } status_src_tran_b;
  } ;
  __IM  uint32_t  RESERVED7;
  
  union {
    __IM  uint32_t status_dst_tran;             /*!< (@ 0x00000040) IntDstTran Interrupt Status Register                       */
    
    struct {
      __IM  uint32_t status_dst_tran : 6;       /*!< [5..0] Interrupt status of destination transfer complete                  */
    } status_dst_tran_b;
  } ;
  __IM  uint32_t  RESERVED8;
  
  union {
    __IM  uint32_t status_err;                  /*!< (@ 0x00000048) IntErr Interrupt Status Register                           */
    
    struct {
      __IM  uint32_t status_err : 6;            /*!< [5..0] Interrupt status of transfer error                                 */
    } status_err_b;
  } ;
  __IM  uint32_t  RESERVED9;
  
  union {
    __IOM uint32_t mask_tfr;                    /*!< (@ 0x00000050) IntTfr Interrupt Mask Register                             */
    
    struct {
      __IOM uint32_t mask_tfr   : 6;            /*!< [5..0] Interrupt mask of transfer complete                                */
    } mask_tfr_b;
  } ;
  __IM  uint32_t  RESERVED10;
  
  union {
    __IOM uint32_t mask_block;                  /*!< (@ 0x00000058) IntBlock Interrupt Mask Register                           */
    
    struct {
      __IOM uint32_t mask_block : 6;            /*!< [5..0] Interrupt mask of one block transfer complete                      */
    } mask_block_b;
  } ;
  __IM  uint32_t  RESERVED11;
  
  union {
    __IOM uint32_t mask_src_tran;               /*!< (@ 0x00000060) IntSrcTran Interrupt Mask Register                         */
    
    struct {
      __IOM uint32_t mask_src_tran : 6;         /*!< [5..0] Interrupt mask of source transfer complete                         */
    } mask_src_tran_b;
  } ;
  __IM  uint32_t  RESERVED12;
  
  union {
    __IOM uint32_t mask_dst_tran;               /*!< (@ 0x00000068) IntDstTran Interrupt Mask Register                         */
    
    struct {
      __IOM uint32_t mask_dst_tran : 6;         /*!< [5..0] Interrupt mask of destination transfer complete                    */
    } mask_dst_tran_b;
  } ;
  __IM  uint32_t  RESERVED13;
  
  union {
    __IOM uint32_t mask_err;                    /*!< (@ 0x00000070) IntErr Interrupt Mask Register                             */
    
    struct {
      __IOM uint32_t mask_err   : 6;            /*!< [5..0] Interrupt mask of transfer error                                   */
    } mask_err_b;
  } ;
  __IM  uint32_t  RESERVED14;
  
  union {
    __IOM uint32_t clear_tfr;                   /*!< (@ 0x00000078) IntTfr Interrupt Clear Register                            */
    
    struct {
      __OM  uint32_t status_tfr : 6;            /*!< [5..0] Clear interrupt status of transfer complete                        */
    } clear_tfr_b;
  } ;
  __IM  uint32_t  RESERVED15;
  
  union {
    __IOM uint32_t clear_block;                 /*!< (@ 0x00000080) IntBlock Interrupt Clear Register                          */
    
    struct {
      __OM  uint32_t clear_block : 6;           /*!< [5..0] Clear interrupt status of one block transfer complete              */
    } clear_block_b;
  } ;
  __IM  uint32_t  RESERVED16;
  
  union {
    __IOM uint32_t clear_src_tran;              /*!< (@ 0x00000088) IntSrcTran Interrupt Clear Register                        */
    
    struct {
      __OM  uint32_t clear_src_tran : 6;        /*!< [5..0] Clear interrupt status of source transfer complete                 */
    } clear_src_tran_b;
  } ;
  __IM  uint32_t  RESERVED17;
  
  union {
    __IOM uint32_t clear_dst_tran;              /*!< (@ 0x00000090) IntDstTran Interrupt Clear Register                        */
    
    struct {
      __OM  uint32_t clear_dst_tran : 6;        /*!< [5..0] Clear interrupt status of destination transfer complete            */
    } clear_dst_tran_b;
  } ;
  __IM  uint32_t  RESERVED18;
  
  union {
    __IOM uint32_t clear_err;                   /*!< (@ 0x00000098) IntErr Interrupt Clear Register                            */
    
    struct {
      __OM  uint32_t clear_err  : 6;            /*!< [5..0] Clear interrupt status of transfer error                           */
    } clear_err_b;
  } ;
  __IM  uint32_t  RESERVED19;
  
  union {
    __IM  uint32_t status_int;                  /*!< (@ 0x000000A0) Combined Interrupt Status Register                         */
    
    struct {
      __IM  uint32_t tfr        : 1;            /*!< [0..0] OR of the contents of StatusTfr register                           */
      __IM  uint32_t block      : 1;            /*!< [1..1] OR of the contents of StatusBlock register                         */
      __IM  uint32_t srct       : 1;            /*!< [2..2] OR of the contents of StatusSrcTran register                       */
      __IM  uint32_t dstt       : 1;            /*!< [3..3] OR of the contents of StatusDstTran register                       */
      __IM  uint32_t err        : 1;            /*!< [4..4] OR of the contents of StatusErr register                           */
    } status_int_b;
  } ;
  __IM  uint32_t  RESERVED20[13];
  
  union {
    __IOM uint32_t dma_cfg_reg;                 /*!< (@ 0x000000D8) Configuration Register                                     */
    
    struct {
      __IOM uint32_t dma_en     : 1;            /*!< [0..0] RTK_DMAC Enable bit. 0 : Disable, 1 : Enable                       */
    } dma_cfg_reg_b;
  } ;
  __IM  uint32_t  RESERVED21;
  
  union {
    __IOM uint32_t ch_en_reg;                   /*!< (@ 0x000000E0) Channel Enable Register                                    */
    
    struct {
      __IOM uint32_t ch_en      : 6;            /*!< [5..0] Enables/Disables the channel. Setting this bit enables
                                                     a channel while clearing this bit disables the channel.
                                                     0 : Disable the Channel 1 : Enable the Channel The ChEnReg.CH_EN
                                                     bit is automatically cleared by hardware to disable the
                                                     channel after the last AXI transfer of the DMA transfer
                                                     to the destination has completed. Software can therefore
                                                     poll this bit to determine when this channel is free for
                                                     a new DMA transfer.                                                       */
      __IM  uint32_t            : 2;
      __OM  uint32_t ch_en_we   : 6;            /*!< [13..8] Channel enable write enable                                       */
    } ch_en_reg_b;
  } ;
  __IM  uint32_t  RESERVED22[5];
  
  union {
    __IOM uint32_t ch_reset_reg;                /*!< (@ 0x000000F8) Channel Reset Register                                     */
    
    struct {
      __IOM uint32_t ch_reset_en : 6;           /*!< [5..0] Reset channel enable. Set this bit to reset a channel;
                                                     clear this bit to finish the reset flow and release the
                                                     channel. 0 : reset the channel finish 1 : reset the channel
                                                     start The reset bit is not automatically cleared by hardware.
                                                     Software must clear it to finish software reset.                          */
      __IM  uint32_t            : 2;
      __IM  uint32_t ch_reset_en_we : 6;        /*!< [13..8] Channel reset write enable                                        */
    } ch_reset_reg_b;
  } ;
} GDMA0_Type;                                   /*!< Size = 252 (0xfc)                                                         */



/* =========================================================================================================================== */
/* ================                                         GDMA0_CH0                                         ================ */
/* =========================================================================================================================== */


/**
  * @brief GDMA control registers for specific channels (GDMA0_CH0)
  */

typedef struct {                                /*!< (@ 0x40060000) GDMA0_CH0 Structure                                        */
  
  union {
    __IOM uint32_t sar;                         /*!< (@ 0x00000000) Source Address Register for Channel x                      */
    
    struct {
      __IOM uint32_t sar        : 32;           /*!< [31..0] Source Address of DMA transfer. Updated after each source
                                                     transfer. The SINC field in the CTLx register determines
                                                     whether the address increments, decrements, or is left
                                                     unchanged on every source transfer throughout the block
                                                     transfer.                                                                 */
    } sar_b;
  } ;
  __IM  uint32_t  RESERVED;
  
  union {
    __IOM uint32_t dar;                         /*!< (@ 0x00000008) Destination Address Register for Channel x                 */
    
    struct {
      __IOM uint32_t dar        : 32;           /*!< [31..0] Destination address of DMA transfer. Updated after each
                                                     destination transfer. The DINC field in the CTLx register
                                                     determines whether the address increments, decrements,
                                                     or is left unchanged on every destination transfer throughout
                                                     the block transfer                                                        */
    } dar_b;
  } ;
  __IM  uint32_t  RESERVED1;
  
  union {
    __IOM uint32_t llp;                         /*!< (@ 0x00000010) Linked List Pointer Register for Channel x                 */
    
    struct {
      __IOM uint32_t lms        : 2;            /*!< [1..0] List Master Select. Identifies the AHB layer/interface
                                                     where the memory device that stores the next linked list
                                                     item resides.                                                             */
      __IOM uint32_t loc        : 30;           /*!< [31..2] Starting address in memory of next LLI if block chaining
                                                     is enabled.                                                               */
    } llp_b;
  } ;
  __IM  uint32_t  RESERVED2;
  
  union {
    __IOM uint32_t ctl_low;                     /*!< (@ 0x00000018) Lower Word of Control Register for Channel x               */
    
    struct {
      __IOM uint32_t int_en     : 1;            /*!< [0..0] If set, then all interrupt-generating sources are enabled.
                                                     Functions as a global mask bit for all interrupts for the
                                                     channel. Raw interrupt registers still assert if this field
                                                     is 0.                                                                     */
      __IOM uint32_t dst_tr_width : 3;          /*!< [3..1] Destination Transfer Width. 0x000 : 8 bit, 0x001 : 16
                                                     bit, 0x010 : 32 bit                                                       */
      __IOM uint32_t src_tr_width : 3;          /*!< [6..4] Source Transfer Width. The block_ts field should be modified
                                                     in accordance with this field. 0x000 : 8 bit, 0x001 : 16
                                                     bit, 0x010 : 32 bit                                                       */
      __IOM uint32_t dinc       : 2;            /*!< [8..7] Destination Address Increment. Indicate whether to increment
                                                     to destination address on every destination transfer. If
                                                     the device is fetching data from a destination peripheral
                                                     FIFO with a fixed adress, then this field should be set
                                                     to No Change. 0x00 : Increment, 0x1x : NoChange.                          */
      __IOM uint32_t sinc       : 2;            /*!< [10..9] Source Address Increment. Indicate whether to increment
                                                     to source address on every source transfer. If the device
                                                     is fetching data from a source peripheral FIFO with a fixed
                                                     adress, then this field should be set to No Change. 0x00
                                                     : Increment, 0x1x : NoChange.                                             */
      __IOM uint32_t dest_msize : 3;            /*!< [13..11] Destination Burst Transaction Length. Number of data
                                                     items, each of width ctl.dst_tr_width, to be read from
                                                     the destination every time a destination burst transaction
                                                     request is mode.                                                          */
      __IOM uint32_t src_msize  : 3;            /*!< [16..14] Source Burst Transaction Length. Number of data items,
                                                     each of width ctl.src_tr_width, to be read from the source
                                                     every time a source burst transaction request is mode.                    */
      __IM  uint32_t            : 3;
      __IOM uint32_t tt_fc      : 3;            /*!< [22..20] Transfer Type and Flow Control. The following transfer
                                                     types are supported. Memory to Memory, Memory to Peripheral,
                                                     Peripheral to Memory.                                                     */
      __IM  uint32_t            : 4;
      __IOM uint32_t llp_dst_en : 1;            /*!< [27..27] Block chaining is enabled on the destination side if
                                                     this field is high and llp.loc is non-zero.                               */
      __IOM uint32_t llp_src_en : 1;            /*!< [28..28] Block chaining is enabled on the source side if this
                                                     field is high and llp.loc is non-zero.                                    */
    } ctl_low_b;
  } ;
  
  union {
    __IOM uint32_t ctl_up;                      /*!< (@ 0x0000001C) Upper Word of Control Register for Channel x               */
    
    struct {
      __IOM uint32_t block_ts   : 12;           /*!< [11..0] Block Transfer Size. When the RTK_DMAC is the flow controller,
                                                     the user writes this field before the channel is enabled
                                                     in order to indicate the block size. The block_ts should
                                                     be modified according to the src_tr_width field. Ex: If
                                                     src_tr_width = 4 byte, block_ts = 2.                                      */
    } ctl_up_b;
  } ;
  __IM  uint32_t  RESERVED3[8];
  
  union {
    __IOM uint32_t cfg_low;                     /*!< (@ 0x00000040) Lower Word of Configuration Register for Channel
                                                                    x                                                          */
    
    struct {
      __IOM uint32_t inactive   : 1;            /*!< [0..0] Indicate the channel is inactive or not. 1: Inactive
                                                     state, 0: Active state.                                                   */
      __IM  uint32_t            : 7;
      __IOM uint32_t ch_susp    : 1;            /*!< [8..8] Channel Suspend. Suspends all DMA data transfers from
                                                     the source until this bit is cleared. There is no guarantee
                                                     that the current transaction will complete. Can also be
                                                     used in conjunction with CFGx.FIFO_EMPTY to cleanly disable
                                                     a channel without losing any data. 0 : Not suspended, 1
                                                     : Suspend DMA transfer from the source                                    */
      __IM  uint32_t fifo_empty : 1;            /*!< [9..9] Indicates if there is data left in the channel FIFO.
                                                     Can be used in conjunction with CFGx.CH_SUSP to cleanly
                                                     disable a channel. 1 : Channel FIFO empty, 0 : Channel
                                                     FIFO not empty.                                                           */
      __IM  uint32_t            : 8;
      __IOM uint32_t dst_hs_pol : 1;            /*!< [18..18] Destination Handshaking Interface Polarity. 0 : Active
                                                     high, 1: Active low                                                       */
      __IOM uint32_t src_hs_pol : 1;            /*!< [19..19] Source Handshaking Interface Polarity. 0 : Active high,
                                                     1: Active low                                                             */
      __IOM uint32_t max_abrst  : 10;           /*!< [29..20] Maximum OCP Burst Length. Maximum OCP burst length
                                                     that is used for DMA transfers on this channel.                           */
      __IOM uint32_t reload_src : 1;            /*!< [30..30] Automatic Source Reload. The SAR register can be automatically
                                                     reloaded from its initial value at the end of every block
                                                     for multi-block transfers. Not support in LP-GDMA.                        */
      __IOM uint32_t reload_dst : 1;            /*!< [31..31] Automatic Destination Reload. The DAR register can
                                                     be automatically reloaded from its initial value at the
                                                     end of every block for multi-block transfers. Not support
                                                     in LP-GDMA.                                                               */
    } cfg_low_b;
  } ;
  
  union {
    __IOM uint32_t cfg_up;                      /*!< (@ 0x00000044) Upper Word of Configuration Register for Channel
                                                                    x                                                          */
    
    struct {
      __IM  uint32_t            : 1;
      __IOM uint32_t fifo_mode  : 1;            /*!< [1..1] FIFO Mode Select. Determines how much space or data needs
                                                     to be available in the FIFO before a burst transaction
                                                     request is servied. Enable this field will improve OCP/AXI
                                                     master interface burst transaction length, but the burst
                                                     transaction length also controlled by CTL.SRC_MSIZE and
                                                     CTL.DST_MSIZE. If FIFO_MODE is enabled, the maximal burst
                                                     transaction length is the minimum value of FIFO depth(half
                                                     FIFO depth) and MSIZE. If FIFO_MODE is disabled, the burst
                                                     transaction length will be fixed to 1. It is recom                        */
      __IM  uint32_t            : 1;
      __IOM uint32_t secure_en  : 1;            /*!< [3..3] Enable secure mode DMA transfer. This bit can only be
                                                     accessed by CPU under secure mode. Non-secure GDMA does
                                                     not have this bit.                                                        */
      __IM  uint32_t            : 3;
      __IOM uint32_t src_per    : 4;            /*!< [10..7] Assigns a hardware handshaking interface to the source
                                                     of channels. The channel can then communicate with the
                                                     source peripheral connected to that interface through the
                                                     assigned hardware handshaking interface.                                  */
      __IOM uint32_t dest_per   : 4;            /*!< [14..11] Assigns a hardware handshaking interface to the destination
                                                     of channels. The channel can then communicate with the
                                                     destination peripheral connected to that interface through
                                                     the assigned hardware handshaking interface.                              */
      __IOM uint32_t extended_src_per : 1;      /*!< [15..15] The extened 4th bit of src_per when hardware handshake
                                                     interfaces number is configured to 32. Not supported in
                                                     LP-GDMA.                                                                  */
      __IOM uint32_t extended_dest_per : 1;     /*!< [16..16] The extened 4th bit of dest_per when hardware handshake
                                                     interfaces number is configured to 32. Not supported in
                                                     LP-GDMA.                                                                  */
    } cfg_up_b;
  } ;
} GDMA0_CH0_Type;                               /*!< Size = 72 (0x48)                                                          */


/** @} */ /* End of group Device_Peripheral_peripherals */


/* =========================================================================================================================== */
/* ================                          Device Specific Peripheral Address Map                           ================ */
/* =========================================================================================================================== */


/** @addtogroup Device_Peripheral_peripheralAddr
  * @{
  */

#define MiscIRQ_BASE                0x00000000UL
#define GPIO_BASE                   0x40001000UL
#define TG0_BASE                    0x40003800UL
#define TM0_BASE                    0x40002040UL
#define TM1_BASE                    0x40002080UL
#define TM2_BASE                    0x400020C0UL
#define TM3_BASE                    0x40002100UL
#define TM4_BASE                    0x40002140UL
#define TM5_BASE                    0x40002180UL
#define TM6_BASE                    0x400021C0UL
#define TM7_BASE                    0x40002200UL
#define TG1_BASE                    0x40002000UL
#define TM8_BASE                    0x40003840UL
#define PWM_COMM_BASE               0x40001C00UL
#define PWM0_BASE                   0x40001C20UL
#define PWM1_BASE                   0x40001C40UL
#define PWM2_BASE                   0x40001C60UL
#define PWM3_BASE                   0x40001C80UL
#define PWM4_BASE                   0x40001CA0UL
#define PWM5_BASE                   0x40001CC0UL
#define PWM6_BASE                   0x40001CE0UL
#define PWM7_BASE                   0x40001D00UL
#define LPCRAM_BASE                 0x40600000UL
#define SPIC_BASE                   0x40020000UL
#define UART0_BASE                  0x40003000UL
#define UART1_BASE                  0x40040000UL
#define UART2_BASE                  0x40040400UL
#define UART3_BASE                  0x40040800UL
#define SSI0_BASE                   0x40042000UL
#define I2C0_BASE                   0x40044000UL
#define SDIO_DEV_BASE               0x40050000UL
#define GDMA0_BASE                  0x400602C0UL
#define GDMA0_CH0_BASE              0x40060000UL
#define GDMA0_CH1_BASE              0x40060058UL
#define SGDMA0_BASE                 0x500602C0UL
#define SGDMA0_CH0_BASE             0x50060000UL
#define SGDMA0_CH1_BASE             0x50060058UL

/** @} */ /* End of group Device_Peripheral_peripheralAddr */


/* =========================================================================================================================== */
/* ================                                  Peripheral declaration                                   ================ */
/* =========================================================================================================================== */


/** @addtogroup Device_Peripheral_declaration
  * @{
  */

#define MiscIRQ                     ((MiscIRQ_Type*)           MiscIRQ_BASE)
#define GPIO                        ((GPIO_Type*)              GPIO_BASE)
#define TG0                         ((TG0_Type*)               TG0_BASE)
#define TM0                         ((TM0_Type*)               TM0_BASE)
#define TM1                         ((TM0_Type*)               TM1_BASE)
#define TM2                         ((TM0_Type*)               TM2_BASE)
#define TM3                         ((TM0_Type*)               TM3_BASE)
#define TM4                         ((TM0_Type*)               TM4_BASE)
#define TM5                         ((TM0_Type*)               TM5_BASE)
#define TM6                         ((TM0_Type*)               TM6_BASE)
#define TM7                         ((TM0_Type*)               TM7_BASE)
#define TG1                         ((TG0_Type*)               TG1_BASE)
#define TM8                         ((TM0_Type*)               TM8_BASE)
#define PWM_COMM                    ((PWM_COMM_Type*)          PWM_COMM_BASE)
#define PWM0                        ((PWM0_Type*)              PWM0_BASE)
#define PWM1                        ((PWM0_Type*)              PWM1_BASE)
#define PWM2                        ((PWM0_Type*)              PWM2_BASE)
#define PWM3                        ((PWM0_Type*)              PWM3_BASE)
#define PWM4                        ((PWM0_Type*)              PWM4_BASE)
#define PWM5                        ((PWM0_Type*)              PWM5_BASE)
#define PWM6                        ((PWM0_Type*)              PWM6_BASE)
#define PWM7                        ((PWM0_Type*)              PWM7_BASE)
#define LPCRAM                      ((LPCRAM_Type*)            LPCRAM_BASE)
#define SPIC                        ((SPIC_Type*)              SPIC_BASE)
#define UART0                       ((UART0_Type*)             UART0_BASE)
#define UART1                       ((UART0_Type*)             UART1_BASE)
#define UART2                       ((UART0_Type*)             UART2_BASE)
#define UART3                       ((UART0_Type*)             UART3_BASE)
#define SSI0                        ((SSI0_Type*)              SSI0_BASE)
#define I2C0                        ((I2C0_Type*)              I2C0_BASE)
#define SDIO_DEV                    ((SDIO_DEV_Type*)          SDIO_DEV_BASE)
#define GDMA0                       ((GDMA0_Type*)             GDMA0_BASE)
#define GDMA0_CH0                   ((GDMA0_CH0_Type*)         GDMA0_CH0_BASE)
#define GDMA0_CH1                   ((GDMA0_CH0_Type*)         GDMA0_CH1_BASE)
#define SGDMA0                      ((GDMA0_Type*)             SGDMA0_BASE)
#define SGDMA0_CH0                  ((GDMA0_CH0_Type*)         SGDMA0_CH0_BASE)
#define SGDMA0_CH1                  ((GDMA0_CH0_Type*)         SGDMA0_CH1_BASE)

/** @} */ /* End of group Device_Peripheral_declaration */


/* =========================================  End of section using anonymous unions  ========================================= */
#if defined (__CC_ARM)
  #pragma pop
#elif defined (__ICCARM__)
  /* leave anonymous unions enabled */
#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
  #pragma clang diagnostic pop
#elif defined (__GNUC__)
  /* anonymous unions are enabled by default */
#elif defined (__TMS470__)
  /* anonymous unions are enabled by default */
#elif defined (__TASKING__)
  #pragma warning restore
#elif defined (__CSMC__)
  /* anonymous unions are enabled by default */
#endif


#ifdef __cplusplus
}
#endif

#endif /* RTL8710C_H */


/** @} */ /* End of group rtl8710c */

/** @} */ /* End of group Realtek Semiconductor Corp. */
