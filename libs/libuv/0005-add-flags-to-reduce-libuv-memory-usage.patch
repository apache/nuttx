From 863837502d2d8c1ecfba7eb0e5b8a493cd46988c Mon Sep 17 00:00:00 2001
From: spiriou <spiriou31@gmail.com>
Date: Sun, 2 Aug 2020 12:16:19 +0200
Subject: [PATCH 5/8] add flags to reduce libuv memory usage

---
 include/uv/unix.h | 40 +++++++++++++++++++++++++++++++++-------
 src/unix/async.c  | 24 ++++++++++++++++++++++++
 src/unix/core.c   | 28 +++++++++++++++++++++++-----
 src/unix/loop.c   | 20 ++++++++++++++++++++
 src/unix/stream.c |  8 ++++++--
 5 files changed, 106 insertions(+), 14 deletions(-)

diff --git a/include/uv/unix.h b/include/uv/unix.h
index 3292e2a..201573c 100644
--- a/include/uv/unix.h
+++ b/include/uv/unix.h
@@ -237,12 +237,18 @@ typedef struct {
 #endif
 
 #ifdef CONFIG_LIBUV_ASYNC
+#ifndef CONFIG_LIBUV_LOW_FOOTPRINT
 #define UV_LOOP_PRIVATE_ASYNC_FIELDS                                          \
   void* async_handles[2];                                                     \
   void (*async_unused)(void);  /* TODO(bnoordhuis) Remove in libuv v2. */     \
   uv__io_t async_io_watcher;                                                  \
   int async_wfd;
 #else
+#define UV_LOOP_PRIVATE_ASYNC_FIELDS                                          \
+  void* async_handles[2];                                                     \
+  uv__io_t async_io_watcher;
+#endif /* CONFIG_LIBUV_LOW_FOOTPRINT */
+#else
 #define UV_LOOP_PRIVATE_ASYNC_FIELDS
 #endif
 
@@ -266,26 +272,46 @@ typedef struct {
 #define UV_LOOP_PRIVATE_WQ_FIELDS
 #endif
 
-#define UV_LOOP_PRIVATE_FIELDS                                                \
+#ifdef CONFIG_LIBUV_LOOP_WATCHERS
+#define UV_LOOP_PRIVATE_WATCHERS_FIELDS                                       \
+  void* prepare_handles[2];                                                   \
+  void* check_handles[2];                                                     \
+  void* idle_handles[2];
+#else
+#define UV_LOOP_PRIVATE_WATCHERS_FIELDS
+#endif
+
+#ifdef CONFIG_LIBUV_LOW_FOOTPRINT
+#define UV_LOOP_PRIVATE_PERFS_FIELDS
+#else
+#define UV_LOOP_PRIVATE_PERFS_FIELDS                                          \
   unsigned long flags;                                                        \
   int backend_fd;                                                             \
-  void* pending_queue[2];                                                     \
+  uv_rwlock_t cloexec_lock;                                                   \
+  int emfile_fd;
+#endif
+
+#if 0
+#define UV_LOOP_PRIVATE_TODO_FIELDS                                           \
+  void* pending_queue[2];
+#else
+#define UV_LOOP_PRIVATE_TODO_FIELDS
+#endif
+
+#define UV_LOOP_PRIVATE_FIELDS                                                \
   void* watcher_queue[2];                                                     \
   uv__io_t** watchers;                                                        \
   unsigned int nwatchers;                                                     \
   unsigned int nfds;                                                          \
   UV_LOOP_PRIVATE_WQ_FIELDS                                                   \
-  uv_rwlock_t cloexec_lock;                                                   \
   uv_handle_t* closing_handles;                                               \
-  void* prepare_handles[2];                                                   \
-  void* check_handles[2];                                                     \
-  void* idle_handles[2];                                                      \
+  UV_LOOP_PRIVATE_WATCHERS_FIELDS                                             \
   UV_LOOP_PRIVATE_ASYNC_FIELDS                                                \
   UV_LOOP_PRIVATE_TIMER_FIELDS                                                \
   uint64_t time;                                                              \
   UV_LOOP_PRIVATE_SIGNAL_FIELDS                                               \
   UV_LOOP_PRIVATE_PROCESS_FIELDS                                              \
-  int emfile_fd;                                                              \
+  UV_LOOP_PRIVATE_PERFS_FIELDS                                                \
   UV_PLATFORM_LOOP_FIELDS                                                     \
 
 #define UV_REQ_TYPE_PRIVATE /* empty */
diff --git a/src/unix/async.c b/src/unix/async.c
index f7c0de1..336dcf9 100644
--- a/src/unix/async.c
+++ b/src/unix/async.c
@@ -177,7 +177,12 @@ static void uv__async_send(uv_loop_t* loop) {
 
   buf = "";
   len = 1;
+
+#ifndef CONFIG_LIBUV_LOW_FOOTPRINT
   fd = loop->async_wfd;
+#else
+  fd = -1;
+#endif
 
 #if defined(__linux__) || defined(__NUTTX__)
   if (fd == -1) {
@@ -204,6 +209,8 @@ static void uv__async_send(uv_loop_t* loop) {
 
 
 static int uv__async_start(uv_loop_t* loop) {
+#ifndef CONFIG_LIBUV_LOW_FOOTPRINT
+
   int pipefd[2];
   int err;
 
@@ -227,6 +234,21 @@ static int uv__async_start(uv_loop_t* loop) {
   uv__io_start(loop, &loop->async_io_watcher, POLLIN);
   loop->async_wfd = pipefd[1];
 
+#else /* CONFIG_LIBUV_LOW_FOOTPRINT */
+
+  int err;
+
+  if (loop->async_io_watcher.fd != -1)
+    return 0;
+
+  err = eventfd(0, EFD_CLOEXEC | EFD_NONBLOCK);
+  if (err < 0)
+    return UV__ERR(errno);
+  uv__io_init(&loop->async_io_watcher, uv__async_io, err);
+  uv__io_start(loop, &loop->async_io_watcher, POLLIN);
+
+#endif /* CONFIG_LIBUV_LOW_FOOTPRINT */
+
   return 0;
 }
 
@@ -245,11 +267,13 @@ void uv__async_stop(uv_loop_t* loop) {
   if (loop->async_io_watcher.fd == -1)
     return;
 
+#ifndef CONFIG_LIBUV_LOW_FOOTPRINT
   if (loop->async_wfd != -1) {
     if (loop->async_wfd != loop->async_io_watcher.fd)
       uv__close(loop->async_wfd);
     loop->async_wfd = -1;
   }
+#endif
 
   uv__io_stop(loop, &loop->async_io_watcher, POLLIN);
   uv__close(loop->async_io_watcher.fd);
diff --git a/src/unix/core.c b/src/unix/core.c
index a9d0a78..7f11370 100644
--- a/src/unix/core.c
+++ b/src/unix/core.c
@@ -90,7 +90,9 @@ extern char** environ;
 # define uv__accept4 accept4
 #endif
 
+#if 0
 static int uv__run_pending(uv_loop_t* loop);
+#endif
 
 /* Verify that uv_buf_t is ABI-compatible with struct iovec. */
 STATIC_ASSERT(sizeof(uv_buf_t) == sizeof(struct iovec));
@@ -339,10 +341,11 @@ int uv_is_closing(const uv_handle_t* handle) {
   return uv__is_closing(handle);
 }
 
-
+#ifndef CONFIG_LIBUV_LOW_FOOTPRINT
 int uv_backend_fd(const uv_loop_t* loop) {
   return loop->backend_fd;
 }
+#endif
 
 
 int uv_backend_timeout(const uv_loop_t* loop) {
@@ -352,11 +355,15 @@ int uv_backend_timeout(const uv_loop_t* loop) {
   if (!uv__has_active_handles(loop) && !uv__has_active_reqs(loop))
     return 0;
 
+#ifdef CONFIG_LIBUV_LOOP_WATCHERS
   if (!QUEUE_EMPTY(&loop->idle_handles))
     return 0;
+#endif
 
+#if 0
   if (!QUEUE_EMPTY(&loop->pending_queue))
     return 0;
+#endif
 
   if (loop->closing_handles)
     return 0;
@@ -397,16 +404,25 @@ int uv_run(uv_loop_t* loop, uv_run_mode mode) {
     uv__run_timers(loop);
 #endif
 
+#if 0
     ran_pending = uv__run_pending(loop);
+#else
+    ran_pending = 0;
+#endif
+
+#ifdef CONFIG_LIBUV_LOOP_WATCHERS
     uv__run_idle(loop);
     uv__run_prepare(loop);
+#endif
 
     timeout = 0;
     if ((mode == UV_RUN_ONCE && !ran_pending) || mode == UV_RUN_DEFAULT)
       timeout = uv_backend_timeout(loop);
 
     uv__io_poll(loop, timeout);
+#ifdef CONFIG_LIBUV_LOOP_WATCHERS
     uv__run_check(loop);
+#endif
     uv__run_closing_handles(loop);
 
     if (mode == UV_RUN_ONCE) {
@@ -815,7 +831,7 @@ int uv_fileno(const uv_handle_t* handle, uv_os_fd_t* fd) {
   return 0;
 }
 
-
+#if 0
 static int uv__run_pending(uv_loop_t* loop) {
   QUEUE* q;
   QUEUE pq;
@@ -836,7 +852,7 @@ static int uv__run_pending(uv_loop_t* loop) {
 
   return 1;
 }
-
+#endif
 
 static unsigned int next_power_of_two(unsigned int val) {
   val -= 1;
@@ -887,7 +903,9 @@ static void maybe_resize(uv_loop_t* loop, unsigned int len) {
 void uv__io_init(uv__io_t* w, uv__io_cb cb, int fd) {
   assert(cb != NULL);
   assert(fd >= -1);
+#if 0
   QUEUE_INIT(&w->pending_queue);
+#endif
   QUEUE_INIT(&w->watcher_queue);
   w->cb = cb;
   w->fd = fd;
@@ -960,7 +978,7 @@ void uv__io_stop(uv_loop_t* loop, uv__io_t* w, unsigned int events) {
     QUEUE_INSERT_TAIL(&loop->watcher_queue, &w->watcher_queue);
 }
 
-
+#if 0
 void uv__io_close(uv_loop_t* loop, uv__io_t* w) {
   uv__io_stop(loop, w, POLLIN | POLLOUT | UV__POLLRDHUP | UV__POLLPRI);
   QUEUE_REMOVE(&w->pending_queue);
@@ -982,7 +1000,7 @@ int uv__io_active(const uv__io_t* w, unsigned int events) {
   assert(0 != events);
   return 0 != (w->pevents & events);
 }
-
+#endif
 
 int uv__fd_exists(uv_loop_t* loop, int fd) {
   return (unsigned) fd < loop->nwatchers && loop->watchers[fd] != NULL;
diff --git a/src/unix/loop.c b/src/unix/loop.c
index fc33892..1c60e31 100644
--- a/src/unix/loop.c
+++ b/src/unix/loop.c
@@ -42,12 +42,16 @@ int uv_loop_init(uv_loop_t* loop) {
 #ifdef CONFIG_LIBUV_WQ
   QUEUE_INIT(&loop->wq);
 #endif
+#ifdef CONFIG_LIBUV_LOOP_WATCHERS
   QUEUE_INIT(&loop->idle_handles);
+#endif
 #ifdef CONFIG_LIBUV_ASYNC
   QUEUE_INIT(&loop->async_handles);
 #endif
+#ifdef CONFIG_LIBUV_LOOP_WATCHERS
   QUEUE_INIT(&loop->check_handles);
   QUEUE_INIT(&loop->prepare_handles);
+#endif
   QUEUE_INIT(&loop->handle_queue);
 
   loop->active_handles = 0;
@@ -55,23 +59,29 @@ int uv_loop_init(uv_loop_t* loop) {
   loop->nfds = 0;
   loop->watchers = NULL;
   loop->nwatchers = 0;
+#if 0
   QUEUE_INIT(&loop->pending_queue);
+#endif
   QUEUE_INIT(&loop->watcher_queue);
 
   loop->closing_handles = NULL;
   uv__update_time(loop);
 #ifdef CONFIG_LIBUV_ASYNC
   loop->async_io_watcher.fd = -1;
+#ifndef CONFIG_LIBUV_LOW_FOOTPRINT
   loop->async_wfd = -1;
 #endif
+#endif
 
 #ifdef CONFIG_LIBUV_SIGNAL
   loop->signal_pipefd[0] = -1;
   loop->signal_pipefd[1] = -1;
 #endif
 
+#ifndef CONFIG_LIBUV_LOW_FOOTPRINT
   loop->backend_fd = -1;
   loop->emfile_fd = -1;
+#endif
 
 #ifdef CONFIG_LIBUV_TIMER
   loop->timer_counter = 0;
@@ -96,9 +106,11 @@ int uv_loop_init(uv_loop_t* loop) {
 #endif
 #endif
 
+#ifndef CONFIG_LIBUV_LOW_FOOTPRINT
   err = uv_rwlock_init(&loop->cloexec_lock);
   if (err)
     goto fail_rwlock_init;
+#endif
 
 #ifdef CONFIG_LIBUV_WQ
   err = uv_mutex_init(&loop->wq_mutex);
@@ -120,10 +132,14 @@ fail_async_init:
   uv_mutex_destroy(&loop->wq_mutex);
 
 fail_mutex_init:
+#ifndef CONFIG_LIBUV_LOW_FOOTPRINT
   uv_rwlock_destroy(&loop->cloexec_lock);
 #endif
+#endif
 
+#ifndef CONFIG_LIBUV_LOW_FOOTPRINT
 fail_rwlock_init:
+#endif
 #ifdef CONFIG_LIBUV_PROCESS
   uv__signal_loop_cleanup(loop);
 
@@ -180,6 +196,7 @@ void uv__loop_close(uv_loop_t* loop) {
   uv__async_stop(loop);
 #endif
 
+#ifndef CONFIG_LIBUV_LOW_FOOTPRINT
   if (loop->emfile_fd != -1) {
     uv__close(loop->emfile_fd);
     loop->emfile_fd = -1;
@@ -189,6 +206,7 @@ void uv__loop_close(uv_loop_t* loop) {
     uv__close(loop->backend_fd);
     loop->backend_fd = -1;
   }
+#endif
 
 #ifdef CONFIG_LIBUV_WQ
   uv_mutex_lock(&loop->wq_mutex);
@@ -198,11 +216,13 @@ void uv__loop_close(uv_loop_t* loop) {
   uv_mutex_destroy(&loop->wq_mutex);
 #endif
 
+#ifndef CONFIG_LIBUV_LOW_FOOTPRINT
   /*
    * Note that all thread pool stuff is finished at this point and
    * it is safe to just destroy rw lock
    */
   uv_rwlock_destroy(&loop->cloexec_lock);
+#endif
 
 #if 0
   assert(QUEUE_EMPTY(&loop->pending_queue));
diff --git a/src/unix/stream.c b/src/unix/stream.c
index 8327f9c..943e644 100644
--- a/src/unix/stream.c
+++ b/src/unix/stream.c
@@ -101,6 +101,7 @@ void uv__stream_init(uv_loop_t* loop,
   QUEUE_INIT(&stream->write_completed_queue);
   stream->write_queue_size = 0;
 
+#ifndef CONFIG_LIBUV_LOW_FOOTPRINT
   if (loop->emfile_fd == -1) {
     err = uv__open_cloexec("/dev/null", O_RDONLY);
     if (err < 0)
@@ -111,6 +112,7 @@ void uv__stream_init(uv_loop_t* loop,
     if (err >= 0)
       loop->emfile_fd = err;
   }
+#endif
 
 #if defined(__APPLE__)
   stream->select = NULL;
@@ -482,7 +484,7 @@ void uv__stream_destroy(uv_stream_t* stream) {
   assert(stream->write_queue_size == 0);
 }
 
-
+#ifndef CONFIG_LIBUV_LOW_FOOTPRINT
 /* Implements a best effort approach to mitigating accept() EMFILE errors.
  * We have a spare file descriptor stashed away that we close to get below
  * the EMFILE limit. Next, we accept all pending connections and close them
@@ -516,7 +518,7 @@ static int uv__emfile_trick(uv_loop_t* loop, int accept_fd) {
 
   return err;
 }
-
+#endif
 
 #if defined(UV_HAVE_KQUEUE)
 # define UV_DEC_BACKLOG(w) w->rcount--;
@@ -555,11 +557,13 @@ void uv__server_io(uv_loop_t* loop, uv__io_t* w, unsigned int events) {
       if (err == UV_ECONNABORTED)
         continue;  /* Ignore. Nothing we can do about that. */
 
+#ifndef CONFIG_LIBUV_LOW_FOOTPRINT
       if (err == UV_EMFILE || err == UV_ENFILE) {
         err = uv__emfile_trick(loop, uv__stream_fd(stream));
         if (err == UV_EAGAIN || err == UV__ERR(EWOULDBLOCK))
           break;
       }
+#endif
 
       stream->connection_cb(stream, err);
       continue;
-- 
2.17.1

