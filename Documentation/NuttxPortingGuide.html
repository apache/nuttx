<html>
<head>
<title>NuttX Porting Guide</title>
<meta name="author" content="Gregory Nutt">
</head>

<body background="backgd.gif">
<hr><hr>
<table width ="100%">
  <tr align="center" bgcolor="#e4e4e4">
    <td>
      <h1><big><font color="#3c34ec">
        <i>NuttX RTOS Porting Guide</i>
      </font></big></h1>
      <p>Last Updated: May 18, 2015</p>
    </td>
  </tr>
</table>
<hr><hr>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
    <td>
  <h1>Table of Contents</h1>
    </td>
  </tr>
</table>

<ul>
  <a href="#Introduction">1.0 Introduction</a><br>
  <a href="#DirectoryStructure">2.0 Directory Structure</a>
  <ul>
    <a href="#DirStructDocumentation">2.1 Documentation</a><br>
    <a href="#DirStructArch">2.2 arch/</a>
    <ul>
      <a href="#archdirectorystructure">2.2.1 Subdirectory Structure</a><br>
      <a href="#summaryofarchfiles">2.2.2 Summary of Files</a><br>
      <a href="#supportedarchitectures">2.2.3 Supported Architectures</a>
    </ul>
    <a href="#DirStructBinFmt">2.3 binfmt/</a><br>
    <a href="#DirStructConfigs">2.4 configs/</a>
    <ul>
      <a href="#configsdirectorystructure">2.4.1 Subdirectory Structure</a><br>
      <a href="#summaryofconfigfiles">2.4.2 Summary of Files</a>
      <ul>
        <a href="#boardlogic">2.4.2.1 Board Specific Logic</a><br>
        <a href="#boardconfigsubdirs">2.4.2.2 Board Specific Configuration Sub-Directories</a>
      </ul>
      <a href="#supportedboards">2.4.3 Supported Boards</a><br>
      <a href="#newboardconfig">2.4.4 Adding a New Board Configuration</a>
    </ul>
    <a href="#DirStructDrivers">2.5 nuttx/drivers/</a><br>
    <a href="#DirStructFs">2.6 nuttx/fs/</a><br>
    <a href="#DirStructGraphics">2.7 nuttx/graphics/</a><br>
    <a href="#DirStructInclude">2.8 nuttx/include/</a><br>
    <a href="#DirStructLib">2.9 nuttx/libc/</a><br>
    <a href="#DirStructLibXX">2.10 nuttx/libxx/</a><br>
    <a href="#DirStructMm">2.11 nuttx/mm/</a><br>
    <a href="#DirStructNet">2.12 nuttx/net</a><br>
    <a href="#DirStructSched">2.13 nuttx/sched/</a><br>
    <a href="#DirStructSyscall">2.14 nuttx/syscall/</a><br>
    <a href="#DirStructTools">2.15 nuttx/tools/</a><br>
    <a href="#topmakefile">2.16 nuttx/Makefile</a><br>
    <a href="#DirStructNetUtils">2.17 apps/netutils</a><br>
    <a href="#DirStructNshLib">2.18 apps/nshlib</a><br>
    <a href="#DirStructExamples">2.19 apps/examples/</a>
  </ul>
  <a href="#configandbuild">3.0 Configuring and Building</a>
  <ul>
    <a href="#configuringnuttx">3.1 Configuring NuttX</a><br>
    <a href="#buildingnuttx">3.2 Building NuttX</a>
  </ul>
  <a href="#ArchAPIs">4.0 Architecture APIs</a>
  <ul>
    <a href="#naming">4.1 Naming and Header File Conventions</a><br>
    <a href="#imports">4.2 APIs Exported by Architecture-Specific Logic to NuttX</a>
    <ul>
      <a href="#upinitialize">4.2.1 <code>up_initialize()</code></a><br>
      <a href="#upidle">4.2.2 <code>up_idle()</code></a><br>
      <a href="#upinitialstate">4.2.3 <code>up_initial_state()</code></a><br>
      <a href="#upcreatestack">4.2.4 <code>up_create_stack()</code></a><br>
      <a href="#upusestack">4.2.5 <code>up_use_stack()</code></a><br>
      <a href="#upstackframe">4.2.6 <code>up_stack_frame()</code></a><br>
      <a href="#upreleasestack">4.2.7 <code>up_release_stack()</code></a><br>
      <a href="#upunblocktask">4.2.8 <code>up_unblock_task()</code></a><br>
      <a href="#upblocktask">4.2.9 <code>up_block_task()</code></a><br>
      <a href="#upreleasepending">4.2.10 <code>up_release_pending()</code></a><br>
      <a href="#upreprioritizertr">4.2.11 <code>up_reprioritize_rtr()</code></a><br>
      <a href="#_exit">4.2.12 <code>_exit()</code></a><br>
      <a href="#upassert">4.2.13 <code>up_assert()</code></a><br>
      <a href="#upschedulesigaction">4.2.14 <code>up_schedule_sigaction()</code></a><br>
      <a href="#upallocateheap">4.2.15 <code>up_allocate_heap()</code></a><br>
      <a href="#upinterruptcontext">4.2.16 <code>up_interrupt_context()</code></a><br>
      <a href="#updisableirq">4.2.17 <code>up_disable_irq()</code></a><br>
      <a href="#upenableirq">4.2.18 <code>up_enable_irq()</code></a><br>
      <a href="#upprioritizeirq">4.2.19 <code>up_prioritize_irq()</code></a><br>
      <a href="#upputc">4.2.20 <code>up_putc()</code></a><br>
    </ul>
    <a href="#systemtime">4.3 System Time and Clock</a>
    <ul>
      <a href="#basictimer">4.3.1 Basic System Timer</a><br>
      <a href="#timerhw">4.3.2 Hardware</a><br>
      <a href="#systcktime">4.3.3 System Tick and Time</a><br>
      <a href="#tickless">4.3.4 Tickless OS</a><br>
      <a href="#Watchdogs">4.3.5 Watchdog Timer Interfaces</a>
    </ul>
    <a href="#workqueues">4.4 Work Queues</a>
    <ul>
      <a href="#wqclasses">4.4.1 Classes of Work Queues</a>
      <ul>
        <a href="#hpwork">4.4.1.1 High Priority Kernel Work queue</a><br>
        <a href="#lpwork">4.4.1.2 Low Priority Kernel Work Queue</a><br>
        <a href="#usrwork">4.4.1.3 User-Mode Work Queue</a>
      </ul>
      <a href="#cmnwqifs">4.4.2 Common Work Queue Interfaces</a>
      <ul>
        <a href="#wqids">4.4.2.1 Work Queue IDs</a><br>
        <a href="#wqiftypes">4.4.2.2 Work Queue Interface Types</a><br>
        <a href="#wqintfs">4.4.2.3 Work Queue Interfaces</a>
        <ul>
          <a href="#workqueue">4.4.2.3.1 <code>work_queue()</code></a><br>
          <a href="#workcancel">4.4.2.3.2 <code>work_cancel()</code></a><br>
          <a href="#worksignal">4.4.2.3.3 <code>work_signal()</code></a><br>
          <a href="#workavailable">4.4.2.3.4 <code>work_available()</code></a><br>
          <a href="#workusrstart">4.4.2.3.5 <code>work_usrstart()</code></a><br>
          <a href="#lpworkboostpriority">4.4.2.3.6 <code>lpwork_boostpriority()</code></a><br>
          <a href="#lpworkrestorepriority">4.4.2.3.7 <code>lpwork_restorepriority()</code></a>
        </ul>
      </ul>
    </ul>
    <a href="#addrenv">4.5 Address Environments</a>
    <ul>
      <a href="#up_addrenv_create">4.5.1 <code>up_addrenv_create()</code></a><br>
      <a href="#up_addrenv_destroy">4.5.2 <code>up_addrenv_destroy()</code></a><br>
      <a href="#up_addrenv_vtext">4.5.3 <code>up_addrenv_vtext()</code></a><br>
      <a href="#up_addrenv_vdata">4.5.4 <code>up_addrenv_vdata()</code></a><br>
      <a href="#up_addrenv_heapsize">4.5.5 <code>up_addrenv_heapsize()</code></a><br>
      <a href="#up_addrenv_select">4.5.6 <code>up_addrenv_select()</code></a><br>
      <a href="#up_addrenv_restore">4.5.7 <code>up_addrenv_restore()</code></a><br>
      <a href="#up_addrenv_clone">4.5.8 <code>up_addrenv_clone()</code></a><br>
      <a href="#up_addrenv_attach">4.5.9 <code>up_addrenv_attach()</code></a><br>
      <a href="#up_addrenv_detach">4.5.10 <code>up_addrenv_detach()</code></a><br>
      <a href="#up_addrenv_ustackalloc">4.5.11 <code>up_addrenv_ustackalloc()</code></a><br>
      <a href="#up_addrenv_ustackfree">4.5.12 <code>up_addrenv_ustackfree()</code></a><br>
      <a href="#up_addrenv_vustack">4.5.13 <code>up_addrenv_vustack()</code></a><br>
      <a href="#up_addrenv_ustackselect">4.5.14 <code>up_addrenv_ustackselect()</code></a><br>
      <a href="#up_addrenv_kstackalloc">4.5.15 <code>up_addrenv_kstackalloc()</code></a><br>
      <a href="#up_addrenv_kstackfree">4.5.16 <code>up_addrenv_kstackfree()</code></a>
    </ul>
    <a href="#boardctl">4.6 <code>boardctl()</code> Application Interface</a><br>
    <a href="#exports">4.7 APIs Exported by NuttX to Architecture-Specific Logic</a>
    <ul>
      <a href="#osstart">4.7.1 <code>os_start()</code></a><br>
      <a href="#listmgmt">4.7.2 OS List Management APIs</a><br>
      <a href="#schedprocesstimer">4.7.3 <code>sched_process_timer()</code></a><br>
      <a href="#schedtimerexpiration">4.7.4 <code>sched_timer_expiration()</code></a><br>
      <a href="#schedalarmexpiration">4.7.5 <code>sched_alarm_expiration()</code></a><br>
      <a href="#irqdispatch">4.7.6 <code>irq_dispatch()</code></a>
    </ul>
    <a href="#shm">4.8 Shared Memory</a>
    <ul>
      <a href="#upshmat">4.8.1 <code>up_shmat()</code></a><br>
      <a href="#upshmdt">4.8.2 <code>up_shmdt()</code></a><br>
    </ul>
    <a href="#demandpaging">4.9 On-Demand Paging</a><br>
    <a href="#ledsupport">4.10 LED Support</a>
    <ul>
      <a href="#ledheaders">4.10.1 Header Files</a><br>
      <a href="#leddefinitions">4.10.2 LED Definitions</a><br>
      <a href="#ledapis">4.10.3 Common LED interfaces</a>
    </ul>
  </ul>
  <a href="#NxFileSystem">5.0 NuttX File System</a><br>
  <a href="#DeviceDrivers">6.0 NuttX Device Drivers</a>
  <ul>
    <a href="#chardrivers">6.1 Character Device Drivers</a><br>
    <ul>
       <a href="#serialdrivers">6.1.1 Serial Device Drivers</a><br>
       <a href="#tscdrivers">6.1.2 Touchscreen Device Drivers</a><br>
       <a href="#analogdrivers">6.1.3 Analog (ADC/DAC) Drivers</a><br>
       <a href="#pwmdrivers">6.1.4 PWM Drivers</a><br>
       <a href="#candrivers">6.1.5 CAN Drivers</a><br>
       <a href="#quadencoder">6.1.6 Quadrature Encoder Drivers</a><br>
       <a href="#timerdriver">6.1.7 Timer Drivers</a><br>
       <a href="#rtcriver">6.1.8 RTC Drivers</a><br>
       <a href="#wdogdriver">6.1.9 Watchdog Timer Drivers</a><br>
       <a href="#kbddriver">6.1.10 Keyboard/Keypad Drivers</a><br>
    </ul>
    <a href="#blockdrivers">6.2 Block Device Drivers</a><br>
    <a href="#specdrivers">6.3 Specialized Device Drivers</a>
    <ul>
       <a href="#ethdrivers">6.3.1 Ethernet Device Drivers</a><br>
       <a href="#spidrivers">6.3.2 SPI Device Drivers</a><br>
       <a href="#i2cdrivers">6.3.3 I2C Device Drivers</a><br>
       <a href="#fbdrivers">6.3.4 Frame Buffer Drivers</a><br>
       <a href="#lcddrivers">6.3.5 LCD Drivers</a><br>
       <a href="#mtddrivers">6.3.6 Memory Technology Device Drivers</a><br>
       <a href="#sdiodrivers">6.3.7 SDIO Device Drivers</a><br>
       <a href="#usbhostdrivers">6.3.8 USB Host-Side Drivers</a><br>
       <a href="#usbdevdrivers">6.3.9 USB Device-Side Drivers</a><br>
    </ul>
    <a href="#pwrmgmt">6.4 Power Management</a>
    <ul>
       <a href="#pmoverview">6.4.1 Overview</a><br>
       <a href="#pminterfaces">6.4.2 Interfaces</a><br>
       <a href="#pmcallbacks">6.4.3 Callbacks</a>
    </ul>
  </ul>
  <a href="#apndxconfigs">Appendix A: NuttX Configuration Settings</a><br>
  <a href="#apndxtrademarks">Appendix B:  Trademarks</a>
</ul>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
    <td>
      <h1>1.0 <a name="Introduction">Introduction</a></h1>
    </td>
  </tr>
</table>

<p><b>Overview</b>
  This document provides and overview of the NuttX build and configuration
  logic and provides hints for the incorporation of new processor/board architectures
  into the build.
</p>
<p>
  See also <code>arch/README.txt</code> and <code>configs/README.txt</code>.
</p>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
    <td>
      <h1>2.0 <a name="DirectoryStructure">Directory Structure</a></h1>
    </td>
  </tr>
</table>

<p>
  <b>Directory Structure</b>.
  The general directly layout for NuttX is very similar to the directory structure
  of the Linux kernel -- at least at the most superficial layers.
  At the top level is the main makefile and a series of sub-directories identified
  below and discussed in the following paragraphs:
</p>
<ul><pre>
.
|- nuttx
|   |-- <a href="#topmakefile">Makefile</a>
|   |-- Kconfig
|   |-- <a href="#DirStructDocumentation">Documentation</a>
|   |   `-- <i>(documentation files)</i>/
|   |-- <a href="#DirStructArch">arch</a>/
|   |   |-- Kconfig
|   |   |-- <i>&lt;arch-name&gt;</i>/
|   |   |   |-- include/
|   |   |   |   |--<i>&lt;chip-name&gt;</i>/
|   |   |   |   |  `-- <i>(chip-specific header files)</i>
|   |   |   |   |--<i>&lt;other-chips&gt;</i>/
|   |   |   |   `-- <i>(architecture-specific header files)</i>
|   |   |   `-- src/
|   |   |       |--<i>&lt;chip-name&gt;</i>/
|   |   |       |  `-- <i>(chip-specific source files)</i>
|   |   |       |--<i>&lt;other-chips&gt;</i>/
|   |   |       `-- <i>(architecture-specific source files)</i>
|   |   `-- <i>&lt;other-architecture directories&gt;</i>/
|   |-- <a href="#DirStructBinFmt">binfmt</a>/
|   |   |-- Makefile
|   |   |-- Kconfig
|   |   |-- <i>(binfmt-specific sub-directories)</i>/
|   |   |   `-- <i>(binfmt-specific source files)</i>
|   |   `-- <i>(common binfmt source files)</i>
|   |-- <a href="#DirStructConfigs">configs</a>/
|   |   |-- <i>&lt;board-name&gt;</i>/
|   |   |   |-- include/
|   |   |   |   `-- <i>(other board-specific header files)</i>
|   |   |   |-- src/
|   |   |   |   `-- <i>(board-specific source files)</i>
|   |   |   |---<i>&lt;config-name&gt;</i>/
|   |   |   |   `-- <i>(board configuration-specific source files)</i>
|   |   |   `---<i>(other configuration sub-directories for this board)</i>/
|   |   `-- <i>&lt;(other board directories)&gt;</i>/
|   |-- <a href="#DirStructDrivers">drivers</a>/
|   |   |-- Makefile
|   |   |-- Kconfig
|   |   |-- <i>(driver-specific sub-directories)/</i>
|   |   |   `-- <i>(driver-specific source files)</i>
|   |   `-- <i>(common driver source files)</i>
|   |-- <a href="#DirStructFs">fs</a>/
|   |   |-- Makefile
|   |   |-- Kconfig
|   |   |-- <i>(file system-specific sub-directories)</i>/
|   |   |   `-- <i>(file system-specific source files)</i>
|   |   `-- <i>(common file system source files)</i>
|   |-- <a href="#DirStructGraphics">graphics</a>/
|   |   |-- Makefile
|   |   |-- Kconfig
|   |   |-- <i>(feature-specific sub-directories)</i>/
|   |   |   `-- <i>(feature-specific source files library source files)</i>
|   |   `-- <i>(common graphics-related source files)</i>
|   |-- <a href="#DirStructInclude">include</a>/
|   |   |-- <i>(standard header files)</i>
|   |   |-- <i>(standard include sub-directories)</i>
|   |   |   `-- <i>(more standard header files)</i>
|   |   |-- <i>(non-standard include sub-directories)</i>
|   |       `-- <i>(non-standard header files)</i>
|   |-- <a href="#DirStructLib">libc</a>/
|   |   |-- Makefile
|   |   |-- Kconfig
|   |   `-- <i>(libc source files)</i>
|   |-- <a href="#DirStructLibXX">libxx</a>/
|   |   |-- Makefile
|   |   |-- Kconfig
|   |   `-- <i>(libxx management source files)</i>
|   |-- <a href="#DirStructMm">mm</a>/
|   |   |-- Makefile
|   |   |-- Kconfig
|   |   `-- <i>(memory management source files)</i>
|   |-- <a href="#DirStructNet">net</a>/
|   |   |-- Makefile
|   |   |-- Kconfig
|   |   |-- arp/
|   |   |   `-- <i>(ARP source files)</i>
|   |   |-- devif/
|   |   |   `-- <i>(Ethernet device interface source files)</i>
|   |   |-- icmp/
|   |   |   `-- <i>(ICMP source files)</i>
|   |   |-- igmp/
|   |   |   `-- <i>(IGMP source files)</i>
|   |   |-- iob/
|   |   |   `-- <i>(I/O buffering source files)</i>
|   |   |-- ipv6/
|   |   |   `-- <i>(IPv6 source files)</i>
|   |   |-- netdev/
|   |   |   `-- <i>(Socket device interface source files)</i>
|   |   |-- pkt/
|   |   |   `-- <i>(Packet socket source files)</i>
|   |   |-- route/
|   |   |   `-- <i>(Routing table source files)</i>
|   |   |-- socket/
|   |   |   `-- <i>(BSD socket source files)</i>
|   |   |-- tcp/
|   |   |   `-- <i>(TCP source files)</i>
|   |   |-- udp/
|   |   |   `-- <i>(UDP source files)</i>
|   |   `-- utils/
|   |       `-- <i>(Miscellaneous, utility source files)</i>
|   |-- <a href="#DirStructSched">sched</a>/
|   |   |-- Makefile
|   |   |-- Kconfig
|   |   `-- <i>(sched source files)</i>
|   |-- <a href="#DirStructSysCall">syscall</a>/
|   |   |-- Makefile
|   |   |-- Kconfig
|   |   `-- <i>(syscall source files)</i>
|   `-- <a href="#DirStructTools">tools</a>/
|       `-- <i>(miscellaneous scripts and programs)</i>
`- apps
    |-- <a href="#DirStructNetUtils">netutils</a>/
    |   |-- Makefile
    |   |-- Kconfig
    |   |-- <i>(network feature sub-directories)</i>/
    |   |   `-- <i>(network feature source files)</i>
    |   `-- <i>(netutils common files)</i>
    |--  <a href="#DirStructNshLib">nshlib</a>/
    |   |-- Makefile
    |   |-- Kconfig
    |   `-- <i>NuttShell (NSH) files</i>
    |-- <i>(Board-specific applications)</i>/
    |   |-- Makefile
    |   |-- Kconfig
    |   |-- <i>(Board-specific application sub-directories)</i>/
    |   |   `-- <i>(Board-specific application source files)</i>
    |   `-- <i>(Board-specific common files)</i>
    `-- <a href="#DirStructExamples">examples</a>/
        `-- <i>(example)</i>/
            |-- Makefile
            |-- Kconfig
            `-- <i>(example source files)</i>
</pre></ul>

<p>
  <b>Configuration Files</b>.
  The NuttX configuration consists of:
</p>
<ul>
  <li>
    <i>Processor architecture specific files</i>.
    These are the files contained in the <code>arch/</code><i>&lt;arch-name&gt;</i><code>/</code> directory
    and are discussed in a paragraph <a href="#archdirectorystructure">below</a>.
  </li>
  <li>
    <i>Chip/SoC specific files</i>.
    Each processor processor architecture is embedded in chip or <i>System-on-a-Chip</i> (SoC) architecture.
    The full chip architecture includes the processor architecture plus chip-specific interrupt logic,
    clocking logic, general purpose I/O (GIO) logic, and specialized, internal peripherals (such as UARTs, USB, etc.).
    <p>
      These chip-specific files are contained within chip-specific sub-directories in the
      <code>arch/</code><i>&lt;arch-name&gt;</i><code>/</code> directory and are selected via
      the <code>CONFIG_ARCH_name</code> selection.
    </p>
  </li>
  <li>
    <i>Board specific configurations</i>.
    In order to be usable, the chip must be contained in a board environment.
    The board configuration defines additional properties of the board including such things as
    peripheral LEDs, external peripherals (such as network, USB, etc.).
    <p>
      These board-specific configuration files can be found in the
      <code>configs/</code><i>&lt;board-name&gt;</i><code>/</code> sub-directories and are discussed
      in a paragraph <a href="#configsdirectorystructure">below</a>.
    </p>
  </li>
</ul>

<h2>2.1 <a name="DirStructDocumentation">Documentation</a></h2>

<p>
  General documentation for the NuttX OS resides in this directory.
</p>

<h2>2.2 <a name="DirStructArch">nuttx/arch</a></h2>

<h3><a name="archdirectorystructure">2.2.1 Subdirectory Structure</a></h3>
<p>
  This directory contains several sub-directories, each containing
  architecture-specific logic.
  The task of porting NuttX to a new processor consists of
  add a new subdirectory under <code>arch/</code> containing logic specific
  to the new architecture.
  The complete board port in is defined by the architecture-specific code in this
  directory (plus the board-specific configurations in the <code>config/</code>
  subdirectory).
  Each architecture must provide a subdirectory, <i>&lt;arch-name&gt;</i>
  under <code>arch/</code> with the following characteristics:
</p>
<ul><pre>
<i>&lt;arch-name&gt;</i>/
|-- include/
|   |--<i>&lt;chip-name&gt;</i>/
|   |  `-- <i>(chip-specific header files)</i>
|   |--<i>&lt;other-chips&gt;</i>/
|   |-- arch.h
|   |-- irq.h
|   |-- types.h
|   |-- limits.h
|   `-- syscall.h
`-- src/
    |--<i>&lt;chip-name&gt;</i>/
    |  `-- <i>(chip-specific source files)</i>
    |--<i>&lt;other-chips&gt;</i>/
    |-- Makefile
    `-- <i>(architecture-specific source files)</i>
</pre></ul>

<h3><a name="summaryofarchfiles">2.2.2 Summary of Files</a></h3>
<ul>
  <li>
    <code>include/</code><i>&lt;chip-name&gt;</i><code>/</code>
    This sub-directory contains chip-specific header files.
  </li>
  <li>
    <code>include/arch.h</code>:
    This is a hook for any architecture specific definitions that may
    be needed by the system.  It is included by <code>include/nuttx/arch.h</code>.
  </li>
  <li>
    <code>include/types.h</code>:
    This provides architecture/toolchain-specific definitions for
    standard types.  This file should <code>typedef</code>:
    <ul><code>
      _int8_t, _uint8_t, _int16_t, _uint16_t, _int32_t, _uint32_t_t
    </code></ul>
    <p>and if the architecture supports 24- or 64-bit integers</p>
    <ul><code>
      _int24_t, _uint24_t, int64_t, uint64_t
    </code></ul>
    <p>
      NOTE that these type names have a leading underscore character.  This
      file will be included(indirectly) by include/stdint.h and typedef'ed to
      the final name without the underscore character.  This roundabout way of
      doings things allows the stdint.h to be removed from the include/
      directory in the event that the user prefers to use the definitions
      provided by their toolchain header files
    </p>
    <p>
      And finally
    </p>
    <ul><code>
      irqstate_t
    </code></ul>
    <p>
      Must be defined to the be the size required to hold the interrupt
     enable/disable state.
    </p>
    <p>
      This file will be included by include/sys/types.h and be made
      available to all files.
    </p>
  </li>
  <li>
    <code>include/irq.h</code>:
    This file needs to define some architecture specific functions (usually
    inline if the compiler supports inlining) and some structures.  These include:
    <ul>
      <li>
        <code>struct xcptcontext</code>:
        This structures represents the saved context of a thread.
      </li>
      <li>
        <code>irqstate_t irqsave(void)</code>:
        Used to disable all interrupts.
      </li>
      <li>
        <code>void irqrestore(irqstate_t flags)</code>:
        Used to restore interrupt enables to the same state as before <code>irqsave()</code> was called.
      </li>
    </ul>
    <p>
      This file must also define <code>NR_IRQS</code>, the total number of IRQs supported
       by the board.
    </p>
  </li>
  <li>
    <code>include/syscall.h</code>:
    This file needs to define some architecture specific functions (usually
    inline if the compiler supports inlining) to support software interrupts
    or <i>syscall</i>s that can be used all from user-mode applications into
    kernel-mode NuttX functions.
    This directory must always be provided to prevent compilation errors.
    However, it need only contain valid function declarations if the architecture
    supports the <code>CONFIG_BUILD_PROTECTED</code> or <code>CONFIG_BUILD_KERNEL</code>configurations.
    <ul>
      <li>
        <code>uintptr_t sys_call0(unsigned int nbr)</code>:
        <code>nbr</code> is one of the system call numbers that can be found in <code>include/sys/syscall.h</code>.
        This function will perform a system call with no (additional) parameters.
      </li>
      <li>
        <code>uintptr_t sys_call1(unsigned int nbr, uintptr_t parm1)</code>:
        <code>nbr</code> is one of the system call numbers that can be found in <code>include/sys/syscall.h</code>.
        This function will perform a system call with one (additional) parameter.
      </li>
      <li>
        <code>uintptr_t sys_call2(unsigned int nbr, uintptr_t parm1, uintptr_t parm2)</code>:
        <code>nbr</code> is one of the system call numbers that can be found in <code>include/sys/syscall.h</code>.
        This function will perform a system call with two (additional) parameters.
      </li>
      <li>
        <code>uintptr_t sys_call3(unsigned int nbr, uintptr_t parm1, uintptr_t parm2, uintptr_t parm3)</code>:
        <code>nbr</code> is one of the system call numbers that can be found in <code>include/sys/syscall.h</code>.
        This function will perform a system call with three (additional) parameters.
      </li>
      <li>
        <code>uintptr_t sys_call4(unsigned int nbr, uintptr_t parm1, uintptr_t parm2, uintptr_t parm3, uintptr_t parm4)</code>:
        <code>nbr</code> is one of the system call numbers that can be found in <code>include/sys/syscall.h</code>.
        This function will perform a system call with four (additional) parameters.
      </li>
      <li>
        <code>uintptr_t sys_call5(unsigned int nbr, uintptr_t parm1, uintptr_t parm2, uintptr_t parm3, uintptr_t parm4, uintptr_t parm5)</code>:
        <code>nbr</code> is one of the system call numbers that can be found in <code>include/sys/syscall.h</code>.
        This function will perform a system call with five (additional) parameters.
      </li>
      <li>
        <code>uintptr_t sys_call6(unsigned int nbr, uintptr_t parm1, uintptr_t parm2, uintptr_t parm3, uintptr_t parm4, uintptr_t parm5, uintptr_t parm6)</code>:
        <code>nbr</code> is one of the system call numbers that can be found in <code>include/sys/syscall.h</code>.
        This function will perform a system call with six (additional) parameters.
      </li>
    </ul>
    <p>
      This file must also define <code>NR_IRQS</code>, the total number of IRQs supported
       by the board.
    </p>
  </li>
  <li>
    <code>src/</code><i>&lt;chip-name&gt;</i><code>/</code>
    This sub-directory contains chip-specific source files.
  </li>
  <li>
    <code>src/Makefile</code>:
    This makefile will be executed to build the targets <code>src/libup.a</code> and
    <code>src/up_head.o</code>.  The <code>up_head.o</code> file holds the entry point into the system
    (power-on reset entry point, for example).  It will be used in
    the final link with <code>libup.a</code> and other system archives to generate the
    final executable.
  </li>
  <li>
    <i>(architecture-specific source files)</i>.
    The file <code>include/nuttx/arch.h</code> identifies all of the APIs that must
    be provided by the architecture specific logic.  (It also includes
    <code>arch/</code><i>&lt;arch-name&gt;</i><code>/arch.h</code> as described above).
  </li>
</ul>

<h3><a name="supportedarchitectures">2.2.3 Supported Architectures</a></h3>
<p>
   <b>Architecture- and Chip-Specific Directories</b>.
   All processor architecture-specific directories are maintained in sub-directories of
   the <code>arch/</code> directory.
   Different chips or SoC's may implement the same processor core.
   Chip-specific logic can be found in sub-directories under the architecture
   directory.
   Current architecture/chip directories are summarized below:
</p>
<ul>
  <li><code>arch/sim</code>:
    A user-mode port of NuttX to the x86 Linux platform is available.
    The purpose of this port is primarily to support OS feature development.
    This port does not support interrupts or a real timer (and hence no
    round robin scheduler)  Otherwise, it is complete.
  </li>
  <p>NOTE: This target will not run on Cygwin probably for many reasons but
    first off because it uses some of the same symbols as does cygwind.dll.
  </p>

  <li><code>arch/arm</code>:
    This directory holds common ARM architectures.  At present, this includes
    the following subdirectories:
    <ul>
      <li><code>arch/arm/include</code> and <code>arch/arm/src/common</code>:
          Common ARM logic.
      </li>

      <li><code>arch/arm/include/c5471</code> and <code>arch/arm/src/c5471</code>:
        TI TMS320C5471 (also called TMS320DM180 or just C5471).
        NuttX operates on the ARM7 of this dual core processor.
        This port is complete, verified, and included in the NuttX release 0.1.1.
      </li>

      <li><code>arch/arm/include/dm320</code> and <code>arch/arm/src/dm320</code>:
        TI TMS320DM320 (also called just DM320).
        NuttX operates on the ARM9EJS of this dual core processor.
        This port complete, verified, and included in the NuttX release 0.2.1.
      </li>

      <li><code>arch/arm/include/lpc214x</code> and <code>arch/arm/src/lpc214x</code>:
        These directories provide support for NXP LPC214x family of
        processors.
        STATUS: This port boots and passes the OS test (apps/examples/ostest).
        The port is complete and verified.  As of NuttX 0.3.17, the port includes:
        timer interrupts, serial console, USB driver, and SPI-based MMC/SD card
        support.  A verified NuttShell configuration is also available.
      </li>

    </ul>
  </li>

  <li><code>configs/mcu123-lpc214x</code>:
    The mcu123.com lpc214x development board.
    This is a work in progress.
  </li>

  <li><code>arch/z16f</code>:
    Zilog z16f Microcontroller.
    This port uses the Zilog z16f2800100zcog Development Kit.
    This port was released with nuttx-0.3.7.
  </li>

    <li><code>arch/z80</code>:
    This directory holds 8-bit ZiLOG architectures.  At present, this includes the
    Zilog z80, ez80Acclaim! and z8Encore! Microcontrollers.
    <ul>
      <li><code>arch/z80/include</code> and <code>arch/z80/src/common</code>:
          Common logic.
      </li>

      <li><code>arch/z80/include/z80</code> and <code>arch/z80/src/z80</code>:
        The Z80 port was released in nuttx-0.3.6 has been verified using only a
        z80 instruction simulator.
        The set simulator  can be found in the NuttX GIT at
        http://sourceforge.net/p/nuttx/git/ci/master/tree/misc/sims/z80sim.
        This port also uses the SDCC toolchain (http://sdcc.sourceforge.net/)
        (verified with version 2.6.0 and 2.7.0).
      </li>

      <li><code>arch/z80/include/ez80</code> and <code>arch/z80/src/ez80</code>:
        The ez80Acclaim! port uses the ZiLOG ez80f0910200kitg development kit, eZ80F091 part,
        with the Zilog ZDS-II Windows command line tools.
        The development environment is Cygwin under WinXP.
        This is a work in progress.  Verified ez80 support will be announced in a future NuttX release.
      </li>

      <li><code>arch/z80/include/z8</code> and <code>arch/z80/src/z8</code>:
        The Z8Encore! port uses either the ZiLOG z8encore000zco development kit, Z8F6403 part,
        or the z8f64200100kit development kit, Z8F6423 part with the Zilog ZDS-II Windows command line
        tools.  The development environment is Cygwin under WinXP.
        The initial release, verified only on the ZDS-II ez8 simulator, was released in nuttx-0.3.9.
      </li>
    </ul>
    </li>
</ul>

<p>
  <b>Deprecated Architecture Directories</b>.
  The following architecture directories are deprecated.  They have been
  replaced by the logic in <code>arm/arm</code> and will deleted when
  <code>arch/arm</code> is fully verified.
</p>
<ul>
  <li><code>arch/c5471</code>:
    Replaced with <code>arch/arm/include/c5471</code> and
    <code>arch/arm/src/c5471</code>.
  </li>

  <li><code>arch/dm320</code>:
    Replaced with <code>arch/arm/include/dm320</code> and
    <code>arch/arm/src/dm320</code>.
  </li>
</ul>
<p>
  Other ports for the for the TI TMS320DM270 and for MIPS are in various states
  of progress
</p>

<h2>2.3 <a name="DirStructBinFmt">nuttx/binfmt</a></h2>

<p>
  The <code>binfmt/</code> subdirectory contains logic for loading binaries in the file
  system into memory in a form that can be used to execute them.
</p>

<h2>2.4 <a name="DirStructConfigs">nuttx/configs</a></h2>
<p>
  The <code>configs/</code> subdirectory contains configuration data for each board.
  These board-specific configurations plus the architecture-specific configurations in
  the <code>arch/</code> subdirectory complete define a customized port of NuttX.
</p>

<h3><a name="configsdirectorystructure">2.4.1 Subdirectory Structure</a></h3>
<p>
  The configs directory contains board specific configuration files.  Each board must
  provide a subdirectory &lt;board-name&gt; under <code>configs/</code> with the following characteristics:
</p>
<ul><pre>
<i>&lt;board-name&gt;</i>
|-- Kconfig
|-- include/
|   |-- board.h
|   `-- <i>(board-specific header files)</i>
|-- src/
|   |-- Makefile
|   `-- <i>(board-specific source files)</i>
|-- <i>&lt;config1-dir&gt;</i>
|   |-- Make.defs
|   |-- defconfig
|   `-- setenv.sh
|-- <i>&lt;config2-dir&gt;</i>
|   |-- Make.defs
|   |-- defconfig
|   `-- setenv.sh
|   ...
`-- <i>(other board-specific configuration sub-directories)</i>/
</pre></ul>

<h3><a name="summaryofconfigfiles">2.4.2 Summary of Files</a></h3>
<h4><a name="boardlogic">2.4.2.1 Board Specific Logic</a></h4>
<ul>
  <li>
    <code>include/</code>:
    This directory contains board specific header files.
    This directory will be linked as <code>include/arch/board</code> at configuration time
    and can be included via <code>#include &lt;arch/board/header.h&gt;</code>.
    These header file can only be included by files in <code>arch/</code><i>&lt;arch-name&gt;</i><code>/include/</code>
    and <code>arch/</code><i>&lt;arch-name&gt;</i><code>/src/</code>.
  </li>
  <li>
    <code>src/</code>:
    This directory contains board specific drivers.
    This directory will be linked as <config>arch/</code><i>&lt;arch-name&gt;</i><code>/src/board</code> at configuration
    time and will be integrated into the build system.
  </li>
  <li>
    <code>src/Makefile</code>:
    This makefile will be invoked to build the board specific drivers.
    It must support the following targets:  <code>libext$(LIBEXT)</code>, <code>clean</code>, and <code>distclean</code>.
  </li>
</ul>
<h4><a name="boardconfigsubdirs">2.4.2.2 Board Specific Configuration Sub-Directories</a></h4>
<p>
  The <code>configs/</code><i>&lt;board-name&gt;</i><code>/</code> sub-directory holds all of the
  files that are necessary to configure NuttX for the particular board.
  A board may have various different configurations using the common source files.
  Each board configuration is described by three files:  <code>Make.defs</code>, <code>defconfig</code>, and <code>setenv.sh</code>.
  Typically, each set of configuration files is retained in a separate configuration sub-directory
  (<i>&lt;config1-dir&gt;</i>, <i>&lt;config2-dir&gt;</i>, .. in the above diagram).

  The procedure for configuring NuttX is described <a href="#configuringnuttx">below</a>,
  This paragraph will describe the contents of these configuration files.
</p>
<ul>
  <li>
    <code>Make.defs</code>: This makefile fragment provides architecture and
    tool-specific build options.  It will be included by all other
    makefiles in the build (once it is installed).  This make fragment
    should define:
    <ul>
      <li>Tools: <code>CC</code>, <code>LD</code>, <code>AR</code>, <code>NM</code>, <code>OBJCOPY</code>, <code>OBJDUMP</code></li>
      <li>Tool options: <code>CFLAGS</code>, <code>LDFLAGS</code></li>
    </ul>
    <p>
      When this makefile fragment runs, it will be passed <code>TOPDIR</code> which
      is the path to the root directory of the build.  This makefile
      fragment should include:
    </p>
    <ul>
      <li><code>$(TOPDIR)/.config </code> : Nuttx configuration</li>
      <li><code>$(TOPDIR)/tools/Config.mk</code>  : Common definitions</li>
    </ul>
    <p>
      Definitions in the <code>Make.defs</code> file probably depend on some of the
      settings in the .<code>config</code> file.  For example, the <code>CFLAGS</code> will most likely be
      different if <code>CONFIG_DEBUG=y</code>.
    </p>
    <p>
      The included <code>tools/Config.mk</code> file contains additional definitions that may
      be overridden in the architecture-specific Make.defs file as necessary:
    </p>
    <ul>
      <li><code>COMPILE</code>, <code>ASSEMBLE</code>, <code>ARCHIVE</code>, <code>CLEAN</code>, and <code>MKDEP</code> macros</li>
    </ul>
  </li>
  <li>
    <p>
      <code>defconfig</code>: This is a configuration file similar to the Linux
      configuration file.  In contains variable/value pairs like:
    </p>
    <ul>
      <li><code>CONFIG_VARIABLE</code>=value</li>
    </ul>
    <p>
      This configuration file will be used at build time:
    </p>
    <p><ol>
      <li>As a makefile fragment included in other makefiles, and</li>
      <li>to generate <code>include/nuttx/config.h</code> which is included by
          most C files in the system.</li>
    </ol></p>
  </li>
  <li>
    <p>
      <code>setenv.sh</code>: This is a script that can be included that will be installed at
      the top level of the directory structure and can be sourced to set any
      necessary environment variables.
      You will most likely have to customize the default <code>setenv.sh</code> script in order
      for it to work correctly in your environment.
    </p>
  </li>
</ul>

<h3><a name="supportedboards">2.4.3 Supported Boards</a></h3>
<p>
  All of the specific boards supported by NuttX are identified below.
  These are the specific <i>&lt;board-name&gt;</i>'s that may be used to configure NuttX
  as described <a href="#configuringnuttx">below</a>.
</p>
<ul>
  <li><code>configs/avr32dev1</code>:
    This is a port of NuttX to the Atmel AVR32DEV1 board.  That board is
    based on the Atmel AT32UC3B0256 MCU and uses a specially patched
    version of the GNU toolchain:  The patches provide support for the
    AVR32 family.  That patched GNU toolchain is available only from the
    Atmel website.  STATUS: This port is functional but very basic.  There
    are configurations for NSH and the OS test.
  </li>

  <li><code>configs/c5471evm</code>:
    This is a port to the Spectrum Digital C5471 evaluation board.  The
    C5471 is a dual core processor from TI with an ARM7TDMI general purpose
    processor and a c54 DSP.  It is also known as TMS320DA180 or just DA180.
    NuttX runs on the ARM core and is built with with a GNU arm-nuttx-elf toolchain
    under Linux or Cygwin. This port is complete and verified.
  </li>

  <li><code>configs/demo9s12ne64</code>:
    Freescale DMO9S12NE64 board based on the MC9S12NE64 hcs12 cpu.  This
    port uses the m9s12x GCC toolchain.  STATUS:  (Still) under development; it
    is code complete but has not yet been verified.
  </li>

  <li><code>configs/ea3131</code>:
    Embedded Artists EA3131 Development bard.  This board is based on the
    an NXP LPC3131 MCU. This OS is built with the arm-nuttx-elf toolchain.
    STATUS:  This port is complete and mature.
  </li>

  <li><code>configs/eagle100</code>:
    Micromint Eagle-100 Development board.  This board is based on the
    an ARM Cortex-M3 MCU, the Luminary LM3S6918. This OS is built with the
    arm-nuttx-elf toolchain.  STATUS:  This port is complete and mature.
  </li>

  <li><code>configs/ez80f0910200kitg</code>
    ez80Acclaim! Microcontroller.  This port use the Zilog ez80f0910200kitg
    development kit, eZ80F091 part, and the Zilog ZDS-II Windows command line
    tools.  The development environment is Cygwin under WinXP.
  </li>

  <li><code>configs/ez80f910200zco</code>:
    ez80Acclaim! Microcontroller.  This port use the Zilog ez80f0910200zco
    development kit, eZ80F091 part, and the Zilog ZDS-II Windows command line
    tools.  The development environment is Cygwin under WinXP.
  </li>

  <li><code>configs/lm3s6965-ek</code>:
    Stellaris LM3S6965 Evaluation Kit.  This board is based on the
    an ARM Cortex-M3 MCU, the Luminary/TI LM3S6965. This OS is built with the
    arm-nuttx-elf toolchain.  STATUS:  This port is complete and mature.
  </li>

  <li><code>configs/lm3s8962-ek</code>:
    Stellaris LMS38962 Evaluation Kit. STATUS: contributed.
  </li>

  <li><code>configs/lpcxpresso-lpc1768</code>:
    Embedded Artists base board with NXP LPCExpresso LPC1768.  This board
    is based on the NXP LPC1768.  The Code Red toolchain is used by default.
  </li>

  <li><code>configs/mbed</code>:
    The configurations in this directory support the mbed board (http://mbed.org)
    that features the NXP LPC1768 microcontroller. This OS is also built
    with the arm-nuttx-elf toolchain.  STATUS:  Contributed.
  </li>

  <li><code>configs/mcu123-lpc214x</code>:
    This port is for the NXP LPC2148 as provided on the mcu123.com
    lpc214x development board.
    This OS is also built with the arm-nuttx-elf toolchain* under Linux or Cygwin.
    The port supports serial, timer0, spi, and usb.
  </li>

  <li><code>configs/mirtoo</code>:
    This is the port to the DTX1-4000L &quot;Mirtoo&quot; module.
    This module uses MicroChipPIC32MX250F128D.
    See the <a href="http://www.dimitech.com/">Dimitech</a> website for further information.
  </li>

  <li><code>configs/mx1ads</code>:
    This is a port to the Motorola MX1ADS development board.  That board
    is based on the Freescale i.MX1 processor.  The i.MX1 is an ARM920T.
    STATUS:  This port is nearly code complete but was never fully
    integrated due to tool-related issues.
  </li>

  <li><code>configs/ne64badge</code>:
    Future Electronics Group NE64 /PoE Badge board based on the
    MC9S12NE64 hcs12 cpu.  This port uses the m9s12x GCC toolchain.
    STATUS:  The port is code-complete but was never fully tested.
  </li>

  <li><code>configs/ntosd-dm320</code>:
    This port uses the Neuros OSD with a GNU arm-nuttx-elf toolchain* under Linux or Cygwin.
    See <a href="http://wiki.neurostechnology.com/index.php/Developer_Welcome">Neuros Wiki</a>
    for further information.
    NuttX operates on the ARM9EJS of this dual core processor.
    STATUS: This port is code complete, verified, and included in the
    NuttX 0.2.1 release.
  </li>

  <li><code>configs/nucleus2g</code>:
    This port uses the Nucleus 2G board (with Babel CAN board).
    This board features an NXP LPC1768 processor.
    See the <a href="http://www.2g-eng.com/">2G Engineering</a> website for more information about the Nucleus 2G.
  </li>

  <li><code>configs/olimex-lpc1766stk</code>:
    This port uses the Olimex LPC1766-STK board and a GNU GCC toolchain under
    Linux or Cygwin.  STATUS: Complete and mature.
  </li>

  <li><code>configs/olimex-lpc2378</code>:
    This port uses the Olimex-lpc2378 board and a GNU arm-nuttx-elf toolchain under
    Linux or Cygwin.  STATUS: ostest and NSH configurations available.
  </li>

  <li><code>configs/olimex-strp711</code>:
    This port uses the Olimex STR-P711 board arm-nuttx-elf toolchain* under Linux or Cygwin.
    See the <a href="http://www.olimex.com/dev/str-p711.html">Olimex</a> web site
    for further information.
    STATUS: Configurations for the basic OS test and NSH are complete and verified.
  </li>

  <li><code>configs/pcblogic-pic32mx</code>:
    This is the port of NuttX to the PIC32MX board from PCB Logic Design Co.
    This board features the MicroChip PIC32MX460F512L.
    The board is a very simple -- little more than a carrier for the PIC32
    MCU plus voltage regulation, debug interface, and an OTG connector.
    STATUS:  Code complete but testing has been stalled due to tool related problems
    (PICkit 2 does not work with the PIC32).
  </li>

  <li><code>configs/qemu-i486</code>:
    Port of NuttX to QEMU in i486 mode.  This port will also run on real i486
    hardware (Google the Bifferboard).
  </li>

  <li><code>configs/rgmp</code>:
    RGMP stands for RTOS and GPOS on Multi-Processor.  RGMP is a project for
    running GPOS and RTOS simultaneously on multi-processor platforms. You can
    port your favorite RTOS to RGMP together with an unmodified Linux to form a
    hybrid operating system. This makes your application able to use both RTOS
    and GPOS features.
    See the <a href="http://rgmp.sourceforge.net/wiki/index.php/Main_Page">RGMP Wiki</a> for further information about RGMP.
  </li>

  <li><code>configs/sam3u-ek</code>:
    The port of NuttX to the Atmel SAM3U-EK development board.
  </li>

  <li><code>configs/skp16c26</code>:
    Renesas M16C processor on the Renesas SKP16C26 StarterKit.  This port
    uses the GNU m32c toolchain.  STATUS:  The port is complete but untested
    due to issues with compiler internal errors.
  </li>

  <li><code>configs/stm3210e-eval</code>:
    STMicro STM3210E-EVAL development board based on the STMicro STM32F103ZET6
    microcontroller (ARM Cortex-M3).  This port uses the GNU Cortex-M3
    toolchain.
  </li>

  <li><code>configs/sim</code>:
    A user-mode port of NuttX to the x86 Linux platform is available.
    The purpose of this port is primarily to support OS feature development.
    This port does not support interrupts or a real timer (and hence no
    round robin scheduler)  Otherwise, it is complete.
  </li>

  <li><code>configs/us7032evb1</code>:
    This is a port of the Hitachi SH-1 on the Hitachi SH-1/US7032EVB1 board.
    STATUS:  This port is available as of release 0.3.18 of NuttX.  The port is basically
    complete and many examples run correctly.  However, there are remaining instabilities
    that make the port un-usable.  The nature of these is not understood; the behavior is
    that certain SH-1 instructions stop working as advertised.  This could be a silicon
    problem, some pipeline issue that is not handled properly by the gcc 3.4.5 toolchain
    (which has very limited SH-1 support to begin with), or perhaps with the CMON debugger.
    At any rate, I have exhausted all of the energy that I am willing to put into this cool
    old processor for the time being.
  </li>

  <li><code>configs/vsn</code>:
    ISOTEL NetClamps VSN V1.2 ready2go sensor network platform based on the
    STMicro STM32F103RET6.  Contributed by Uros Platise.
    See the <a href="http://isotel.eu/NetClamps/">Isotel</a> web site for further information
    about the NetClamps board.
  </li>

  <li><code>configs/xtrs</code>:
    TRS80 Model 3.  This port uses a vintage computer based on the Z80.
    An emulator for this computer is available to run TRS80 programs on a
    Linux platform (http://www.tim-mann.org/xtrs.html).
  </li>

  <li><code>configs/z16f2800100zcog</code>
    z16f Microcontroller.
    This port use the Zilog z16f2800100zcog development kit and the
    Zilog ZDS-II Windows command line tools.
    The development environment is Cygwin under WinXP.
  </li>

  <li><code>configs/z80sim</code>:
    z80 Microcontroller.  This port uses a Z80 instruction set simulator.
    That simulator can be found in the NuttX GIT
    <a href="http://sourceforge.net/p/nuttx/git/ci/master/tree/misc/sims/z80sim" target="_blank">here</a>.
    This port also the <a href="http://sdcc.sourceforge.net/">SDCC</a> toolchain
    under Linux or Cygwin(verified with version 2.6.0).
  </li>

  <li><code>configs/z8encore000zco</code>
    z8Encore! Microcontroller.  This port use the Zilog z8encore000zco
    development kit, Z8F6403 part, and the Zilog ZDS-II Windows command line
    tools.  The development environment is Cygwin under WinXP.
  </li>

  <li><code>configs/z8encore000zco</code>
    z8Encore! Microcontroller.  This port use the Zilog z8f64200100kit
    development kit, Z8F6423 part, and the Zilog ZDS-II Windows command line
    tools.  The development environment is Cygwin under WinXP.
  </li>

  <li><code>configs/z8f64200100kit</code>:
    z8Encore! Microcontroller.  This port use the Zilog z8f64200100kit
    development kit, Z8F6423 part, and the Zilog ZDS-II Windows command line
    tools.  The development environment is Cygwin under WinXP.
  </li>
</ul>

<p><small><blockquote>
  * A customized version of the <a href="http://www.buildroot.org">buildroot</a>
  is available to build these toolchains under Linux or Cygwin.
</blockquote></small></p>

<h3><a name="newboardconfig">2.4.4 Adding a New Board Configuration</a></h3>
<p>
  Okay, so you have created a new board configuration directory.
  Now, how do you hook this board into the configuration system so that you can select with <code>make menuconfig</code>?
</p>
<p>
  You will need modify the file <code>configs/Kconfig</code>.
  Let's look at the STM32F4-Discovery configuration in the <code>Kconfig</code> file and see how we would add a new board directory to the configuration.
  For this configuration let's say that you new board resides in the directory <code>configs/myboard</code>;
  It uses an MCU selected with <code>CONFIG_ARCH_CHIP_MYMCU</code>; and you want the board to be selected with <code>CONFIG_ARCH_BOARD_MYBOARD</code>.
  Then here is how you can clone the STM32F4-Discovery configuration in <code>configs/Kconfig</code> to support your new board configuration.
</p>
<p>
  In <code>configs/Kconfig</code> for the stm32f4-discovery, you will see a configuration definition like this:
<p>
<ul><pre>
config ARCH_BOARD_STM32F4_DISCOVERY
    bool "STMicro STM32F4-Discovery board"
    depends on ARCH_CHIP_STM32F407VG
    select ARCH_HAVE_LEDS
    select ARCH_HAVE_BUTTONS
    select ARCH_HAVE_IRQBUTTONS
    ---help---
        STMicro STM32F4-Discovery board based on the STMicro STM32F407VGT6 MCU.
</pre></ul>
<p>
  The above selects the STM32F4-Discovery board.
  The <code>select</code> lines say that the board has both LEDs and buttons and that the board can generate interrupts from the button presses.
  You can just copy the above configuration definition to a new location (notice that they the configurations are in alphabetical order).
  Then you should edit the configuration to support your board.
  The final configuration definition might look something like:
</p>
<ul><pre>
config ARCH_BOARD_MYBOARD
    bool "My very own board configuration"
    depends on ARCH_CHIP_MYMCU
    select ARCH_HAVE_LEDS
    select ARCH_HAVE_BUTTONS
    select ARCH_HAVE_IRQBUTTONS
    ---help---
        This options selects the board configuration for my very own board
        based on the MYMCU processor.
</pre></ul>
<p>
  Later in the <code>configs/Kconfig</code> file, you will see a long, long string configuration with lots of defaults like this:
</p>
<ul><pre>
config ARCH_BOARD
    string
    default "amber"               if ARCH_BOARD_AMBER
    default "avr32dev1"           if ARCH_BOARD_AVR32DEV1
    default "c5471evm"            if ARCH_BOARD_C5471EVM
...
    default "stm32f4discovery"    if ARCH_BOARD_STM32F4_DISCOVERY
...
</pre></ul>
<p>
  This logic will assign string value to a configuration variable called <code>CONFIG_ARCH_BOARD</code> that will name the directory where the board-specific files reside.
  In our case, these files reside in <code>configs/myboard</code> and we add the following to the long list of defaults (again in alphabetical order):
</p>
<ul><pre>
    default "myboar"              if ARCH_BOARD_MYBOARD
</pre></ul>
<p>
  Now the build system knows where to find your board configuration!
</p>
<p>
  And finally, add something like this near the bottom of <code>configs/myboard</code>:
</p>
<ul><pre>
if ARCH_BOARD_MYBOARD
source "configs/myboard/Kconfig"
endif
</pre></ul>
<p>
  This includes additional, board-specific configuration variable definitions in <code>configs/myboard/Kconfig</code>.
</p>

<h2>2.5 <a name="DirStructDrivers">nuttx/drivers</a></h2>

<p>
  This directory holds architecture-independent device drivers.
</p>
<ul><pre>
drivers/
|-- Kconfig
|-- Makefile
|-- analog/
|   |-- Kconfig
|   |-- Make.defs
|   `-- <i>(Common ADC and DAC driver source files)</i>
|-- bch/
|   |-- Kconfig
|   |-- Make.defs
|   `-- <i>(bch driver source files)</i>
|-- input/
|   |-- Kconfig
|   |-- Make.defs
|   `-- <i>(Common touchscreen and keypad driver source files)</i>
|-- lcd/
|   |-- Kconfig
|   |-- Make.defs
|   `-- <i>(Common LCD driver source files)</i>
|-- mmcsd/
|   |-- Kconfig
|   |-- Make.defs
|   `-- <i>(Common MMC/SD card driver source files)</i>
|-- mtd/
|   |-- Kconfig
|   |-- Make.defs
|   `-- <i>(Common memory technology device driver source files)</i>
|-- net/
|   |-- Kconfig
|   |-- Make.defs
|   `-- <i>(Common network driver source files)</i>
|-- sensors/
|   |-- Kconfig
|   |-- Make.defs
|   `-- <i>(Common sensor driver source files)</i>
|-- serial/
|   |-- Kconfig
|   |-- Make.defs
|   `-- <i>(Files for the Calypso SERCOMM driver)</i>
|-- serial/
|   |-- Kconfig
|   |-- Make.defs
|   `-- <i>(Common front-end character drivers for chip-specific UARTs)</i>
|-- usbdev/
|   |-- Kconfig
|   |-- Make.defs
|   `-- <i>(Common USB device driver source files)</i>
|-- usbhost/
|   |-- Kconfig
|   |-- Make.defs
|   `-- <i>(Common USB host driver source files)</i>
|-- wireless/
|   |-- Kconfig
|   |-- Make.defs
|   `-- <i>(Common wireless driver source files)</i>
`-- <i>(Various common driver source files)</i>
</pre></ul>

<h2>2.6 <a name="DirStructFs">nuttx/fs</a></h2>

<p>
  This directory contains the NuttX file system.
  This file system is described <a href="#NxFileSystem">below</a>.
</p>
<ul><pre>
fs/
|-- Kconfig
|-- Makefile
|-- fat/
|   |-- Kconfig
|   |-- Make.defs
|   `-- <i>(FAT file system source files)</i>
|-- mmap/
|   |-- Kconfig
|   |-- Make.defs
|   `-- <i>(RAM-based file mapping source files)</i>
|-- nfs/
|   |-- Kconfig
|   |-- Make.defs
|   `-- <i>(NFS client file system source files)</i>
|-- nxffs/
|   |-- Kconfig
|   |-- Make.defs
|   `-- <i>(NuttX Flash File System (NXFFS) source files)</i>
|-- romfs/
|   |-- Kconfig
|   |-- Make.defs
|   `-- <i>(ROMFS file system source files)</i>
 `-- <i>(common file system source files)</i>
</pre></ul>

<h2>2.7 <a name="DirStructGraphics">nuttx/graphics</a></h2>

<p>
  This directory contains files for graphics/video support under NuttX.
</p>
<ul><pre>
graphics/
|-- Kconfig
|-- Makefile
|-- nxbe/
|   |-- Make.defs
|   `-- <i>(NuttX graphics back-end (NXBE) source files)</i>
|-- nxfont/
|   |-- Make.defs
|   `-- <i>(NuttX graphics font-related (NXFONT) source files)</i>
|-- nxglib/
|   |-- Make.defs
|   `-- <i>(NuttX graphics library (NXGL) source files)</i>
|-- nxmu/
|   |-- Make.defs
|   `-- <i>(NuttX graphics multi-user (NXMU) server source files)</i>
|-- nxsu/
|   |-- Make.defs
|   `-- <i>(NuttX graphics single-user (NXSU) source files)</i>
`-- <i>(common file system source files)</i>
</pre></ul>

<h2>2.8 <a name="DirStructInclude">nuttx/include</a></h2>
<p>
  This directory holds NuttX header files.
  Standard header files file retained in can be included in the <i>normal</i> fashion:
</p>
<ul>
  <code>include &lt;stdio.h&gt;</code><br>
  <code>include &lt;sys/types.h&gt;</code><br>
  etc.
</ul>
<p>
  Directory structure:
</p>
<ul><pre>
include/
|-- <i>(standard header files)</i>
|-- arpa/
|   `-- <i>(Standard header files)</i>
|-- cxx/
|   `-- <i>(C++ standard header files)</i>
|-- netinet/
|   `-- <i>(Standard header files)</i>
|-- nuttx/
|   |-analog/
|   |  `-- <i>(Analog driver header files)</i>
|   |-audio/
|   |  `-- <i>(Audio driver header files)</i>
|   |-binfmt/
|   |  `-- <i>(Binary format header files)</i>
|   |-fs/
|   |  `-- <i>(File System header files)</i>
|   |-input/
|   |  `-- <i>(Input device driver header files)</i>
|   |-lcd/
|   |  `-- <i>(LCD driver header files)</i>
|   |-mtd/
|   |  `-- <i>(Memory technology device header files)</i>
|   |-serial/
|   |  `-- <i>(Serial driver header files)</i>
|   |-net/
|   |  `-- <i>(Networking header files)</i>
|   |-nx/
|   |  `-- <i>(NX graphics header files)</i>
|   |-power/
|   |  `-- <i>(Power management header files)</i>
|   |-sensors/
|   |  `-- <i>(Sensor device driver header files)</i>
|   |-sercomm/
|   |  `-- <i>(SERCOMM driver header files)</i>
|   |-serial/
|   |  `-- <i>(Serial driver header files)</i>
|   |-spi/
|   |  `-- <i>(SPI driver header files)</i>
|   |-syslog/
|   |  `-- <i>(SYSLOG header files)</i>
|   |-usb/
|   |  `-- <i>(USB driver header files)</i>
|   `-wireless/
|      `-- <i>(Wireless device driver header files)</i>
`- sys/
    `-- <i>(More standard header files)</i>
</per></ul>

<h2>2.9 <a name="DirStructLib">nuttx/libc</a></h2>
<p>
  This directory holds a collection of standard libc-like functions with custom
  interfaces into NuttX.
</p>
<p>
  Normally the logic in this file builds to a single library (<code>libc.a</code>).
  However, if NuttX is built as a separately compiled kernel (with <code>CONFIG_BUILD_PROTECTED=y</code> or <code>CONFIG_BUILD_KERNEL=y</code>), then the contents of this directory are built as two libraries:
  One for use by user programs (<code>libuc.a</code>) and one for use only within the &lt;kernel&gt; space (<code>libkc.a</code>).
</p>
<p>
  These user/kernel space libraries (along with the sycalls of <a href="#DirStructSyscall"><code>nuttx/syscall</code></a>) are needed to support the two differing protection domains.
</p>
<p>
  Directory structure:
</p>
<ul><pre>
libc/
|-- libgen/
|   `-- <i>(Implementation of functions from libgen.h)</i>
|-- math/
|   `-- <i>(Implementation of functions from fixedmath.h)</i>
|-- misc/
|   `-- <i>(Implementation of miscellaneous library functions)</i>
|-- mqueue/
|   `-- <i>(Implementation of some functions from mqueue.h)</i>
|-- net/
|   `-- <i>(Implementation of network-related library functions)</i>
|-- queue/
|   `-- <i>(Implementation of functions from queue.h)</i>
|-- sched/
|   `-- <i>(Implementation of some functions from sched.h)</i>
|-- semaphore/
|   `-- <i>(Implementation of some functions from semaphore.h)</i>
|-- signal/
|   `-- <i>(Implementation of some functions from signal.h)</i>
|-- stdio/
|   `-- <i>(Implementation of functions from stdio.h)</i>
|-- stdlib/
|   `-- <i>(Implementation of functions from stdlib.h)</i>
|-- string/
|   `-- <i>(Implementation of functions from string.h)</i>
|-- time/
|   `-- <i>(Implementation of some functions from time.h)</i>
`-- unistd/
    `-- <i>(Implementation of some functions from unistd.h)</i>
</per></ul>

<h2>2.10 <a name="DirStructLibXX">nuttx/libxx</a></h2>
<p>
  This directory holds a tiny, minimal standard std C++ that can be used to
  build some, simple C++ applications in NuttX.
</p>

<h2>2.11 <a name="DirStructMm">nuttx/mm</a></h2>
<p>
  This is the NuttX memory manager.
</p>

<h2>2.12 <a name="DirStructNet">nuttx/net</a></h2>
<p>
  This directory contains the implementation of the NuttX networking layer including internal socket APIs.
</P>

<h2>2.13 <a name="DirStructSched">nuttx/sched</a></h2>
<p>
  The files forming core of the NuttX RTOS reside here.
</p>

<h2>2.14 <a name="DirStructSyscall">nuttx/syscall</a></h2>
<p>
  If NuttX is built as a separately compiled kernel (with <code>CONFIG_BUILD_PROTECTED=y</code> or <code>CONFIG_BUILD_KERNEL=y</code>),
  then the contents of this directory are built.
  This directory holds a syscall interface that can be used for communication
  between user-mode applications and the kernel-mode RTOS.
</p>

<h2>2.15 <a name="DirStructTools">nuttx/tools</a></h2>
<p>
  This directory holds a collection of tools and scripts to simplify
  configuring, building and maintaining NuttX.
</p>
<ul><pre>
tools/
|-- Makefile.host
|-- Makefile.export
|-- README.txt
|-- configure.sh / configure.bat
|-- cfgparser.c
|-- cfgparser.h
|-- copydir.sh / copydir.bat
|-- define.sh / define.bat
|-- incdir.sh / indir.bat
|-- indent.sh
|-- link.sh / link.bat
|-- mkconfig.c
|-- mkdeps.sh / mkdeps.bat
|-- mkexport.sh
|-- mkimage.sh
|-- mknulldeps.sh
|-- mkromfsimg.sh
|-- mksyscall.c
|-- mkversion.c
|-- unlink.sh / unlink.bat
|-- version.sh
`-- zipme.sh
</pre></ul>

<p>
  Refer to the README file in the <code>tools</code> directory for more information about the individual files.
  Some of these tools are discussed below as well in the discussion of <a href="#configandbuild">configuring and building</a> NuttX.
</p>

<h2>2.16 <a name="topmakefile">nuttx/Makefile</a></h2>
<p>
  The top-level <code>Makefile</code> in the <code>${TOPDIR}</code> directory contains all of the top-level control
  logic to build NuttX.
  Use of this <code>Makefile</code> to build NuttX is described <a href="#buildingnuttx">below</a>.
</p>

<h2>2.17 <a name="DirStructNetUtils">apps/netutils</a></h2>
<p>
  This directory contains most of the network applications.
  Some of these are original with NuttX (like tftpc and dhcpd) and others were leveraged from the uIP-1.0 apps directory.
  As the uIP apps/README says, these applications &quot;are not all heavily tested.&quot;
</p>
<ul><pre>
netutils/
|-- Kconfig
|-- Makefile
|-- dhcdp/
|   |-- Kconfig
|   |-- Make.defs
|   `-- <i>(DHCP client source files)</i>
|-- dhcpd/
|   |-- Kconfig
|   |-- Make.defs
|   `-- <i>(DHCP server source files)</i>
|-- ftpc/
|   |-- Kconfig
|   |-- Make.defs
|   `-- <i>(FTP client source files)</i>
|-- ftpd/
|   |-- Kconfig
|   |-- Make.defs
|   `-- <i>(FTP server source files)</i>
|-- resolv/
|   |-- Kconfig
|   |-- Make.defs
|   `-- <i>(resolv source files)</i>
|-- resolv/
|   |-- Kconfig
|   |-- Make.defs
|   `-- <i>(resolv source files)</i>
|-- smtp/
|   |-- Kconfig
|   |-- Make.defs
|   `-- <i>(smtp source files)</i>
|-- telnetd/
|   |-- Kconfig
|   |-- Make.defs
|   `-- <i>(Telnet client source files)</i>
|-- tftpc/
|   |-- Kconfig
|   |-- Make.defs
|   `-- <i>(TFTP client source files)</i>
|-- thttpd/
|   |-- Kconfig
|   |-- Make.defs
|   `-- <i>(thttpd HTTP server source files)</i>
|-- netlib/
|   |-- Kconfig
|   |-- Make.defs
|   `-- <i>(netlib source files)</i>
|-- weblclient/
|   |-- Kconfig
|   |-- Make.defs
|   `-- <i>(webclient source files)</i>
|-- webserver/
|   |-- Kconfig
|   |-- Make.defs
|   `-- <i>(uIP webserver source files)</i>
`-- <i>(netutils common files)</i>
</pre></ul>

<h2>2.18 <a name="DirStructNshLib">apps/nshlib</a></h2>
<p>
  This directory contains for the core of the NuttShell (NSH) application.
</p>

<h2>2.19 <a name="DirStructExamples">apps/examples</a></h2>
<p>
  Example and test programs to build against.
</p>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
    <td>
      <h1>3.0 <a name="configandbuild">Configuring and Building</a></h1>
    </td>
  </tr>
</table>

<h2><a name="configuringnuttx">3.1 Configuring NuttX</a></h2>
<p>
  <b>Manual Configuration</b>.
  Configuring NuttX requires only copying the
  <a href="#boardconfigsubdirs">board-specific configuration files</a> into the top level directory which appears in the make files as the make variable, <code>${TOPDIR}</code>.
  This could be done manually as follows:
</p>
<ul>
  <li>Copy <code>configs/</code><i>&lt;board-name&gt;</i><code>/[</code><i>&lt;config-dir&gt;</i><code>/]Make.defs</code> to <code>${TOPDIR}/Make.defs</code>,<li>
  <li>Copy <code>configs/</code><i>&lt;board-name&gt;</i><code>/[</code><i>&lt;config-dir&gt;</i><code>/]setenv.sh</code> to <code>${TOPDIR}/setenv.sh</code>, and</li>
  <li>Copy <code>configs/</code><i>&lt;board-name&gt;</i><code>/[</code><i>&lt;config-dir&gt;</i><code>/]defconfig</code> to <code>${TOPDIR}/.config</code></li>
</ul>

<p>
  Where <i>&lt;board-name&gt;</i> is the name of one of the sub-directories of the
  NuttX <a href="#DirStructConfigs"><code>configs/</code></a> directory.
  This sub-directory name corresponds to one of the supported boards
  identified <a href="#supportedboards">above</a>.
  &lt;config-dir&gt; is the optional, specific configuration directory for the board.
  And &lt;app-dir&gt; is the location of the optional application directory.
</p>
<p>
  <b>Automated Configuration</b>.
  There is a script that automates these steps.  The following steps will
  accomplish the same configuration:
</p>
<ul><pre>
  cd tools
  ./configure.sh <i>&lt;board-name&gt;</i>[/<i>&lt;config-dir&gt;</i>]
</pre></ul>

<p>
  There is an alternative Windows batch file, <code>configure.bat</code>,  that can be used instead of <code>configure.sh</code> in the windows native environment like:
</p>
<ul><pre>
  cd tools
  configure.bat <i>&lt;board-name&gt;</i>[\<i>&lt;config-dir&gt;</i>]
</pre></ul>
<p>
  See <code>tools/README.txt</code> for more information about these scripts.
</p>

<p>
  If your application directory is not in the standard location (<code>../apps</code> or <code>../apps-&lt;version&gt</code>),
  then you should also specify the location of the application directory on the command line like:
</p>
<ul><pre>
  cd tools
  ./configure.sh -a &lt;app-dir&gt; <i>&lt;board-name&gt;</i>[/<i>&lt;config-dir&gt;</i>]
</pre></ul>

<p>
  <b>Version Files</b>.
  The NuttX build expects to find a version file located in the top-level NuttX build directory.
  That version file is called <code>.version</code>.
  The correct version file is installed in each versioned NuttX released.
  However, if you are working from an GIT snapshot, then there will be no version file.
  If there is no version file, the top-level <code>Makefile</code> will create a dummy <code>.version</code> file on the first make.
  This dummy version file will contain all zeroes for version information.
  If that is not what you want, they you should run the <code>version.sh</code> script to create a better <code>.version</code> file.
</p>

<p>
  You can get help information from the <code>version.sh</code> script using the <code>-h</code> option.
  For example:
</p>
<ul><pre>
$ tools/version.sh -h
tools/version.sh is a tool for generation of proper version files for the NuttX build

USAGE: tools/version.sh [-d|-h] [-b build] -v &lt;major.minor&gt; &lt;outfile-path&gt;

Where:
        -d
                Enable script debug
        -h
                show this help message and exit
        -v &lt;major.minor&gt;
                The NuttX version number expressed a major and minor number separated
                by a period
        &lt;outfile-path&gt;
                The full path to the version file to be created
</pre></ul>

<p>
  As an example, the following command will generate a version file for version 6.1 using the current GIT revision number:
</p>
<ul><pre>
tools/version.h -v 6.1 .version
</pre></ul>

<p>
  The <code>.version</code> file is also used during the build process to create a C header file at <code>include/nuttx/version.h</code> that contains the same version information.
  That version file may be used by your C applications for, as an example, reporting version information.
</p>

<p>
  <b>Additional Configuration Steps</b>.
  The remainder of configuration steps will be performed by <a href="#topmakefile"><code>${TOPDIR}/Makefile</code></a>
  the first time the system is built as described below.
</p>

<h2><a name="buildingnuttx">3.2 Building NuttX</a></h2>
<p>
  <b>Building NuttX</b>.
   Once NuttX has been configured as described <a href="#configuringnuttx">above</a>, it may be built as follows:
</p>
<ul><pre>
cd ${TOPDIR}
source ./setenv.sh
make
</pre></ul>
<p>
  The <code>${TOPDIR}</code> directory holds:
</p>
<ul>
  <li>The top level <a href="#topmakefile"><code>Makefile</code></a> that controls the NuttX build.
</ul>
<p>
  That directory also holds:
</p>
<ul>
  <li>The makefile fragment <a href="#boardconfigsubdirs"><code>.config</code></a> that describes the current configuration.</li>
  <li>The makefile fragment <a href="#boardconfigsubdirs"><code>Make.defs</code></a> that provides customized build targets, and</li>
  <li>The shell script <a href="#boardconfigsubdirs"><code>setenv.sh</code></a> that sets up the configuration environment for the build.</li>
</ul>
<p>
The <a href="#boardconfigsubdirs"><code>setenv.sh</code></a> contains Linux/Cygwin environmental settings that are needed for the build.
The specific environmental definitions are unique for each board but should include, as a minimum, updates to the <code>PATH</code> variable to include the full path to the architecture-specific toolchain identified in <a href="#boardconfigsubdirs"><code>Make.defs</code></a>.
The <a href="#boardconfigsubdirs"><code>setenv.sh</code></a> only needs to be source'ed at the beginning of a session.
The system can be re-made subsequently by just typing <code>make</code>.
</p>
<p>
  <b>First Time Make.</b>
  Additional configuration actions will be taken the first time that system is built.
  These additional steps include:
</p>
<ul>
  <li>Auto-generating the file <code>include/nuttx/config.h</code> using the <code>${TOPDIR}/.config</code> file.</li>
  <li>Auto-generating the file  <code>${TOPDIR}/.version</code> with version 0.0 if one does not exist.</li>
  <li>Auto-generating the file <code>include/nuttx/version.h</code> using the <code>${TOPDIR}/.version</code> file.</li>
  <li>Creating a link to <code>${TOPDIR}/arch/</code><i>&lt;arch-name&gt;</i><code>/include</code> at <code>${TOPDIR}/include/arch</code>.</li>
  <li>Creating a link to <code>${TOPDIR}/configs/</code><i>&lt;board-name&gt;</i><code>/include</code> at <code>${TOPDIR}/include/arch/board</code>.</li>
  <li>Creating a link to <code>${TOPDIR}/configs/</code><i>&lt;board-name&gt;</i><code>/src</code> at <code>${TOPDIR}/arch/</code><i>&lt;arch-name&gt;</i><code>/src/board</code></li>
  <li>Creating a link to <code>${APPDIR}/include</code> at <code>${TOPDIR}/include/apps</code></li>
  <li>Creating make dependencies.
</ul>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
    <td>
      <h1>4.0 <a name="ArchAPIs">Architecture APIs</a></h1>
    </td>
  </tr>
</table>

<p>
  The file <code>include/nuttx/arch.h</code> identifies by prototype all of the APIs that must
  be provided by the architecture specific logic.
  The internal OS APIs that architecture-specific logic must
  interface with also also identified in <code>include/nuttx/arch.h</code> or in
  other header files.
</p>

<h2><a name="naming">4.1 Naming and Header File Conventions</a></h2>

<ul>
  <li>
    <p>
      <b>Common Microprocessor Interfaces</b>.
      Any interface that is common to all microprocessors should be prefixed with <code>up_</code> and prototyped in <code>include/nuttx/arch.h</code>.
      The definitions in that header file provide the common interface between NuttX and the architecture-specific implementation in <code>arch/</code>.
    </p>
    <blockquote><small>
      <code>up_</code> is supposed to stand for microprocessor; the <code>u</code> is like the Greek letter micron: <i></i>.    So it would be <code>P</code> which is a common shortening of the word microprocessor.  I don't like that name very much.  I wish I would have used a more obvious prefix like <code>arch_</code> instead -- then I would not have to answer this question so often.
    </small></blockquote>
  </li>
  <li>
    <p>
      <b>Microprocessor-Specific Interfaces</b>.
      An interface which is unique to a certain microprocessor should be prefixed with the name of the microprocessor, for example <code>stm32_</code>, and be prototyped in some header file in the <code>arch/</code> directories.
    </p>
    <p>
      There is also a <code>arch/<architecture>/include/<chip>/chip.h</code> header file that can be used to communicate other microprocessor-specific information between the board logic and even application logic.
      Application logic may, for example, need to know specific capabilities of the chip.
      Prototypes in that <code>chip.h</code> header file should follow the microprocessor-specific naming convention.
    </p>
  </li>
  <li>
    <p>
      <b>Common Board Interfaces</b>.
      Any interface that is common to all boards should be prefixed with <code>board_</code> and should also be prototyped in <code>include/nuttx/arch.h</code>.
      These <code>board_</code> definitions provide the interface between the board-level logic and the architecture-specific logic.
    </p>
    <p>
      There is also a <code>configs/<board>/include/board.h</code> header file that can be used to communicate other board-specific information between the architecture logic and even application logic.
      Any definitions which are common between a single architecture and several boards should go in this <code>board.h</code> header file;
      <code>include/nuttx/arch.h</code>is reserved for board-related definitions common to all architectures.
    </p>
  <li>
    <p>
      <b>Board-Specific Interfaces</b>.
      Any interface which is unique to a board should be prefixed with the board name, for example <code>stm32f4discovery_</code>.
      Sometimes the board name is too long so <code>stm32_</code> would be okay too.
      These should be prototyped in <code>configs/<board>/src/<board>.h</code> and should not be used outside of that directory since board-specific definitions have no meaning outside of the board directory.
  </li>
</ul>

<h2><a name="imports">4.2 APIs Exported by Architecture-Specific Logic to NuttX</a></h2>
<h3><a name="upinitialize">4.2.1 <code>up_initialize()</code></a></h3>

<p><b>Function Prototype</b>: <code>void up_initialize(void);</code></p>

<p><b>Description</b>.
  <code>up_initialize()</code> will be called once during OS
  initialization after the basic OS services have been
  initialized.  The architecture specific details of
  initializing the OS will be handled here.  Such things as
  setting up interrupt service routines, starting the
  clock, and registering <a href="#DeviceDrivers">device drivers</a> are some of the
  things that are different for each processor and hardware
  platform.
</p>
<p>
  <code>up_initialize()</code> is called after the OS initialized but
  before the init process has been started and before the
  libraries have been initialized.  OS services and driver
  services are available.
</p>

<h3><a name="upidle">4.2.2 <code>up_idle()</code></a></h3>
<p><b>Function Prototype</b>: <code>void up_idle(void);</code></p>

<p><b>Description</b>.
  <code>up_idle()</code> is the logic that will be executed
  when their is no other ready-to-run task.  This is processor
  idle time and will continue until some interrupt occurs to
  cause a context switch from the idle task.
</p>
<p>
  Processing in this state may be processor-specific. e.g.,
  this is where power management operations might be performed.
</p>

<h3><a name="upinitialstate">4.2.3 <code>up_initial_state()</code></a></h3>
<p><b>Function Prototype</b>: <code>void up_initial_state(FAR struct tcb_s *tcb);</code></p>

<p><b>Description</b>.
  A new thread is being started and a new TCB has been created.
  This function is called to initialize the processor specific portions of the new TCB.
</p>
<p>
  This function must setup the initial architecture registers and/or stack so that execution
  will begin at tcb->start on the next context switch.
</p>
<p>
  This function may also need to set up processor registers so that the new thread executes
  with the correct privileges.
  If <code>CONFIG_BUILD_PROTECTED</code> or <code>CONFIG_BUILD_KERNEL</code> have been selected in the NuttX configuration, then special initialization may need to be performed depending on the task type specified in the TCB's flags field:
  Kernel threads will require kernel-mode privileges;
  User tasks and pthreads should have only user-mode privileges.
  If neither <code>CONFIG_BUILD_PROTECTED</code> nor <code>CONFIG_BUILD_KERNEL</code> have been selected, then all threads should have kernel-mode privileges.
</p>

<h3><a name="upcreatestack">4.2.4 <code>up_create_stack()</code></a></h3>
<p><b>Function Prototype</b>: <code>STATUS up_create_stack(FAR struct tcb_s *tcb, size_t stack_size, uint8_t ttype);</code></p>

<p><b>Description</b>.
  Allocate a stack for a new thread and setup up stack-related information in the TCB.
</p>
<p>
  The following TCB fields must be initialized:
</p>
<ul>
  <li><code>adj_stack_size</code>: Stack size after adjustment for hardware,
    processor, etc.  This value is retained only for debug
    purposes.</li>
  <li><code>stack_alloc_ptr</code>: Pointer to allocated stack</li>
  <li><code>adj_stack_ptr</code>: Adjusted <code>stack_alloc_ptr</code> for HW.  The
    initial value of the stack pointer.
</ul>

<p><b>Input Parameters</b>:</p>
<ul>
  <li>
    <p>
      <code>tcb</code>: The TCB of new task.
    </p>
  </li>
  <li>
    <p>
      <code>stack_size</code>:  The requested stack size.  At least this much must be allocated.
    </p>
  </li>
  <li>
    <p>
      <code>ttype</code>:  The thread type.
      This may be one of following (defined in <code>include/nuttx/sched.h</code>):
    </p>
    <ul>
      <li><code>TCB_FLAG_TTYPE_TASK</code>: Normal user task</li>
      <li><code>TCB_FLAG_TTYPE_PTHREAD</code>: User pthread</li>
      <li><code>TCB_FLAG_TTYPE_KERNEL</code>: Kernel thread</li>
    </ul>
    <p>
      This thread type is normally available in the flags field of the TCB, however, there are certain contexts where the TCB may not be fully initialized when up_create_stack is called.
    </p>
    <p>
      If <code>CONFIG_BUILD_PROTECTED</code> or <code>CONFIG_BUILD_KERNEL</code> are defined, then this thread type may affect how the stack is allocated.  For example, kernel thread stacks should be allocated from protected kernel memory.  Stacks for user tasks and threads must come from memory that is accessible to user code.
    </p>
  </li>
</ul>

<h3><a name="upusestack">4.2.5 <code>up_use_stack()</code></a></h3>
<p><b>Function Prototype</b>:
  <code>STATUS up_use_stack(FAR struct tcb_s *tcb, FAR void *stack, size_t stack_size);</code>
</p>

<p><b>Description</b>.
  Setup up stack-related information in the TCB using pre-allocated stack memory.
  This function is called only from <code>task_init()</code> when a task or kernel thread is started (never for pthreads).
</p>
<p>
  The following TCB fields must be initialized:
</p>
<ul>
  <li><code>adj_stack_size</code>: Stack size after adjustment for hardware,
    processor, etc.  This value is retained only for debug
    purposes.</li>
  <li><code>stack_alloc_ptr</code>: Pointer to allocated stack</li>
  <li><code>adj_stack_ptr</code>: Adjusted <code>stack_alloc_ptr</code> for HW.  The
    initial value of the stack pointer.
</ul>

<p><b>Input Parameters:</b></p>
<ul>
  <li>
    <code>tcb</code>: The TCB of new task.
  </li>
  <li>
    <code>stack_size</code>:  The allocated stack size.
  </li>
</ul>
<p>
  NOTE:  Unlike <code>up_stack_create()</code> and <code>up_stack_release</code>, this function does not require the task type (<code>ttype</code>) parameter.
  The TCB flags will always be set to provide the task type to <code>up_use_stack()</code> if the information needs that information.
</p>


<h3><a name="upstackframe">4.2.6 <code>up_stack_frame()</code></a></h3>
<p><b>Function Prototype</b>: <code>FAR void *up_stack_frame(FAR struct tcb_s *tcb, size_t frame_size);</code></p>

<p>
  <b>Description</b>.
  Allocate a stack frame in the TCB's stack to hold thread-specific data.
  This function may be called any time after <code>up_create_stack()</code> or <code>up_use_stack()</code> have been called but before the task has been started.
</p>
<p>
  Thread data may be kept in the stack (instead of in the TCB) if it is accessed by the user code directly.
  This includes such things as <code>argv[]</code>.
  The stack memory is guaranteed to be in the same protection domain as the thread.
</p>
<p>
  The following TCB fields will be re-initialized:
</p>
<ul>
  <li>
    <code>adj_stack_size</code>: Stack size after removal of the stack frame from the stack.
  </li>
  <li>
    <code>adj_stack_ptr</code>: Adjusted initial stack pointer after the frame has been removed from the stack.
    This will still be the initial value of the stack pointer when the task is started.
  </li>
</ul>
<p><b>Input Parameters:</b></p>
<ul>
  <li>
    <p>
      <code>tcb</code>:
      The TCB of new task.
    </p>
  </li>
  <li>
    <p>
      <code>frame_size</code>:
      The size of the stack frame to allocate.
    </p>
  </li>
</ul>
<p>
  <b>Returned Value:</b>
   A pointer to bottom of the allocated stack frame.
   NULL will be returned on any failures.
   The alignment of the returned value is the same as the alignment of the stack itself
</p>

<h3><a name="upreleasestack">4.2.7 <code>up_release_stack()</code></a></h3>
<p><b>Function Prototype</b>: <code>void up_release_stack(FAR struct tcb_s *dtcb);</code></p>

<p><b>Description</b>.
  A task has been stopped.
  Free all stack related resources retained int the defunct TCB.
</p>
<p><b>Input Parameters:</b></p>
<ul>
  <li>
    <p>
      <code>dtcb</code>:
      The TCB containing information about the stack to be released.
    </p>
  </li>
  <li>
    <p>
      <code>ttype</code>:  The thread type.
      This may be one of following (defined in <code>include/nuttx/sched.h</code>):
    </p>
    <ul>
      <li><code>TCB_FLAG_TTYPE_TASK</code>: Normal user task</li>
      <li><code>TCB_FLAG_TTYPE_PTHREAD</code>: User pthread</li>
      <li><code>TCB_FLAG_TTYPE_KERNEL</code>: Kernel thread</li>
    </ul>
    <p>
      This thread type is normally available in the flags field of the TCB, however, there are certain error recovery contexts where the TCB may not be fully initialized when up_release_stack is called.
    </p>
    <p>
      If <code>CONFIG_BUILD_PROTECTED</code> or <code>CONFIG_BUILD_KERNEL</code> are defined, then this thread type may affect how the stack is freed.
      For example, kernel thread stacks may have been allocated from protected kernel memory.
      Stacks for user tasks and threads must have come from memory that is accessible to user
    </p>
  </li>
</ul>

<h3><a name="upunblocktask">4.2.8 <code>up_unblock_task()</code></a></h3>
<p><b>Function Prototype</b>: <code>void up_unblock_task(FAR struct tcb_s *tcb);</code></p>

<p><b>Description</b>.
  A task is currently in an inactive task list
  but has been prepped to execute.  Move the TCB to the
  ready-to-run list, restore its context, and start execution.
</p>
<p>
  This function is called only from the NuttX scheduling
  logic.  Interrupts will always be disabled when this
  function is called.
</p>

<p><b>Input Parameters</b>:
<ul>
  <li><code>tcb</code>: Refers to the tcb to be unblocked.  This tcb is
    in one of the waiting tasks lists.  It must be moved to
    the ready-to-run list and, if it is the highest priority
    ready to run tasks, executed.
  </li>
</ul>

<h3><a name="upblocktask">4.2.9 <code>up_block_task()</code></a></h3>
<p><b>Function Prototype</b>: <code>void up_block_task(FAR struct tcb_s *tcb, tstate_t task_state);</code></p>

<p><b>Description</b>.
  The currently executing task at the head of
  the ready to run list must be stopped.  Save its context
  and move it to the inactive list specified by task_state.

  This function is called only from the NuttX scheduling
  logic.  Interrupts will always be disabled when this
  function is called.

<p><b>Input Parameters:</b></p>
<ul>
  <li><code>tcb</code>: Refers to a task in the ready-to-run list (normally
    the task at the head of the list).  It most be
    stopped, its context saved and moved into one of the
    waiting task lists.  It it was the task at the head
    of the ready-to-run list, then a context to the new
    ready to run task must be performed.
  </li>
  <li><code>task_state</code>: Specifies which waiting task list should be
    hold the blocked task TCB.
  </li>
</ul>

<h3><a name="upreleasepending">4.2.10 <code>up_release_pending()</code></a></h3>
<p><b>Function Prototype</b>: <code>void up_release_pending(void);</code></p>

<p><b>Description</b>.
  When tasks become ready-to-run but cannot run because pre-emption
  is disabled, they are placed into a pending task list.
  This function releases and makes ready-to-run all of the tasks that have
  collected in the pending task list.  This can cause a
  context switch if a new task is placed at the head of
  the ready to run list.
</p>
<p>
  This function is called only from the NuttX scheduling logic when
  pre-emption is re-enabled.  Interrupts will always be disabled when this
  function is called.
</p>

<h3><a name="upreprioritizertr">4.2.11 <code>up_reprioritize_rtr()</code></a></h3>
<p><b>Function Prototype</b>: <code>void up_reprioritize_rtr(FAR struct tcb_s *tcb, uint8_t priority);</code></p>

<p><b>Description</b>.
  Called when the priority of a running or
  ready-to-run task changes and the reprioritization will
  cause a context switch.  Two cases:
</p>
<ol>
  <li>
    The priority of the currently running task drops and the next
    task in the ready to run list has priority.
  </li>
  <li>
    An idle, ready to run task's priority has been raised above the
    the priority of the current, running task and it now has the
    priority.
  </li>
</ol>
<p>
  This function is called only from the NuttX scheduling
  logic.  Interrupts will always be disabled when this
  function is called.
</p>

<p><b>Input Parameters:</b></p>
<ul>
  <li>
    <code>tcb</code>: The TCB of the task that has been reprioritized
  </li>
  <li>
    <code>priority</code>: The new task priority
  </li>
</ul>

<h3><a name="_exit">4.2.12 <code>_exit()</code></a></h3>
<p><b>Function Prototype</b>: <code>void _exit(int status) noreturn_function;</code></p>

<p><b>Description</b>.
  This function causes the currently executing task to cease
  to exist.  This is a special case of task_delete().
</p>
<p>
  Unlike other UP APIs, this function may be called
  directly from user programs in various states.  The
  implementation of this function should disable interrupts
  before performing scheduling operations.
</p>

<h3><a name="upassert">4.2.13 <code>up_assert()</code></a></h3>
<p><b>Function Prototype</b>:<br>
  <code>void up_assert(FAR const uint8_t *filename, int linenum);</code>
</p>

<p><b>Description</b>.
  Assertions may be handled in an architecture-specific way.
</p>

<h3><a name="upschedulesigaction">4.2.14 <code>up_schedule_sigaction()</code></a></h3>
<p><b>Function Prototype</b>:
  <code>void up_schedule_sigaction(FAR struct tcb_s *tcb, sig_deliver_t sigdeliver);</code>
</p>

<p><b>Description</b>.
  This function is called by the OS when one or more
  signal handling actions have been queued for execution.
  The architecture specific code must configure things so
  that the 'sigdeliver' callback is executed on the thread
  specified by 'tcb' as soon as possible.
</p>
<p>
  This function may be called from interrupt handling logic.
</p>
<p>
  This operation should not cause the task to be unblocked
  nor should it cause any immediate execution of sigdeliver.
  Typically, a few cases need to be considered:
</p>
<ol>
  <li>
    This function may be called from an interrupt handler
    During interrupt processing, all xcptcontext structures
    should be valid for all tasks.  That structure should
    be modified to invoke sigdeliver() either on return
    from (this) interrupt or on some subsequent context
    switch to the recipient task.
  </li>
  <li>
    If not in an interrupt handler and the tcb is NOT
    the currently executing task, then again just modify
    the saved xcptcontext structure for the recipient
    task so it will invoke sigdeliver when that task is
    later resumed.
  </li>
  <li>
    If not in an interrupt handler and the tcb IS the
    currently executing task -- just call the signal
    handler now.
  </li>
</ol>
<p>
  This API is <i>NOT</i> required if <code>CONFIG_DISABLE_SIGNALS</code>
  is defined.
</p>

<h3><a name="upallocateheap">4.2.15 <code>up_allocate_heap()</code></a></h3>
<p><b>Function Prototype</b>: <code>void up_allocate_heap(FAR void **heap_start, size_t *heap_size);</code></p>

<p><b>Description</b>.
  This function will be called to dynamically set aside the heap region.
</p>
<p>
  For the kernel build (<code>CONFIG_BUILD_PROTECTED=y</code> or <code>CONFIG_BUILD_KERNEL=y</code>) with both kernel- and user-space heaps (<code>CONFIG_MM_KERNEL_HEAP=y</code>), this function provides the size of the unprotected, user-space heap.
  If a protected kernel-space heap is provided, the kernel heap must be allocated (and protected) by an analogous <code>up_allocate_kheap()</code>.
</p>

<h3><a name="upinterruptcontext">4.2.16 <code>up_interrupt_context()</code></a></h3>
<p><b>Function Prototype</b>: <code>bool up_interrupt_context(void)</code></p>

<p><b>Description</b>.
  Return true if we are currently executing in the interrupt handler context.
</p>

<h3><a name="updisableirq">4.2.17 <code>up_disable_irq()</code></a></h3>
<p><b>Function Prototype</b>:</p>
<ul><pre>
#ifndef CONFIG_ARCH_NOINTC
  void up_disable_irq(int irq);
#endif
</pre></ul>

<p><b>Description</b>.
  Disable the IRQ specified by 'irq'
  On many architectures, there are three levels of interrupt enabling: (1)
  at the global level, (2) at the level of the interrupt controller,
  and (3) at the device level.  In order to receive interrupts, they
  must be enabled at all three levels.
</p>
<p>
  This function implements enabling of the device specified by 'irq'
  at the interrupt controller level if supported by the architecture
  (irqsave() supports the global level, the device level is hardware
  specific).
<p>
  If the architecture does not support <code>up_disable_irq</code>,
  <code>CONFIG_ARCH_NOINTC</code> should be defined in the NuttX configuration file.
  Since this API cannot be supported on all architectures, it should be
  avoided in common implementations where possible.
</p>

<h3><a name="upenableirq">4.2.18 <code>up_enable_irq()</code></a></h3>
<p><b>Function Prototype</b>:</p>
<ul><pre>
#ifndef CONFIG_ARCH_NOINTC
  void up_enable_irq(int irq);
#endif
</pre></ul>

<p><b>Description</b>.
  This function implements disabling of the device specified by 'irq'
  at the interrupt controller level if supported by the architecture
  (irqrestore() supports the global level, the device level is hardware
  specific).
</p>
<p>
  If the architecture does not support <code>up_disable_irq</code>,
  <code>CONFIG_ARCH_NOINTC</code> should be defined in the NuttX configuration file.
  Since this API cannot be supported on all architectures, it should be
  avoided in common implementations where possible.
</p>

<h3><a name="upprioritizeirq">4.2.19 <code>up_prioritize_irq()</code></a></h3>
<p><b>Function Prototype</b>:</p>
<ul><pre>
#ifdef CONFIG_ARCH_IRQPRIO
  void up_enable_irq(int irq);
#endif
</pre></ul>
<p><b>Description</b>.
  Set the priority of an IRQ.
</p>
<p>
  If the architecture supports <code>up_enable_irq</code>,
  <code>CONFIG_ARCH_IRQPRIO</code> should be defined in the NuttX configuration file.
  Since this API cannot be supported on all architectures, it should be
  avoided in common implementations where possible.
</p>

<h3><a name="upputc">4.2.20 <code>up_putc()</code></a></h3>

<p><b>Function Prototype</b>: <code>int up_putc(int ch);</code></p>
<p><b>Description</b>.
  This is a debug interface exported by the architecture-specific logic.
  Output one character on the console
</p>

<h2><a name="systemtime">4.3 System Time and Clock</a></h2>

<h3><a name="basictimer">4.3.1 Basic System Timer</a></h3>

<p><b>System Timer</b>
  In most implementations, system time is provided by a timer interrupt.
  That timer interrupt runs at rate determined by <code>CONFIG_USEC_PER_TICK</code> (default 10000 microseconds or 100Hz.  If <code>CONFIG_SCHED_TICKLESS</code> is selected, the default is 100 microseconds).
  The timer generates an interrupt each <code>CONFIG_USEC_PER_TICK</code> microseconds and increments a counter called <code>g_system_timer</code>.
  <code>g_system_timer</code> then provides a time-base for calculating <i>up-time</i> and elapsed time intervals in units of <code>CONFIG_USEC_PER_TICK</code>.
  The range of <code>g_system_timer</code> is, by default, 32-bits.
  However, if the MCU supports type <code>long long</code> and <code>CONFIG_SYSTEM_TIME16</code> is selected,
  a 64-bit system timer will be supported instead.
</p>
<p><b>System Timer Accuracy</b>
  On many system, the exact timer interval specified by <code>CONFIG_USEC_PER_TICK</code> cannot be achieved due to limitations in frequencies or in dividers.
  As a result, the time interval specified by <code>CONFIG_USEC_PER_TICK</code> may only be approximate and there may be small errors in the apparent <i>up-time</i> time.
  These small errors, however, will accumulate over time and after a long period of time may have an unacceptably large error in the apparent <i>up-time</i> of the MCU.
</p>
  If the timer tick period generated by the hardware is not exactly <code>CONFIG_USEC_PER_TICK</code> <i>and</i> if there you require accurate up-time for the MCU, then there are measures that you can take:
</p>
<ul>
  <li>
    Perhaps you can adjust <code>CONFIG_USEC_PER_TICK</code> to a different value so that an exactly <code>CONFIG_USEC_PER_TICK</code> can be realized.
  </li>
  <li>
    Or you can use a technique known as <i>Delta-Sigma Modulation</i>. (Suggested by Uros Platise).  Consider the example below.
  </li>
</ul>

<p><b>Delta-Sigma Modulation Example</b>.
  Consider this case:  The system timer is a count-up timer driven at 32.768KHz.
  There are dividers that can be used, but a divider of one yields the highest accuracy.
  This counter counts up until the count equals a match value, then a timer interrupt is generated.
  The desire frequency is 100Hz (<code>CONFIG_USEC_PER_TICK</code> is 10000).
</p>
<p>
  This exact frequency of 100Hz cannot be obtained in this case.
  In order to obtain that exact frequency a match value of 327.68 would have to be provided.
  The closest integer value is 328 but the ideal match value is between 327 and 328.
  The closest value, 328, would yield an actual timer frequency of 99.9Hz!
  That will may cause significant timing errors in certain usages.
</p>
<p>
  Use of Delta-Sigma Modulation can eliminate this error in the long run.
  Consider this example implementation:
</p>
<ol>
  <li>
    Initially an accumulator is zero an the match value is programmed to 328:
<ul><pre>
accumulator = 0;
match = 328;
</pre></ul>
  </li>
  <li>
    On each timer interrupt, accumulator is updated with difference that, in this reflects, 100* the error in interval that just passed.
    So on the first timer interrupt, the accumulator would be updated like:
<ul><pre>
if (match == 328)
  {
    accumulator += 32; // 100*(328 - 327.68)
  }
else
  {
    accumulator -= 68; // (100*(327 - 327.68)
  }
</pre></ul>
  </li>
  <li>
     And on that same timer interrupt a new match value would be programmed:
<ul><pre>
if (accumulator < 0)
  {
    match = 328;
  }
else
  {
    match = 327;
  }
</pre></ul>
</ol>
<p>
  In this way, the timer interval is controlled from interrupt-to-interrupt to produce an average frequency of exactly 100Hz.
</p>

<h3><a name="timerhw">4.3.2 Hardware</a></h3>
<p>
  To enable hardware module use the following configuration options:
<p>
<ul><dl>
  <dt><code>CONFIG_RTC</code>
  <dd>Enables general support for a hardware RTC.
      Specific architectures may require other specific settings.
  <dt><code>CONFIG_RTC_DATETIME</code>
  <dd>There are two general types of RTC:  (1) A simple battery backed counter that keeps the time when power
     is down, and (2) A full date / time RTC the provides the date and time information, often in BCD format.
     If <code>CONFIG_RTC_DATETIME</code> is selected, it specifies this second kind of RTC.
     In this case, the RTC is used to &quot;seed&quot;" the normal NuttX timer and the NuttX system timer
     provides for higher resolution time.
  <dt><code>CONFIG_RTC_HIRES</code>
  <dd>If <code>CONFIG_RTC_DATETIME</code> not selected, then the simple, battery backed counter is used.
      There are two different implementations of such simple counters based on the time resolution of the counter:
      The typical RTC keeps time to resolution of 1 second, usually supporting a 32-bit <code>time_t</code> value.
      In this case, the RTC is used to &quot;seed&quot; the normal NuttX timer and the NuttX timer provides for higher resolution time.
      If <code>CONFIG_RTC_HIRES</code> is enabled in the NuttX configuration, then the RTC provides higher resolution time and completely replaces the system timer for purpose of date and time.
  <dt><code>CONFIG_RTC_FREQUENCY</code>
  <dd>If <code>CONFIG_RTC_HIRES</code> is defined, then the frequency of the high resolution RTC must be provided.
      If <code>CONFIG_RTC_HIRES</code> is not defined, <code>CONFIG_RTC_FREQUENCY</code> is assumed to be one.
  <dt><code>CONFIG_RTC_ALARM</code>
  <dd>Enable if the RTC hardware supports setting of an alarm.
    A callback function will be executed when the alarm goes off
</dl></ul>
<p>
  which requires the following base functions to read and set time:
</p>
<ul>
  <li><code>up_rtcinitialize()</code>.
     Initialize the hardware RTC per the selected configuration.
     This function is called once during the OS initialization sequence
  </li>
  <li><code>up_rtc_time()</code>.
    Get the current time in seconds.  This is similar to the standard <code>time()</code> function.
    This interface is only required if the low-resolution RTC/counter hardware implementation selected.
    It is only used by the RTOS during initialization to set up the system time when <code>CONFIG_RTC</code> is set
    but neither <code>CONFIG_RTC_HIRES</code> nor <code>CONFIG_RTC_DATETIME</code> are set.
  </li>
  <li><code>up_rtc_gettime()</code>.
    Get the current time from the high resolution RTC clock/counter.
    This interface is only supported by the high-resolution RTC/counter hardware implementation.
    It is used to replace the system timer (<code>g_system_tick</code>).
  </li>
  <li><code>up_rtc_settime()</code>.
    Set the RTC to the provided time.
    All RTC implementations must be able to set their time based on a standard timespec.
  </li>
</ul>

<h3><a name="systcktime">4.3.3 System Tick and Time</a></h3>
<p>
  The system tick is represented by::
</p>
<ul>
  <li><code>g_system_timer</code></li>
</ul>
<p>
  Running at rate of system base timer, used for time-slicing, and so forth.
</p>
<p>
  If hardware RTC is present (<code>CONFIG_RTC</code>) and and high-resolution timing
  is enabled (<code>CONFIG_RTC_HIRES</code>), then after successful
  initialization variables are overridden by calls to <code>up_rtc_gettime()</code> which is
  running continuously even in power-down modes.
</p>
<p>
  In the case of <code>CONFIG_RTC_HIRES</code> is set the <code>g_system_timer</code>
  keeps counting at rate of a system timer, which however, is disabled in power-down mode.
  By comparing this time and RTC (actual time) one may determine the actual system active time.
  To retrieve that variable use:
</p>

<h3><a name="tickless">4.3.4 Tickless OS</a></h3>
<h4><a name="tickoverview">4.3.4.1 Tickless Overview</a></h4>

<p>
  <b>Default System Timer</b>.
  By default, a NuttX configuration uses a periodic timer interrupt that drives all system timing. The timer is provided by architecture-specific code that calls into NuttX at a rate controlled by <code>CONFIG_USEC_PER_TICK</code>. The default value of <code>CONFIG_USEC_PER_TICK</code> is 10000 microseconds which corresponds to a timer interrupt rate of 100 Hz.
</p>
<p>
  On each timer interrupt, NuttX does these things:
<p>
<ul>
  <li>Increments a counter. This counter is the system time and has a resolution of <code>CONFIG_USEC_PER_TICK</code> microseconds.
  <li>Checks if it is time to perform time-slice operations on tasks that have select round-robin scheduling.
  <li>Checks for expiration of timed events.
</ul>
<p>
  What is wrong with this default system timer? Nothing really. It is reliable and uses only a small fraction of the CPU band width. But we can do better. Some limitations of default system timer are, in increasing order of importance:
</p>
<ul>
  <li>
    <b>Overhead</b>:
    Although the CPU usage of the system timer interrupt at 100Hz is really very low, it is still mostly wasted processing time. One most timer interrupts, there is really nothing that needs be done other than incrementing the counter.
  </li>
  <li>
    <b>Resolution</b>:
    Resolution of all system timing is also determined by <code>CONFIG_USEC_PER_TICK</code>. So nothing that be time with resolution finer than 10 milliseconds be default. To increase this resolution, <code>CONFIG_USEC_PER_TICK</code> an be reduced. However, then the system timer interrupts use more of the CPU bandwidth processing useless interrupts.
  </li>
  <li>
    <b>Power Usage</b>:
    But the biggest issue is power usage. When the system is IDLE, it enters a light, low-power mode (for ARMs, this mode is entered with the <code>wfi</code> or <code>wfe</code> instructions for example). But each interrupt awakens the system from this low power mode. Therefore, higher rates of interrupts cause greater power consumption.
  </li>
</ul>
<p>
  <b><i>Tickless OS</i></b>.
  The so-called <i>Tickless OS</i> provides one solution to issue. The basic concept here is that the periodic, timer interrupt is eliminated and replaced with a one-shot, interval timer. It becomes event driven instead of polled: The default system timer is a polled design. On each interrupt, the NuttX logic checks if it needs to do anything and, if so, it does it.
</p>
<p>
  Using an interval timer, one can anticipate when the next interesting OS event will occur, program the interval time and wait for it to fire. When the interval time fires, then the scheduled activity is performed.
</p>

<h4><a name="tickplatform">4.3.4.2 Tickless Platform Support</a></h4>

In order to use the Tickless OS, one must provide special support from the platform-specific code. Just as with the default system timer, the platform-specific code must provide the timer resources to support the OS behavior.

Currently these timer resources are only provided on a few platforms. An example implementation is for the simulation is at <code>nuttx/arch/sim/src/up_tickless.c</code>.  There is another example for the Atmel SAMA5 at <code>nuttx/arch/arm/src/sama5/sam_tickless.c</code>.  These paragraphs will explain how to provide the Tickless OS support to any platform.

<h4><a name="tickconfig">4.3.4.3 Tickless Configuration Options</a></h4>
<ul>
  <li>
    <p>
      <b><code>CONFIG_ARCH_HAVE_TICKLESS</code></b>:
      If the platform provides support for the <i>Tickless OS</i>, then this setting should be selected in the <code>Kconfig</code> file for the board. Here is what the selection looks in the <code>arch/Kconfig</code> file for the simulated platform:
    </p>
<ul><pre>
config ARCH_SIM
   bool "Simulation"
   select ARCH_HAVE_TICKLESS
   ---help---
       Linux/Cywgin user-mode simulation.
</pre></ul>
    <p>
      When the simulation platform is selected, <code>ARCH_HAVE_TICKLESS</code> is automatically selected, informing the configuration system that <i>Tickless OS</i> options can be selected.
    </p>
  </li>
  <li>
    <p>
      <b><code>CONFIG_SCHED_TICKLESS</code></b>:
      If <code>CONFIG_ARCH_HAVE_TICKLESS</code> is selected, then it will enable the Tickless OS features in NuttX.
    </p>
  </li>
  <li>
    <p>
      <b><code>CONFIG_SCHED_TICKLESS_ALARM</code></b>:
      The tickless option can be supported either via a simple interval timer (plus elapsed time) or via an alarm.  The interval timer allows programming events to occur after an interval.  With the alarm, you can set a time in the future and get an event when that alarm goes off.  This option selects the use of an alarm.
    </p>
    <p>
      The advantage of an alarm is that it avoids some small timing errors; the advantage of the use of the interval timer is that the hardware requirement may be less.
    </p>
  </li>
  <li>
    <p>
      <b><code>CONFIG_USEC_PER_TICK</code></b>:
      This option is not unique to <i>Tickless OS</i> operation, but changes its relevance when the <i>Tickless OS</i> is selected.
      In the default configuration where system time is provided by a periodic timer interrupt, the default system timer is configure the timer for 100Hz or <code>CONFIG_USEC_PER_TICK=10000</code>. If <code>CONFIG_SCHED_TICKLESS</code> is selected, then there are no system timer interrupt. In this case, <code>CONFIG_USEC_PER_TICK</code> does not control any timer rates. Rather, it only determines the resolution of time reported by <code>clock_systimer()</code> and the resolution of times that can be set for certain delays including watchdog timers and delayed work.
    </p>
    <p>
      In this case there is still a trade-off: It is better to have the <code>CONFIG_USEC_PER_TICK</code> as low as possible for higher timing resolution. However, the the time is currently held in <code>unsigned int</code>. On some systems, this may be 16-bits in width but on most contemporary systems it will be 32-bits. In either case, smaller values of <code>CONFIG_USEC_PER_TICK</code> will reduce the range of values that delays that can be represented. So the trade-off is between range and resolution (you could also modify the code to use a 64-bit value if you really want both).
    </p>
    <p>
      The default, 100 microseconds, will provide for a range of delays up to 120 hours.
    </p>
    <p>
      This value should never be less than the underlying resolution of the timer. Errors may ensue.
    </p>
  </li>
</ul>

<h4><a name="tickconfig">4.3.4.4 Tickless Imported Intefaces</a></h4>
<p>
  The interfaces that must be provided by the platform specified code are defined in <code>include/nuttx/arch.h</code>, listed below, and summarized in the following paragraphs:
</p>
<ul>
  <li>
    <a href="#uptimerinit"><code>up_timer_initialize()</code></a>:
    Initializes the timer facilities.  Called early in the intialization sequence (by <code>up_intialize()</code>).
  </li>
  <li>
    <a href="#uptimergettime"><code>up_timer_gettime()</code></a>:
    Returns the current time from the platform specific time source.
  </li>
</ul>
<p>
  The tickless option can be supported either via a simple interval timer (plus elapsed time) or via an alarm.  The interval timer allows programming events to occur after an interval.  With the alarm, you can set a time in* the future and get an event when that alarm goes off.
</p>
<p>
  If <code>CONFIG_SCHED_TICKLESS_ALARM</code> is defined, then the platform code must provide the following:
<p>
<ul>
  <li>
    <a href="#upalarmcancel"><code>up_alarm_cancel()</code></a>:
    Cancels the alarm.
  </li>
  <li>
    <a href="#upalarmstart"><code>up_alarm_start()</code></a>:
    Enables (or re-enables) the alaram.
  </li>
</ul>
<p>
  If <code>CONFIG_SCHED_TICKLESS_ALARM</code> is <i>not</i>defined, then the platform code must provide the following verify similar functions:
<p>
<ul>
  <li>
    <a href="#uptimercancel"><code>up_timer_cancel()</code></a>:
    Cancels the interval timer.
  </li>
  <li>
    <a href="#uptimerstart"><code>up_timer_start()</code></a>:
    Starts (or re-starts) the interval timer.
  </li>
</ul>
<p>
  Note that a platform-specific implementation would probably require two hardware timers: (1) A interval timer to satisfy the requirements of <a href="#uptimerstart"><code>up_timer_start()</code></a> and <a href="#uptimercancel"><code>up_timer_cancel()</code></a>, and a (2) a counter to handle the requirement of <a href="#uptimergettime"><code>up_timer_gettime()</code></a>.  Ideally, both timers would run at the rate determined by <code>CONFIG_USEC_PER_TICK</code> (and certainly never slower than that rate).
</p>
<p>
  Since timers are a limited resource, the use of two timers could be an issue on some systems.
  The job could be done with a single timer if, for example, the single timer were kept in a free-running at all times. Some timer/counters have the capability to generate a compare interrupt when the timer matches a comparison value but also to continue counting without stopping. If your hardware supports such counters, one might used the <code>CONFIG_SCHED_TICKLESS_ALARM</code> option and be able to simply set the comparison count at the value of the free running timer <i>PLUS</i> the desired delay. Then you could have both with a single timer: An alarm and a free-running counter with the same timer!
</p>
<p>
  In addition to these imported interfaces, the RTOS will export the following interfaces for use by the platform-specific interval timer implementation:
</p>
<ul>
  <li>
    <a href="#schedalarmexpiration"><code>sched_alarm_expiration()</code></a>. Called by the platform-specific logic when the alarm expires.
  </li>
  <li>
    <a href="#schedtimerexpiration"><code>sched_timer_expiration()</code></a>. Called by the platform-specific logic when the interval time expires.
  </li>
</ul>

<h5><a name="uptimerinit">4.3.4.4.1 <code>up_timer_initialize()</code></a></h5>
<p><b>Function Prototype</b>:</p>
<ul><pre>
#include &lt;nuttx/arch.h&gt;
void up_timer_initialize(void);
</ul>
<p><b>Description</b>:</p>
<ul>
  Initializes all platform-specific timer facilities. This function is called early in the initialization sequence by <code>up_intialize()</code>. On return, the current up-time should be available from <code>up_timer_gettime()</code> and the interval timer is ready for use (but not actively timing).
</ul>
<p><b>Input Parameters</b>:</p>
<ul>
  None
</ul>
<p><b>Returned Value</b>:</p>
<ul>
  Zero (<code>OK</code>) on success; a negated <code>errno</code> value on failure.
</ul>
<p><b>Assumptions</b>:</p>
<ul>
  Called early in the initialization sequence before any special concurrency protections are required.
</ul>

<h5><a name="uptimergettime">4.3.4.4.2 <code>up_timer_gettime()</code></a></h5>
<p><b>Function Prototype</b>:<p>
<ul><pre>
#include &lt;nuttx/arch.h&gt;
int up_timer_gettime(FAR struct timespec *ts);
</ul>
<p><b>Description</b>:</p>
  Return the elapsed time since power-up (or, more correctly, since <code>up_timer_initialize()</code> was called). This function is functionally equivalent to <code>clock_gettime()</code> for the clock ID <code>CLOCK_MONOTONIC</code>. This function provides the basis for reporting the current time and also is used to eliminate error build-up from small errors in interval time calculations.
<ul>
</ul>
<p><b>Input Parameters</b>:</p>
<ul>
  <li><code>ts</code>: Provides the location in which to return the up-time..
</li>
</ul>
<p><b>Returned Value</b>:</p>
<ul>
  Zero (<code>OK</code>) on success; a negated <code>errno</code> value on failure.
</ul>
<p><b>Assumptions</b>:</p>
<ul>
  Called from the the normal tasking context. The implementation must provide whatever mutual exclusion is necessary for correct operation. This can include disabling interrupts in order to assure atomic register operations.
</ul>

<h5><a name="upalarmcancel">4.3.4.4.3 <code>up_alarm_cancel()</code></a></h5>
<p><b>Function Prototype</b>:<p>
<ul><pre>
#include &lt;nuttx/arch.h&gt;
int up_alarm_cancel(FAR struct timespec *ts);
</ul>
<p><b>Description</b>:</p>
  Cancel the alarm and return the time of cancellation of the alarm. These two steps need to be as nearly atomic as possible. <code>sched_timer_expiration()</code> will not be called unless the alarm is restarted with <code>up_alarm_start()</code>. If, as a race condition, the alarm has already expired when this function is called, then time returned is the current time.
<ul>
</ul>
<p><b>Input Parameters</b>:</p>
<ul>
  <li><code>ts</code>: Location to return the expiration time.  The current time should be returned if the timer is not active.    <code>ts</code> may be <code>NULL</code> in which case the time is not returned</li>
</ul>
<p><b>Returned Value</b>:</p>
<ul>
  Zero (<code>OK</code>) on success; a negated <code>errno</code> value on failure.
</ul>
<p><b>Assumptions</b>:</p>
<ul>
  May be called from interrupt level handling or from the normal tasking level. iterrupts may need to be disabled internally to assure non-reentrancy.
</ul>

<h5><a name="upalarmstart">4.3.4.4.4 <code>up_alarm_start()</code></a></h5>
<p><b>Function Prototype</b>:<p>
<ul><pre>
#include &lt;nuttx/arch.h&gt;
int up_alarm_start(FAR const struct timespec *ts);
</ul>
<p><b>Description</b>:</p>
  Start the alarm. <code>sched_timer_expiration()</code> will be called when the alarm occurs (unless <code>up_alaram_cancel</code> is called to stop it).
<ul>
</ul>
<p><b>Input Parameters</b>:</p>
<ul>
  <li><code>ts</code>: The time in the future at the alarm is expected to occur.  When the alarm occurs the timer logic will call <code>sched_timer_expiration()</code>.</li>
</ul>
<p><b>Returned Value</b>:</p>
<ul>
  Zero (<code>OK</code>) on success; a negated <code>errno</code> value on failure.
</ul>
<p><b>Assumptions</b>:</p>
<ul>
  May be called from interrupt level handling or from the normal tasking level. Interrupts may need to be disabled internally to assure non-reentrancy.
</ul>

<h5><a name="uptimercancel">4.3.4.4.5 <code>up_timer_cancel()</code></a></h5>
<p><b>Function Prototype</b>:<p>
<ul><pre>
#include &lt;nuttx/arch.h&gt;
int up_timer_cancel(FAR struct timespec *ts);
</ul>
<p><b>Description</b>:</p>
  Cancel the interval timer and return the time remaining on the timer. These two steps need to be as nearly atomic as possible. <code>sched_timer_expiration()</code> will not be called unless the timer is restarted with <code>up_timer_start()</code>. If, as a race condition, the timer has already expired when this function is called, then that pending interrupt must be cleared so that <code>sched_timer_expiration()</code> is not called spuriously and the remaining time of zero should be returned.
<ul>
</ul>
<p><b>Input Parameters</b>:</p>
<ul>
  <li><code>ts</code>: Location to return the remaining time. Zero should be returned if the timer is not active.</li>
</ul>
<p><b>Returned Value</b>:</p>
<ul>
  Zero (<code>OK</code>) on success; a negated <code>errno</code> value on failure.
</ul>
<p><b>Assumptions</b>:</p>
<ul>
  May be called from interrupt level handling or from the normal tasking level. iterrupts may need to be disabled internally to assure non-reentrancy.
</ul>

<h5><a name="uptimerstart">4.3.4.4.6 <code>up_timer_start()</code></a></h5>
<p><b>Function Prototype</b>:<p>
<ul><pre>
#include &lt;nuttx/arch.h&gt;
int up_timer_start(FAR const struct timespec *ts);
</ul>
<p><b>Description</b>:</p>
  Start the interval timer. <code>sched_timer_expiration()</code> will be called at the completion of the timeout (unless <code>up_timer_cancel()</code> is called to stop the timing).
<ul>
</ul>
<p><b>Input Parameters</b>:</p>
<ul>
  <li><code>ts</code>: Provides the time interval until <code>sched_timer_expiration()</code> is called.</li>
</ul>
<p><b>Returned Value</b>:</p>
<ul>
  Zero (<code>OK</code>) on success; a negated <code>errno</code> value on failure.
</ul>
<p><b>Assumptions</b>:</p>
<ul>
  May be called from interrupt level handling or from the normal tasking level. Interrupts may need to be disabled internally to assure non-reentrancy.
</ul>

<h3><a name="Watchdogs">4.3.5 Watchdog Timer Interfaces</a></h3>
<p>
  NuttX provides a general watchdog timer facility.
  This facility allows the NuttX user to specify a watchdog timer function
  that will run after a specified delay.
  The watchdog timer function will run in the context of the timer interrupt handler.
  Because of this, a limited number of NuttX interfaces are available to he watchdog timer function.
  However, the watchdog timer function may use <code>mq_send()</code>, <code>sigqueue()</code>,
  or <code>kill()</code> to communicate with NuttX tasks.
</p>
<ul>
  <li><a href="#wdcreate">4.3.5.1 wd_create/wd_static</a></li>
  <li><a href="#wddelete">4.3.5.2 wd_delete</a></li>
  <li><a href="#wdstart">4.3.5.3 wd_start</a></li>
  <li><a href="#wdcancel">4.3.5.4 wd_cancel</a></li>
  <li><a href="#wdgettime">4.3.5.5 wd_gettime</a></li>
  <li><a href="#wdcallback">4.3.5.6 Watchdog Timer Callback</a></li>

</ul>

<h4><a name="wdcreate">4.3.5.1 wd_create/wd_static</a></h4>

<p>
<b>Function Prototype:</b>
<pre>
    #include &lt;nuttx/wdog.h&gt;
    WDOG_ID wd_create(void);
    void wd_static(FAR struct wdog_s *wdog);
</pre>

<p>
<b>Description:</b> The <code>wd_create()</code> function will create a timer by allocating the appropriate resources for the watchdog.  The <code>wd_create()</code> function returns a pointer to a fully initialized, dynamically allocated <code>struct wdog_s</code> instance (which is <code>typedef</code>'ed as <code>WDOG_ID</code>);
</p>
<p>
<code>wd_static()</code> performs the equivalent initialization of a statically allocated <code>struct wdog_s</code> instance.  No allocation is performed in this case.  The initializer definition, <code>WDOG_INITIALIZER</code> is also available for initialization of static instances of <code>struct wdog_s</code>.  NOTE: <code>wd_static()</code> is also implemented as a macro definition.
</p>
<p>
<b>Input Parameters:</b> None.
<p>
<b>Returned Value:</b>
<ul>
<li>Pointer to watchdog that may be used as a handle in subsequent NuttX calls (i.e., the watchdog ID), or NULL if insufficient resources are available to create the watchdogs.
</ul>

<p>
<b>Assumptions/Limitations:</b>
<p>
<b>  POSIX  Compatibility:</b> This is a NON-POSIX interface.
VxWorks provides the following comparable interface:
<pre>
    WDOG_ID wdCreate (void);
</pre>

<p>
Differences from the VxWorks interface include:
<ul>
<li>The number of available watchdogs is fixed (configured at
initialization time).
</ul>

<h4><a name="wddelete">4.3.5.2 wd_delete</a></h4>

<p>
<b>Function Prototype:</b>
<pre>
    #include &lt;nuttx/wdog.h&gt;
    int wd_delete(WDOG_ID wdog);
</pre>

<p>
<b>Description:</b> The wd_delete function will deallocate a watchdog timer previously allocated via <code>wd_create()</code>. The watchdog timer will be removed from the timer queue if has been started.
<p>
<p>
This function need not be called for statically allocated timers (but it is not harmful to do so).
</p>
<b>Input Parameters:</b>
<ul>
<li><code>wdog</code>. The watchdog ID to delete. This is actually a
pointer to a watchdog structure.
</ul>

<p>
<b>Returned Value:</b>
<ul>
<li>OK or ERROR
</ul>

<p>
<b>Assumptions/Limitations:</b> It is the responsibility of the
caller to assure that the watchdog is inactive before deleting
it.
<p>
<b>POSIX  Compatibility:</b> This is a NON-POSIX interface.
VxWorks provides the following comparable interface:
<pre>
    STATUS wdDelete (WDOG_ID wdog);
</pre>

<p>
Differences from the VxWorks interface include:
<ul>
<li>Does not make any checks to see if the watchdog is being used
before deallocating it (i.e., never returns ERROR).
</ul>

<h4><a name="wdstart">4.3.5.3 wd_start</a></h4>

<p>
<b>Function Prototype:</b>
<pre>
    #include &lt;nuttx/wdog.h&gt;
    int wd_start(WDOG_ID wdog, int delay, wdentry_t wdentry,
                 int argc, ....);
</pre>

<p>
<b>Description:</b> This function adds a watchdog to the timer
queue. The specified watchdog function will be called from the
interrupt level after the specified number of ticks has elapsed.
Watchdog timers may be started from the interrupt level.
<p>
Watchdog times execute in the context of the timer interrupt handler.
<p>
Watchdog timers execute only once.
<p>
To replace either the timeout delay or the function to be executed,
call wd_start again with the same wdog; only the most recent
wd_start() on a given watchdog ID has any effect.
<p>
<b>Input Parameters:</b>
<ul>
<li><code>wdog</code>. Watchdog ID
<li><code>delay</code>. Delay count in clock ticks
<li><code>wdentry</code>. Function to call on timeout
<li><code>argc</code>.  The number of uint32_t parameters to pass to wdentry.
<li><code>...</code>. uint32_t size parameters to pass to wdentry
</ul>

<p>
<b>Returned Value:</b>
<ul>
<li>OK or ERROR
</ul>

<p>
<b>Assumptions/Limitations:</b> The watchdog routine runs in the
context of the timer interrupt handler and is subject to all ISR
restrictions.
<p>
<b>POSIX  Compatibility:</b> This is a NON-POSIX interface.
VxWorks provides the following comparable interface:
<pre>
    STATUS wdStart (WDOG_ID wdog, int delay, FUNCPTR wdentry, int parameter);
</pre>

<p>
Differences from the VxWorks interface include:
<ul>
<li>The present implementation supports multiple parameters passed
to wdentry; VxWorks supports only a single parameter.  The maximum
number of parameters is determined by
</ul>

<h4><a name="wdcancel">4.3.5.4 wd_cancel</a></h4>
<p>
<b>Function Prototype:</b>
<pre>
    #include &lt;nuttx/wdog.h&gt;
    int wd_cancel(WDOG_ID wdog);
</pre>

<p>
<b>Description:</b> This function cancels a currently running
watchdog timer. Watchdog timers may be canceled from the interrupt
level.
<p>
<b>Input Parameters:</b>
<ul>
<li><code>wdog</code>. ID of the watchdog to cancel.
</ul>

<p>
<b>Returned Value:</b>
<ul>
<li>OK or ERROR
</ul>

<p>
<b>Assumptions/Limitations:</b>
<p>
<b>POSIX  Compatibility:</b> This is a NON-POSIX interface.
VxWorks provides the following comparable interface:
<pre>
    STATUS wdCancel (WDOG_ID wdog);
</pre>

<h3><a name="wdgettime">4.3.5.5 wd_gettime</a></h3>
<p>
  <b>Function Prototype:</b>
</p>
<pre>
    #include &lt;nuttx/wdog.h&gt;
    Sint wd_gettime(WDOG_ID wdog);
</pre>
<p>
  <b>Description:</b>
   This function returns the time remaining before the specified watchdog expires.
</p>
<p>
  <b>Input Parameters:</b>
  <ul>
    <li><code>wdog</code>. Identifies the watchdog that the request is for.</li>
  </ul>
</p>
<p>
  <b>Returned Value:</b>
  The time in system ticks remaining until the watchdog time expires.  Zero
  means either that wdog is not valid or that the wdog has already expired.
</p>

<h4><a name="wdcallback">4.3.5.6 Watchdog Timer Callback</a></h4>
<p>
  When a watchdog expires, the callback function with this type is called:
</p>
<pre>
    typedef void (*wdentry_t)(int argc, ...);
</pre>
<p>
  Where <code>argc</code> is the number of <code>wdparm_t</code> type arguments that follow.
</p>
<p>
  The arguments are passed as scalar <code>wdparm_t</code> values.  For systems where the <code>sizeof(pointer) &lt; sizeof(uint32_t)</code>, the following union defines the alignment of the pointer within the <code>uint32_t</code>.  For example, the SDCC MCS51 general pointer is 24-bits, but <code>uint32_t</code> is 32-bits (of course).
</p>
   We always have <code>sizeof(pointer) <= sizeof(uintptr_t)</code> by definition.
</p>
<ul><pre>
union wdparm_u
{
  FAR void     *pvarg; /* The size one generic point */
  uint32_t      dwarg; /* Big enough for a 32-bit value in any case */
  uintptr_t     uiarg; /* sizeof(uintptr_t) >= sizeof(pointer) */
};

#if UINTPTR_MAX >= UINT32_MAX
typedef uintptr_t wdparm_t;
#else
typedef uint32_t  wdparm_t;
#endif
</pre></ul>

<h2><a name="workqueues">4.4 Work Queues</a></h2>
<p><b>Work Queues</b>.
  NuttX provides <i>work queues</i>.  Work queues are threads the service a queue of work items to be performed.  There are useful for off-loading work to a different threading context, for delayed processing, or for serializing activities.
</p>

<h3><a name="wqclasses">4.4.1 Classes of Work Queues</a></h3>

<p><b>Classes of Work Queues</b>.
  There are three different classes of work queues, each with different properties and intended usage.  These class of work queues along with the the common work queue interface are described in the following paragraphs.
</p>

<h4><a name="hpwork">4.4.1.1 High Priority Kernel Work queue</a></h4>

<p><b>High Priority Kernel Work queue</b>.
  The dedicated high-priority work queue is intended to handle delayed processing from interrupt handlers.  This work queue is required for some drivers but, if there are no complaints, can be safely disabled.  The high priority worker thread also performs garbage collection -- completing any delayed memory deallocations from interrupt handlers.  If the high-priority worker thread is disabled, then that clean up will be performed either by (1) the low-priority worker thread, if enabled, and if not (2) the IDLE thread instead (which runs at the lowest of priority and may not be appropriate if memory reclamation is of high priority)
</p>
<p><b>Device Driver Bottom Half</b>.
  The higher priority worker thread is intended to serve as the <i>bottom half</i> for device drivers.  As a consequence it must run at a very high, fixed priority rivalling the priority of the interrupt handler itself.  Typically, the high priority work queue should be the highest priority thread in your system (the default priority is 224).
</p>
<p><b>Compared to the Low Priority Kernel Work Queue</b>.
  For less critical, lower priority, application oriented worker thread support, consider enabling the lower priority work queue.  The lower priority work queue runs at a lower priority, of course, but has the added advantage that it supports <i>priority inheritance</i> (if <config> CONFIG_PRIORITY_INHERITANCE</code> is also selected):  The priority of the lower priority worker thread can then be adjusted to match the highest priority client.
</p>
<p>
  <b>Configuration Options</b>.
</p>
<ul>
  <li><code>CONFIG_SCHED_HPWORK</code>.
    Enables the hight prioirity work queue.
  </li>
  <li><code>CONFIG_SCHED_HPWORKPRIORITY</code>.
    The execution priority of the high-priority worker thread.  Default: 224
  </li>
  <li><code>CONFIG_SCHED_HPWORKPERIOD</code>.
    How often the worker thread re-checks for work in units of microseconds.  This work period is really only necessary if the the high priority thread is performing periodic garbage collection.  The worker thread will be awakened immediately with it is queued work to be done.  If the high priority worker thread is performing garbage collection, then the default is 50*1000 (50 MS).  Otherwise, if the lower priority worker thread is performing garbage collection, the default is 100*1000.
  <li><code>CONFIG_SCHED_HPWORKSTACKSIZE</code>.
    The stack size allocated for the worker thread in bytes.  Default: 2048.
  </li>
</ul>
<p>
  <b>Common Configuration Options</b>.
  These options apply to all work queues:
</p>
<ul>
  <li><code>CONFIG_SIG_SIGWORK</code>
    The signal number that will be used to wake-up the worker thread.  This same signal is used with the   Default: 17
  </li>
</ul>

<h4><a name="lpwork">4.4.1.2 Low Priority Kernel Work Queue</a></h4>
<p>
  <b>Low Priority Kernel Work Queue</b>.
  This lower priority work queue is better suited for more extended, application oriented processing such as file system clean-up, memory garbage collection and asynchronous I/O operations.
</p>
<p>
  <b>Compared to the High Priority Work Queue</b>.
  The lower priority work queue runs at a lower priority than the high priority work queue, of course, and so is inapproperiate to serve as a driver <i>bottom half</i>.  The lower priority work queue has the other advantages, however, that make it better suited for some tasks:
</p>
<ul>
  <li>
    <p><b>Priority Inheritance</b>.
      The lower priority worker thread(s) support <i>priority inheritance</i> (if <config> CONFIG_PRIORITY_INHERITANCE</code> is also selected):  The priority of the lower priority worker thread can then be adjusted to match the highest priority client.
    </p>
    <blockquote>
      <b>NOTE:</b> This priority inheritance feature is not automatic.  The lower priority worker thread will always a fixed priority unless additional logic implements that calls <code>lpwork_boostpriority()</code> to raise the priority of the lower priority worker thread (typically called before scheduling the work) and then calls the matching <code>lpwork_restorepriority()</code> when the work is completed (typically called within the work handler at the completion of the work). Currently, only the NuttX asynchronous I/O logic uses this dynamic prioritization feature.
    </blockquote>
    <p>
      The higher priority worker thread, on the other hand, is intended to serve as the <i>bottom half</i> for device drivers.  As a consequence must run at a very high, fixed priority.  Typically, it should be the highest priority thread in your system.
    </p>
  </li>
  <li>
    <p>
      <b>Thread Pool</b>.
      The low-priority work queue can be configured to support multiple, low-priority threads.  This is essentially a <i>thread pool</i> that provides multi-threaded servicing of the low-priority work thread.  This breaks the strict serialization of the &quot;queue&quot; (and hence, the low-priority work queue is no longer a queue at all).
    </p>
    <p>
      Multiple worker threads are required to support, for example, I/O operations that stall waiting for input.  If there is only a single thread, then the entire low-priority queue processing would stall in such cases. Such behavior is necessary to support asynchronous I/O, AIO, for example.
    </p>
  </li>
</ul>
<p>
  <b>Configuration Options</b>.
</p>
<ul>
  <li><code>CONFIG_SCHED_LPWORK</code>.
    If CONFIG_SCHED_LPWORK is selected then a lower-priority work queue will be enabled.
  </li>
  <li><code>CONFIG_SCHED_LPNTHREADS</code>.
    The number of thread in the low-priority queue's thread pool.  Default: 1
  </li>
  <li><code>CONFIG_SCHED_LPWORKPRIORITY</code>.
    The minimum execution priority of the lower priority worker thread.  The priority of the all worker threads start at this priority.  If priority inheritance is in effect, the priority may be boosted from this level.  Default: 50.
  </li>
  <li><code>CONFIG_SCHED_LPWORKPRIOMAX</code>.
    The maximum execution priority of the lower priority worker thread.  Lower priority worker threads will be started at <code>CONFIG_SCHED_LPWORKPRIORITY</code> but their priority may be boosted due to priority inheritance.  The boosted priority of the low priority worker thread will not, however, ever exceed<code>CONFIG_SCHED_LPWORKPRIOMAX</code>.  This limit would be necessary, for example, if the higher priority worker thread were to defer work to the lower priority thread.  Clearly, in such a case, you would want to limit the maximum priority of the lower priority work thread.  Default: 176.
  </li>
  <li><code>CONFIG_SCHED_LPWORKPERIOD</code>.
    How often the lower priority worker thread checks for garbage collection in units of microseconds.  Default: 50*1000 (50 MS).
  </li>
  <li><code>CONFIG_SCHED_LPWORKSTACKSIZE</code>.
    The stack size allocated for the lower priority worker thread.  Default: 2048.
  </li>
</ul>

<h4><a name="usrwork">4.4.1.3 User-Mode Work Queue</a></h4>
<p>
  <b>Work Queue Accessibility</b>.
  The high- and low-priority worker threads are kernel-mode threads.  In the normal, <i>flat</i> NuttX build, these work queues are are useful to application code and may be shared.  However, in the NuttX protected and kernel build modes, kernel mode code is isolated and cannot be accessed from user-mode code.
</p>
<p>
  <b>User-Mode Work Queue</b>.
  if either <code>CONFIG_BUILD_PROTECTED</code> or <code>CONFIG_BUILD_KERNEL</code> are selected, then the option to enable a special user-mode work queue is enable.  The interface to the user-mode work queue is identical to the interface to the kernel-mode work queues and the user-mode work queue is functionally equivalent to the high priority work queue.  It differs in that its implementation does not depend on internal, kernel-space facilities.
</p>
<p>
  <b>Configuration Options</b>.
</p>
<ul>
  <li><code>CONFIG_LIB_USRWORK</code>.
    If CONFIG_LIB_USRWORK is also defined then the user-mode work queue will be enabled.
  <li><code>CONFIG_LIB_USRWORKPRIORITY</code>.
    The execution priority of the user-mode priority worker thread.  Default: 100
  <li><code>CONFIG_LIB_USRWORKPERIOD</code>
    How often the lower priority worker thread is awakened in units of microseconds.  Default: 100*1000 (100 MS).
  <li><code>CONFIG_LIB_USRWORKSTACKSIZE</code>.
    The stack size allocated for the lower priority worker thread.  Default: 2048.
</ul>

<h3><a name="cmnwqifs">4.4.2 Common Work Queue Interfaces</a></h3>
<h4><a name="wqids">4.4.2.1 Work Queue IDs</a></h4>

<p>
  <b>Work queue IDs</b>.
  All work queues use the identical interface functions (at least identical in terms of the function <i>signature</i>).  The first parameter passed to the work queue interface function identifies the work queue:
</p>
<p>
  <b>Kernel-Mode Work Queue IDs:</b>
<p>
<ul>
  <li>
    <code>HPWORK</code>.
    This ID of the high priority work queue that should only be used for hi-priority, time-critical, driver bottom-half functions.
  </li>
  <li>
    <code>LPWORK</code>.
    This is the ID of the low priority work queue that can be used for any purpose.  if <code>CONFIG_SCHED_LPWORK</code> is not defined, then there is only one kernel work queue and <code>LPWORK</code> is equal to <code>HPWORK</code>.
  </li>
</ul>
<p>
  <b>User-Mode Work Queue IDs:</b>
<p>
<ul>
  <li>
    <code>USRWORK</code>.
    This is the ID of the user-mode work queue that can be used for any purpose by applications.  In a flat build, <code>LPWORK</code> is equal to <code>LPWORK</code> so that user applications will use the lower priority work queue (if there is one).
  </li>
</ul>

<h4><a name="wqiftypes">4.4.2.2 Work Queue Interface Types</a></h4>

<ul>
  <li>
    <code>typedef void (*worker_t)(FAR void *arg);</code>
    Defines the type of the work callback.
  </li>
  <li>
    <code>struct work_s</code>.
    Defines one entry in the work queue.  This is a client-allocated structure.  Work queue clients should not reference any field in this structure since they are subjec to change.  The user only needs this structure in order to declare instances of the work structure.  Handling of all fields is performed by the work queue interfaces described below.
  </li>
</ul>

<h4><a name="wqintfs">4.4.2.3 Work Queue Interfaces</a></h4>
<h5><a name="workqueue">4.4.2.3.1 <code>work_queue()</code></a></h5>
<p>
  <b>Function Prototype</b>:
  <ul><pre>
#include &lt;nuttx/wqueue.h&gt;
int work_queue(int qid, FAR struct work_s *work, worker_t worker,
               FAR void *arg, uint32_t delay);
</pre></ul>
</p>
<p>
  <b>Description</b>.
  Queue work to be performed at a later time.  All queued work will be performed on the worker thread of execution (not the caller's).
</p>
<p>
  The work structure is allocated by caller, but completely managed by the work queue logic.  The caller should never modify the contents of the work queue structure; the caller should not call  <code>work_queue()</code> again until either (1) the previous work has been performed and removed from the queue, or (2) <code>work_cancel()</code> has been called to cancel the work and remove it from the work queue.
</p>
<p>
  <b>Input Parameters</b>:
</p>
<ul>
  <li>
    <p>
      <code>qid</code>:
      The work queue ID.
    </p>
  </li>
  <li>
    <p>
      <code>work</code>:
      The work structure to queue
    </p>
  </li>
  <li>
    <p>
      <code>worker</code>:
      The worker callback to be invoked.  The callback will invoked on the worker thread of execution.
    </p>
  </li>
  <li>
    <p>
      <code>arg</code>:
      The argument that will be passed to the worker callback function when it is invoked.
    </p>
  </li>
  <li>
    <p>
      <code>delay</code>:
      Delay (in system clock ticks) from the time queue until the worker is invoked. Zero means to perform the work immediately.
    </p>
  </li>
</ul>
<p>
  <b>Returned Value</b>:
</p>
<ul>
  <p>
     Zero is returned on success; a negated <code>errno</code> is returned on failure.
  </p>
</ul>

<h5><a name="workcancel">4.4.2.3.2 <code>work_cancel()</code></a></h5>
<p>
  <b>Function Prototype</b>:
#include &lt;nuttx/wqueue.h&gt;
int work_cancel(int qid, FAR struct work_s *work);
  <ul><pre>
</pre></ul>
</p>
<p>
  <b>Description</b>.
  Cancel previously queued work.  This removes work from the work queue.  After work has been cancelled, it may be re-queue by calling <code>work_queue()</code> again.
</p>
<p>
  <b>Input Parameters</b>:
</p>
<ul>
  <li>
    <p>
      <code>qid</code>:
      The work queue ID.
    </p>
  </li>
  <li>
    <p>
      <code>work</code>:
      The previously queue work structure to cancel.
    </p>
  </li>
</ul>
<p>
  <b>Returned Value</b>:
</p>
<ul>
  <p>
     Zero is returned on success; a negated <code>errno</code> is returned on failure.
  </p>
  <ul>
    <li><code>ENOENT</code>: There is no such work queued.</li>
    <li><code>EINVAL</code>: An invalid work queue was specified.</li>
  </ul>
</ul>

<h5><a name="worksignal">4.4.2.3.3 <code>work_signal()</code></a></h5>
<p>
  <b>Function Prototype</b>:
#include &lt;nuttx/wqueue.h&gt;
int work_signal(int qid);
  <ul><pre>
</pre></ul>
</p>
<p>
  <b>Description</b>.
  Signal the worker thread to process the work queue now.  This function is used internally by the work logic but could also be used by the user to force an immediate re-assessment of pending work.
</p>
<p>
  <b>Input Parameters</b>:
</p>
<ul>
  <li>
    <p>
      <code>qid</code>:
      The work queue ID.
    </p>
</ul>
<p>
  <b>Returned Value</b>:
</p>
<ul>
  <p>
     Zero is returned on success; a negated <code>errno</code> is returned on failure.
  </p>
</ul>

<h5><a name="workavailable">4.4.2.3.4 <code>work_available()</code></a></h5>
<p>
  <b>Function Prototype</b>:
  <ul><pre>
#include &lt;nuttx/wqueue.h&gt;
bool work_available(FAR struct work_s *work);
</pre></ul>
</p>
<p>
  <b>Description</b>.
</p>
<p>
  <b>Input Parameters</b>:
  Check if the work structure is available.
</p>
<ul>
  <li>
    <p>
      <code>work</code>:
      The work queue structure to check.
    </p>
</ul>
<p>
  <b>Returned Value</b>:
</p>
<ul>
  <p>
  <code>true</code> if available; false if <code>busy</code> (i.e., there is still pending work).
  </p>
</ul>

<h5><a name="workusrstart">4.4.2.3.5 <code>work_usrstart()</code></a></h5>
<p>
  <b>Function Prototype</b>:
  <ul><pre>
#include &lt;nuttx/config.h&gt;
#include &lt;nuttx/wqueue.h&gt;
#if defined(CONFIG_LIB_USRWORK) && !defined(__KERNEL__)
int work_usrstart(void);
#endif
</pre></ul>
</p>
<p>
  <b>Description</b>.
  The function is only available as a user interface in the kernel-mode build.  In the flat build, there is no user-mode work queue; in the protected mode, the user-mode work queue will automatically be started by the OS start-up code.  But in the kernel mode, each user process will be required to start is own, private instance of the user-mode work thread using this interface.
</p>
<p>
  <b>Input Parameters</b>: None
</p>
<p>
  <b>Returned Value</b>:
</p>
<ul>
  <p>
     The task ID of the worker thread is returned on success.  A negated <code>errno</code> value is returned on failure.
  </p>
</ul>

<h5><a name="lpworkboostpriority">4.4.2.3.6 <code>lpwork_boostpriority()</code></a></h5>
<p>
  <b>Function Prototype</b>:
  <ul><pre>
#include &lt;nuttx/config.h&gt;
#include &lt;nuttx/wqueue.h&gt;
#if defined(CONFIG_SCHED_LPWORK) && defined(CONFIG_PRIORITY_INHERITANCE)
void lpwork_boostpriority(uint8_t reqprio);
#endif
</pre></ul>
</p>
<p>
  <b>Description</b>.
  Called by the work queue client to assure that the priority of the low-priority worker thread is at least at the requested level, <code>reqprio</code>.  This function would normally be called just before calling <code>work_queue()</code>.
</p>
<p>
  <b>Input Parameters</b>:
</p>
<ul>
  <li>
    <p>
      <code>reqprio</code>:
      Requested minimum worker thread priority.
    </p>
  </li>
</ul>
<p>
  <b>Returned Value</b>: None
</p>

<h5><a name="lpworkrestorepriority">4.4.2.3.7 <code>lpwork_restorepriority()</code></a></h5>
<p>
  <b>Function Prototype</b>:
  <ul><pre>
#include &lt;nuttx/config.h&gt;
#include &lt;nuttx/wqueue.h&gt;
#if defined(CONFIG_SCHED_LPWORK) && defined(CONFIG_PRIORITY_INHERITANCE)
void lpwork_restorepriority(uint8_t reqprio);
#endif
</pre></ul>
</p>
<p>
  <b>Description</b>.
  This function is called to restore the priority after it was previously boosted.  This is often done by client logic on the worker thread when the scheduled work completes.  It will check if we need to drop the priority of the worker thread.
</p>
<p>
  <b>Input Parameters</b>:
</p>
<ul>
  <li>
    <p>
      <code>reqprio</code>:
      Previously requested minimum worker thread priority to be &quot;unboosted&quot;.
    </p>
  </li>
</ul>
<p>
  <b>Returned Value</b>: None
</p>

<h2><a name="addrenv">4.5 Address Environments</a></h2>
<p>
  CPUs that support memory management units (MMUs) may provide <i>address environments</i> within which tasks and their child threads execute.
  The configuration indicates the CPUs ability to support address environments by setting the configuration variable <code>CONFIG_ARCH_HAVE_ADDRENV=y</code>.
  That will enable the selection of the actual address evironment support which is indicated by the selection of the configuration variable  <code>CONFIG_ARCH_ADDRENV=y</code>.
  These address environments are created only when tasks are created via <code>exec()</code> or <code>exec_module()</code> (see <code>include/nuttx/binfmt/binfmt.h</code>).
</p>
<p>
  When <code>CONFIG_ARCH_ADDRENV=y</code> is set in the board configuration, the CPU-specific logic must provide a set of interfaces as defined in the header file <code>include/nuttx/arch.h</code>.
  These interfaces are listed below and described in detail in the following paragraphs.
</p>
<p>
  The CPU-specific logic must provide two categories in interfaces:
</p>
<ol>
  <li>
    <p>
      <b>Binary Loader Support</b>.
      These are low-level interfaces used in <code>binfmt/</code> to instantiate tasks with address environments.
      These interfaces all operate on type <code>group_addrenv_t</code> which is an abstract representation of a task group's address environment and the type must be defined in<code>arch/arch.h</code> if <code>CONFIG_ARCH_ADDRENV</code> is defined. These low-level interfaces include:
    </p>
    <ul>
      <li>
        <a href="#up_addrenv_create">4.5.1 <code>up_addrenv_create()</code></a>:
        Create an address environment.
      </li>
      <li>
        <a href="#up_addrenv_destroy">4.5.2 <code>up_addrenv_destroy()</code></a>:
        Destroy an address environment.
      </li>
      <li>
        <a href="#up_addrenv_vtext">4.5.3 <code>up_addrenv_vtext()</code></a>:
        Returns the virtual base address of the <code>.text</code> address environment.
      </li>
      <li>
        <a href="#up_addrenv_vdata">4.5.4 <code>up_addrenv_vdata()</code></a>:
        Returns the virtual base address of the <code>.bss</code>/<code>.data</code> address environment.
      </li>
      <li>
        <a href="#up_addrenv_heapsize">4.5.5 <code>up_addrenv_heapsize()</code></a>:
       Return the initial heap size.
      </li>
      <li>
        <a href="#up_addrenv_select">4.5.6 <code>up_addrenv_select()</code></a>:
        Instantiate an address environment.
      </li>
      <li>
        <a href="#up_addrenv_restore">4.5.7 <code>up_addrenv_restore()</code></a>:
        Restore an address environment.
      </li>
      <li>
        <a href="#up_addrenv_clone">4.5.8 <code>up_addrenv_clone()</code></a>:
        Copy an address environment from one location to another.
      </li>
    </ul>
  </li>
  <li>
    <p>
      <b>Tasking Support</b>.
      Other interfaces must be provided to support higher-level interfaces used by the NuttX tasking logic.
      These interfaces are used by the functions in <code>sched/</code> and all operate on the task group which as been assigned an address environment by <code>up_addrenv_clone()</code>.
    </p>
    <ul>
      <li>
        <a href="#up_addrenv_attach">4.5.9 <code>up_addrenv_attach()</code></a>:
        Clone the group address environment assigned to a new thread.
        This operation is done when a pthread is created that share's the same address environment.
      </li>
      <li>
        <a href="#up_addrenv_detach">4.5.10 <code>up_addrenv_detach()</code></a>:
        Release the thread's reference to a group address environment when a task/thread exits.
      </li>
    </ul>
  </li>
  <li>
    <p>
      <b>Dynamic Stack Support</b>.
      <code>CONFIG_ARCH_STACK_DYNAMIC=y</code> indicates that the user process stack resides in its own address space.
      This option is also <i>required</i> if <code> CONFIG_BUILD_KERNEL</code> and <code>CONFIG_LIBC_EXECFUNCS</code> are selected.
      Why?
      Because the caller's stack must be preserved in its own address space when we instantiate the environment of the new process in order to initialize it.
    </p>
    <p>
      <b>NOTE:</b> The naming of the <code>CONFIG_ARCH_STACK_DYNAMIC</code> selection implies that dynamic stack allocation is supported.
      Certainly this option must be set if dynamic stack allocation is supported by a platform.
      But the more general meaning of this configuration environment is simply that the stack has its own address space.
    </p>
    <p>
      If <code>CONFIG_ARCH_STACK_DYNAMIC=y</code> is selected then the platform specific code must export these additional interfaces:
    </p>
    <ul>
      <li>
        <a href="#up_addrenv_ustackalloc">4.5.11 <code>up_addrenv_ustackalloc()</code></a>:
        Create a stack address environment
      </li>
      <li>
        <a href="#up_addrenv_ustackfree">4.5.12 <code>up_addrenv_ustackfree()</code></a>:
        Destroy a stack address environment.
      </li>
      <li>
        <a href="#up_addrenv_vustack">4.5.13 <code>up_addrenv_vustack()</code></a>:
        Returns the virtual base address of the stack
      </li>
      <li>
        <a href="#up_addrenv_ustackselect">4.5.14 <code>up_addrenv_ustackselect()</code></a>:
        Instantiate a stack address environment
      </li>
    </ul>
  </li>
  <li>
    <p>
      If <code>CONFIG_ARCH_KERNEL_STACK</code> is selected, then each user process will have two stacks:  (1) a large (and possibly dynamic) user stack and (2) a smaller kernel stack.  However, this option is <i>required</i> if both <code>CONFIG_BUILD_KERNEL</code> and <code>CONFIG_LIBC_EXECFUNCS</code> are selected.  Why?  Because when we instantiate and initialize the address environment of the new user process, we will temporarily lose the address environment of the old user process, including its stack contents.  The kernel C logic will crash immediately with no valid stack in place.
    </p>
    <p>
      If <code>CONFIG_ARCH_KERNEL_STACK=y</code> is selected then the platform specific code must export these additional interfaces:
    </p>
    <ul>   
      <li>
        <a href="#up_addrenv_kstackalloc">4.5.15 <code>up_addrenv_kstackalloc()</code></a>:
        Allocate the process kernel stack.
      </li>
        <a href="#up_addrenv_kstackfree">4.5.16 <code>up_addrenv_kstackfree()</code></a>:
        Free the process kernel stack.
      </li>
    </ul>
  </li>
</ol>

<h3><a name="up_addrenv_create">4.5.1 <code>up_addrenv_create()</code></a></h3>
<p><b>Function Prototype</b>:</p>
<ul>
  <code>int up_addrenv_create(size_t textsize, size_t datasize, size_t heapsize, FAR group_addrenv_t *addrenv);</code>
</ul>
<p><b>Description</b>:</p>
<ul>
  This function is called when a new task is created in order to instantiate an address environment for the new task group.
  <code>up_addrenv_create()</code> is essentially the allocator of the physical memory for the new task.
</ul>
<p><b>Input Parameters</b>:</p>
<ul>
  <li><code>textsize</code>: The size (in bytes) of the <code>.text</code> address environment needed by the task.  This region may be read/execute only.</li>
  <li><code>datasize</code>: The size (in bytes) of the <code>.bss/.data</code> address environment needed by the task.   This region may be read/write only.</li>
  <li><code>heapsize</code>: The initial size (in bytes) of the heap address environment needed by the task.  This region may be read/write only.</li>
  <li><code>addrenv</code>: The location to return the representation of the task address environment.</li>
</ul>
<p><b>Returned Value</b>:</p>
<ul>
  Zero (<code>OK</code>) on success; a negated <code>errno</code> value on failure.
</ul>

<h3><a name="up_addrenv_destroy">4.5.2 <code>up_addrenv_destroy()</code></a></h3>
<p><b>Function Prototype</b>:<p>
<ul>
  <code>int up_addrenv_destroy(group_addrenv_t *addrenv);</code>
</ul>
<p><b>Description</b>:</p>
<ul>
  This function is called when a final thread leaves the task group and the task group is destroyed.  This function then destroys the defunct address environment, releasing the underlying physical memory allocated by <code>up_addrenv_create()</code>.
</ul>
<p><b>Input Parameters</b>:</p>
<ul>
  <li><code>addrenv</code>: The representation of the task address environment previously returned by <code>up_addrenv_create()</code>.</li>
</ul>
<p><b>Returned Value</b>:</p>
<ul>
  Zero (<code>OK</code>) on success; a negated <code>errno</code> value on failure.
</ul>

<h3><a name="up_addrenv_vtext">4.5.3 <code>up_addrenv_vtext()</code></a></h3>
<p><b>Function Prototype</b>:<p>
<ul>
  <code>int up_addrenv_vtext(FAR group_addrenv_t addrenv, FAR void **vtext);</code>
</ul>
<p><b>Description</b>:</p>
<ul>
  Return the virtual <code>.text</code> address associated with the newly create address environment.
  This function is used by the binary loaders in order get an address that can be used to initialize the new task.
</ul>
<p><b>Input Parameters</b>:</p>
<ul>
  <li><code>addrenv</code>: The representation of the task address environment previously returned by <code>up_addrenv_create()</code>.</li>
  <li><code>vtext</code>: The location to return the virtual address.</li>
</ul>
<p><b>Returned Value</b>:</p>
<ul>
  Zero (<code>OK</code>) on success; a negated <code>errno</code> value on failure.
</ul>

<h3><a name="up_addrenv_vdata">4.5.4 <code>up_addrenv_vdata()</code></a></h3>
<p><b>Function Prototype</b>:<p>
<ul>
  <code>int up_addrenv_vdata(FAR group_addrenv_t *addrenv, size_t textsize, FAR void **vdata);</code>
</ul>
<p><b>Description</b>:</p>
<ul>
  Return the virtual <code>.text</code> address associated with the newly create address environment.
  This function is used by the binary loaders in order get an address that can be used to initialize the new task.
</ul>
<p><b>Input Parameters</b>:</p>
<ul>
  <li><code>addrenv</code>: The representation of the task address environment previously returned by <code>up_addrenv_create()</code>.</li>
  <li><code>textsize</code>: For some implementations, the text and data will be saved in the same memory region (read/write/execute) and, in this case, the virtual address of the data just lies at this offset into the common region.</li>
  <li><code>vdata</code>: The location to return the virtual address.</li>
</ul>
<p><b>Returned Value</b>:</p>
<ul>
  Zero (<code>OK</code>) on success; a negated <code>errno</code> value on failure.
</ul>

<h3><a name="up_addrenv_heapsize">4.5.5 <code>up_addrenv_heapsize()</code></a></h3>
<p><b>Function Prototype</b>:<p>
<ul>
  <code>ssize_t up_addrenv_heapsize(FAR const group_addrenv_t *addrenv);</code>
</ul>
<p><b>Description</b>:</p>
<ul>
  Return the initial heap allocation size.
  That is the amount of memory allocated by <code>up_addrenv_create()</code> when the heap memory region was first created.
  This may or may not differ from the <code>heapsize</code> parameter that was passed to <code>up_addrenv_create()</code>.
</ul>
<p><b>Input Parameters</b>:</p>
<ul>
  <li><code>addrenv</code>: The representation of the task address environment previously returned by <code>up_addrenv_create()</code>.</li>
</ul>
<p><b>Returned Value</b>:</p>
<ul>
  The initial heap size allocated is returned on success; a negated <code>errno</code> value on failure.
</ul>

<h3><a name="up_addrenv_select">4.5.6 <code>up_addrenv_select()</code></a></h3>
<p><b>Function Prototype</b>:<p>
<ul>
  <code>int up_addrenv_select(group_addrenv_t *addrenv, save_addrenv_t *oldenv);</code>
</ul>
<p><b>Description</b>:</p>
<ul>
  After an address environment has been established for a task (via <code>up_addrenv_create())</code>, this function may be called to to instantiate that address environment in the virtual address space.
  This might be necessary, for example, to load the code for the task from a file or to access address environment private data.
</ul>
<p><b>Input Parameters</b>:</p>
<ul>
  <li><code>addrenv</code>: The representation of the task address environment previously returned by <code>up_addrenv_create()</code>.</li>
  <li><code>oldenv</code>:
    The address environment that was in place before <code>up_addrenv_select()</code> was called.
    This may be used with <code>up_addrenv_restore()</code> to restore the original  address environment that was in place before <code>up_addrenv_select()</code> was called.
    Note that this may be a task agnostic, platform-specific representation that may or may not be different from <code>group_addrenv_t</code>.
  </li>
</ul>
<p><b>Returned Value</b>:</p>
<ul>
  Zero (<code>OK</code>) on success; a negated <code>errno</code> value on failure.
</ul>

<h3><a name="up_addrenv_restore">4.5.7 <code>up_addrenv_restore()</code></a></h3>
<p><b>Function Prototype</b>:<p>
<ul>
  <code>int up_addrenv_restore(save_addrenv_t oldenv);</code>
</ul>
<p><b>Description</b>:</p>
<ul>
  After an address environment has been temporarily instantiated by <code>up_addrenv_select</code>,
  this function may be called to to restore the original address environment.
</ul>
<p><b>Input Parameters</b>:</p>
<ul>
  <li><code>oldenv</code>: The platform-specific representation of the address environment previously returned by <code>up_addrenv_select()</code>.</li>
</ul>
<p><b>Returned Value</b>:</p>
<ul>
  Zero (<code>OK</code>) on success; a negated <code>errno</code> value on failure.
</ul>

<h3><a name="up_addrenv_clone">4.5.8 <code>up_addrenv_clone()</code></a></h3>
<p><b>Function Prototype</b>:<p>
<ul>
  <code>int up_addrenv_clone(FAR const task_group_s *src, FAR struct task_group_s *dest);</code>
</ul>
<p><b>Description</b>:</p>
<ul>
  Duplicate an address environment.  This does not copy the underlying memory, only the representation that can be used to instantiate that memory as an address environment.
</ul>
<p><b>Input Parameters</b>:</p>
<ul>
  <li><code>src</code>: The address environment to be copied.</li>
  <li><code>dest</code>: The location to receive the copied address environment.</li>
</ul>
<p><b>Returned Value</b>:</p>
<ul>
  Zero (<code>OK</code>) on success; a negated <code>errno</code> value on failure.
</ul>

<h3><a name="up_addrenv_attach">4.5.9 <code>up_addrenv_attach()</code></a></h3>
<p><b>Function Prototype</b>:<p>
<ul>
  <code>int up_addrenv_attach(FAR struct task_group_s *group, FAR struct tcb_s *tcb);</code>
</ul>
<p><b>Description</b>:</p>
<ul>
  <p>
  This function is called from the core scheduler logic when a thread is created that needs to share the address environment of its task group.
  In this case, the group's address environment may need to be &quot;cloned&quot; for the child thread.
  </p>
  <p>
  NOTE: In most platforms, nothing will need to be done in this case.
  Simply being a member of the group that has the address environment may be sufficient.
  </p>
</ul>
<p><b>Input Parameters</b>:</p>
<ul>
  <li><code>group</code>: The task group to which the new thread belongs.</li>
  <li><code>ctcb</code>: The TCB of the thread needing the address environment.</li>
</ul>
<p><b>Returned Value</b>:</p>
<ul>
  Zero (<code>OK</code>) on success; a negated <code>errno</code> value on failure.
</ul>

<h3><a name="up_addrenv_detach">4.5.10 <code>up_addrenv_detach()</code></a></h3>
<p><b>Function Prototype</b>:<p>
<ul>
  <code>int up_addrenv_detach(FAR struct task_group_s *group, FAR struct task_group_s *tcb);</code>
</ul>
<p><b>Description</b>:</p>
<ul>
  This function is called when a task or thread exits in order to release its reference to an address environment.  The address environment, however, should persist until up_addrenv_destroy() is called when the task group is itself destroyed.  Any resources unique to this thread  may be destroyed now.
</ul>
<p><b>Input Parameters</b>:</p>
<ul>
  <li><code>group</code>: The group to which the thread belonged.</li>
  <li><code>tcb</code>: The TCB of the task or thread whose the address environment will be released.</li>
</ul>
<p><b>Returned Value</b>:</p>
<ul>
  Zero (<code>OK</code>) on success; a negated <code>errno</code> value on failure.
</ul>

<h3><a name="up_addrenv_ustackalloc">4.5.11 <code>up_addrenv_ustackalloc()</code></a></h3>
<p><b>Function Prototype</b>:<p>
<ul>
  <code>int up_addrenv_ustackalloc(FAR struct tcb_s *tcb, size_t stacksize);</code>
</ul>
<p><b>Description</b>:</p>
<ul>
<p>
  This function is called when a new thread is created in order to instantiate an address environment for the new thread's stack.
  <code>up_addrenv_ustackalloc()</code> is essentially the allocator of the physical memory for the new task's stack.
</p>
</ul>
<p><b>Input Parameters</b>:</p>
<ul>
  <li><code>tcb</code>: The TCB of the thread that requires the stack address environment.</li>
  <li><code>stacksize</code>: The size (in bytes) of the initial stack address environment needed by the task.  This region may be read/write only.</li>
</ul>
<p><b>Returned Value</b>:</p>
<ul>
  Zero (<code>OK</code>) on success; a negated <code>errno</code> value on failure.
</ul>

<h3><a name="up_addrenv_up_addrenv_ustackfreeattach">4.5.12 <code>up_addrenv_ustackfree()</code></a></h3>
<p><b>Function Prototype</b>:<p>
<ul>
  <code>int up_addrenv_ustackfree(FAR struct tcb_s *tcb);</code>
</ul>
<p><b>Description</b>:</p>
<ul>
  <p>
    This function is called when any thread exits.
    This function then destroys the defunct address environment for the thread's stack, releasing the underlying physical memory.
  </p>
</ul>
<p><b>Input Parameters</b>:</p>
<ul>
  <li><code>tcb</code>: The TCB of the thread that no longer requires the stack address environment.</li>
</ul>
<p><b>Returned Value</b>:</p>
<ul>
  Zero (<code>OK</code>) on success; a negated <code>errno</code> value on failure.
</ul>

<h3><a name="up_addrenv_vustack">4.5.13 <code>up_addrenv_vustack()</code></a></h3>
<p><b>Function Prototype</b>:<p>
<ul>
  <code>int up_addrenv_vustack(FAR const struct tcb_s *tcb, FAR void **vstack);</code>
</ul>
<p><b>Description</b>:</p>
<ul>
  <p>
    Return the virtual address associated with the newly create stack address environment.
  </p>
</ul>
<p><b>Input Parameters</b>:</p>
<ul>
  <li><code>tcb</code>:The TCB of the thread with the stack address environment of interest. </li>
  <li><code>vstack</code>: The location to return the stack virtual base address.</li>
</ul>
<p><b>Returned Value</b>:</p>
<ul>
  Zero (<code>OK</code>) on success; a negated <code>errno</code> value on failure.
</ul>

<h3><a name="up_addrenv_ustackselect">4.5.14 <code>up_addrenv_ustackselect()</code></a></h3>
<p><b>Function Prototype</b>:<p>
<ul>
  <code>int up_addrenv_ustackselect(FAR const struct tcb_s *tcb);</code>
</ul>
<p><b>Description</b>:</p>
<ul>
  <P>
    After an address environment has been established for a task's stack (via <code>up_addrenv_ustackalloc()</code>.
    This function may be called to instantiate that address environment in the virtual address space.
    This is a necessary step before each context switch to the newly created thread (including the initial thread startup).
  </p>
</ul>
<p><b>Input Parameters</b>:</p>
<ul>
  <li><code>tcb</code>: The TCB of the thread with the stack address environment to be instantiated.</li>
</ul>
<p><b>Returned Value</b>:</p>
<ul>
  Zero (<code>OK</code>) on success; a negated <code>errno</code> value on failure.
</ul>

<h3><a name="up_addrenv_kstackalloc">4.5.15 <code>up_addrenv_kstackalloc()</code></a></h3>
<p><b>Function Prototype</b>:<p>
<ul>
  <code>int up_addrenv_kstackalloc(FAR struct tcb_s *tcb);</code>
</ul>
<p><b>Description</b>:</p>
<ul>
  <p>
    This function is called when a new thread is created to allocate the new thread's kernel stack.
    This function may be called for certain terminating threads which have no kernel stack.
    It must be tolerant of that case.
  </p>
</ul>
<p><b>Input Parameters</b>:</p>
<ul>
  <li><code>tcb</code>: The TCB of the thread that requires the kernel stack.</li>
</ul>
<p><b>Returned Value</b>:</p>
<ul>
  Zero (<code>OK</code>) on success; a negated <code>errno</code> value on failure.
</ul>

<h3><a name="up_addrenv_kstackfree">4.5.16 <code>up_addrenv_kstackfree()</code></a></h3>
<p><b>Function Prototype</b>:<p>
<ul>
  <code>int up_addrenv_kstackfree(FAR struct tcb_s *tcb);</code>
</ul>
<p><b>Description</b>:</p>
<ul>
  <p>
    This function is called when any thread exits.  This function frees the kernel stack.
  </p>
</ul>
<p><b>Input Parameters</b>:</p>
<ul>
  <li>
    <code>tcb</code>: The TCB of the thread that no longer requires the kernel stack.
  </li>
</ul>
<p><b>Returned Value</b>:</p>
<ul>
  Zero (<code>OK</code>) on success; a negated <code>errno</code> value on failure.
</ul>

<h2><a name="boardctl">4.6 <code>boardctl()</code> Application Interface</a></h2>

<p><b>Function Prototype</b>:<p>
<ul>
  <code>
  include &lt;sys/boardctl.h&gt;<br>
  int boardctl(unsigned int cmd, uintptr_t arg);
  </code>
</ul>
<p><b>Description</b>:</p>
<ul>
  <p>
    In a small embedded system, there will typically be a much greater interaction between application and low-level board features.
    The canonically correct to implement such interactions is by implementing a character driver and performing the interactions via low level <code>ioctl()</code> calls.
    This, however, may not be practical in many cases and will lead to &quot;correct&quot; but awkward implementations.
  </p>
  <p>
    <code>boardctl()</code> is <i>non-standard</i> OS interface to alleviate the problem.
    It basically circumvents the normal device driver <code>ioctl()</code> interlace and allows the application to perform direct IOCTL-like calls to the board-specific logic.
    It is especially useful for setting up board operational and test configurations.
  </p>
  <p>
    <b>NOTE:</b> The other interfaces described in this document are internal OS interface.
    <code>boardctl()</code> is an application interface to the OS.
    There is not point, in fact, of using <code>boardctl()</code> within the OS;
    the board interfaces prototyped in <code>include/nuttx/board.h</code> may be called directly from within the OS.
  </p>
  <p>
    Application interfaces are described in the <a href="NuttxUserGuide.html">NuttX User Guide</a>.
    This application interface interface is described here only because it is so non-standard and because it is so closely tied to board porting logic.
  </p>
</ul>
<p><b>Input Parameters</b>:</p>
<ul>
  <li>
    <code>cmd</code>: Identifies the board command to be executed.
    See <code>include/sys/boardctl.h</code> for the complete list of common board commands.
    Provisions are made to support non-common, board-specific commands as well.
  </li>
  <li>
    <code>arg</code>: The argument that accompanies the command.
    The nature of the argument is determined by the specific command.
  </li>
</ul>
<p><b>Returned Value</b>:</p>
<ul>
  On success zero (<code>OK</code>) is returned;
  -1 (<code>ERROR</code>) is returned on failure with the <code>errno</code> variable to to indicate the nature of the failure.
</ul>

<h2><a name="exports">4.7 APIs Exported by NuttX to Architecture-Specific Logic</a></h2>
<p>
  These are standard interfaces that are exported by the OS
  for use by the architecture specific logic.
</p>

<h3><a name="osstart">4.7.1 <code>os_start()</code></a></h3>
<p>
  <b><i>To be provided</i></b>
</p>

<h3><a name="listmgmt">4.7.2 OS List Management APIs</a></h3></h3>
<p>
  <b><i>To be provided</i></b>
</p>

<h3><a name="schedprocesstimer">4.7.3 <code>sched_process_timer()</code></a></h3>
<p><b>Function Prototype</b>: <code>void sched_process_timer(void);</code></p>

<p><b>Description</b>.
  This function handles system timer events.
  The timer interrupt logic itself is implemented in the
  architecture specific code, but must call the following OS
  function periodically -- the calling interval must be
  <code>MSEC_PER_TICK</code>.
</p>

<h3><a name="schedtimerexpiration">4.7.4 <code>sched_timer_expiration()</code></a></h3>
<p><b>Function Prototype</b>:<p>
<ul><pre>
#include &lt;nuttx/arch.h&gt;
void sched_timer_expiration(void);
</ul>
<p><b>Description</b>:</p>
  Description: if <code>CONFIG_SCHED_TICKLESS</code> is defined, then this function is provided by the RTOS base code and called from platform-specific code when the interval timer used to implemented the tick-less OS expires.
<ul>
</ul>
<p><b>Input Parameters</b>:</p>
<ul>
  None
</ul>
<p><b>Returned Value</b>:</p>
<ul>
  None
</ul>
<p><b>Assumptions</b>:</p>
<ul>
  Base code implementation assumes that this function is called from interrupt handling logic with interrupts disabled.
</ul>

<h3><a name="schedalarmexpiration">4.7.5 <code>sched_alaram_expiration()</code></a></h3>
<p><b>Function Prototype</b>:<p>
<ul><pre>
#include &lt;nuttx/arch.h&gt;
void sched_timer_expiration(void);
</ul>
<p><b>Description</b>:</p>
  Description: if <code>CONFIG_SCHED_TICKLESS</code> is defined, then this function is provided by the RTOS base code and called from platform-specific code when the interval timer used to implemented the tick-less OS expires.
<ul>
</ul>
<p><b>Input Parameters</b>:</p>
<ul>
  None
</ul>
<p><b>Returned Value</b>:</p>
<ul>
  None
</ul>
<p><b>Assumptions</b>:</p>
<ul>
  Base code implementation assumes that this function is called from interrupt handling logic with interrupts disabled.
</ul>

<h3><a name="irqdispatch">4.7.6 <code>irq_dispatch()</code></a></h3>
<p><b>Function Prototype</b>: <code>void irq_dispatch(int irq, FAR void *context);</code></p>

<p><b>Description</b>.
  This function must be called from the architecture-
  specific logic in order to display an interrupt to
  the appropriate, registered handling logic.
</p>

<h2><a name="shm">4.8 Shared Memory</a></h2>
<p>
  Shared memory interfaces are only available with the NuttX kernel build (<code>CONFIG_BUILD_KERNEL=y</code>).
  These interfaces support user memory regions that can be shared between multiple user processes.
  The user interfaces are provided in the standard header file <code>include/sys/shm.h></code>.
  All logic to support shared memory is implemented within the NuttX kernel with the exception of two low-level functions that are require to configure the platform-specific MMU resources.
  Those interfaces are described below:
</p>

<h3><a name="upshmat">4.8.1 <code>up_shmat()</code></a></h3>
<p><b>Function Prototype</b>:<p>
<ul><pre>
#include &lt;nuttx/arch.h&gt;
#ifdef CONFIG_MM_SHM
int up_shmat(FAR uintptr_t *pages, unsigned int npages, uintptr_t vaddr);
#endif
</ul>
<p><b>Description</b>:</p>
<ul>
  Attach, i.e, map, on shared memory region to a user virtual address.
</ul>
<p><b>Input Parameters</b>:</p>
<ul>
  <li>
    <code>pages</code>: A pointer to the first element in a array of physical address, each corresponding to one page of memory.
  </li>
  <li>
    <code>npages</code>: The number of pages in the list of physical pages to be mapped.
  </li>
  <li>
    <code>vaddr</code>: The virtual address corresponding to the beginning of the (contiguous) virtual address region.
  </li>
</ul>
<p><b>Returned Value</b>:</p>
<ul>
  Zero (<code>OK</code>) is returned on success; a negated <code>errno</code> value is returned on failure.
</ul>

<h3><a name="upshmdt">4.8.2 <code>up_shmdt()</code></a></h3>
<p><b>Function Prototype</b>:<p>
<ul><pre>
#include &lt;nuttx/arch.h&gt;
#ifdef CONFIG_MM_SHM
int up_shmdt(uintptr_t vaddr, unsigned int npages);
#endif
</ul>
<p><b>Description</b>:</p>
<ul>
  Detach, i.e, unmap, on shared memory region from a user virtual address.
</ul>
<p><b>Input Parameters</b>:</p>
<ul>
  <li>
    <code>vaddr</code>: The virtual address corresponding to the beginning of the (contiguous) virtual address region.
  </li>
  <li>
    <code>npages</code>: T The number of pages to be unmapped.
  </li>
</ul>
<p><b>Returned Value</b>:</p>
<ul>
  Zero (<code>OK</code>) is returned on success; a negated <code>errno</code> value is returned on failure.
</ul>

<h2><a name="demandpaging">4.9 On-Demand Paging</a></h2>
<p>
  The NuttX On-Demand Paging feature permits embedded MCUs with some limited RAM space to execute large programs from some non-random access media.
  If the platform meets certain requirements, then NuttX can provide on-demand paging:
  It can copy .text from the large program in non-volatile media into RAM as needed to execute a huge program from the small RAM.
  Design and porting issues for this feature are discussed in a separate document.
  Please see the <a href="NuttXDemandPaging.html">NuttX Demand Paging</a> design document for further information.
</p>

<h2><a name="ledsupport">4.10 LED Support</a></h2>

<p>
  A board architecture may or may not have LEDs.
  If the board does have LEDs, then most architectures provide similar LED support that is enabled when <code>CONFIG_ARCH_LEDS</code>
  is selected in the NuttX configuration file.
  This LED support is part of architecture-specific logic and is not managed by the core NuttX logic.
  However, the support provided by each architecture is sufficiently similar that it can be documented here.
</p>

<h3><a name="ledheaders">4.10.1 Header Files</a></h3>

<p>
  LED-related definitions are provided in two header files:
  <ul>
    <li>
       LED definitions are provided for each board in the <code>board.h</code> that resides
       in the <code><i>&lt;board-name&gt;</i>/include/board.h</code> file (which is also
       linked to <code>include/arch/board/board.h</code> when the RTOS is configured).
       Those definitions are discussed <a href="#leddefinitions">below</a>.
    </li>
    <li>
       The board-specific logic provides unique instances of the LED interfaces.
       This is because the implementation of LED support may be very different
       on different boards.
       Prototypes for these board-specific implementations are, however, provided
       in architecture-common header files.
       That header file is usually at <code><i>&lt;arch-name&gt;</i>/src/common/up_internal.h</code>,
       but could be at other locations in particular architectures.
       These prototypes are discussed <a href="#ledapis">below</a>.
    </li>
  </ul>
</p>

<h3><a name="leddefinitions">4.10.2 LED Definitions</a></h3>

<p>
   The implementation of LED support is very specific to a board architecture.
   Some boards have several LEDS, others have only one or two.
   Some have none.
   Others LED matrices and show alphanumeric data, etc.
   The NuttX logic does not refer to specific LEDS, rather, it refers to an event to be shown on the LEDS
   in whatever manner is appropriate for the board;
   the way that this event is presented depends upon the hardware available on the board.
</p>
<p>
   The model used by NuttX is that the board can show 8 events defined as follows in <code><i>&lt;board-name&gt;</i>/include/board.h</code>:
</p>
<ul><pre>
#define LED_STARTED       ??
#define LED_HEAPALLOCATE  ??
#define LED_IRQSENABLED   ??
#define LED_STACKCREATED  ??
#define LED_INIRQ         ??
#define LED_SIGNAL        ??
#define LED_ASSERTION     ??
#define LED_PANIC         ??
</pre></ul>
<p>
  The specific value assigned to each pre-processor variable can be whatever makes the implementation easiest for the board logic.
  The <i>meaning</i> associated with each definition is as follows:
</p>
<ul>
  <li>
    <code>LED_STARTED</code> is the value that describes the setting of the LEDs when the LED logic is first initialized.
    This LED value is set but never cleared.
  </li>
  <li>
    <code>LED_HEAPALLOCATE</code> indicates that the NuttX heap has been configured.
    This is an important place in the boot sequence because if the memory is configured wrong, it will probably crash leaving this LED setting.
    This LED value is set but never cleared.
  </li>
  <li>
    <code>LED_IRQSENABLED</code> indicates that interrupts have been enabled.
    Again, during bring-up (or if there are hardware problems), it is very likely that the system may crash just when interrupts are enabled, leaving this setting on the LEDs.
    This LED value is set but never cleared.
  </li>
  <li>
    <code>LED_STACKCREATED</code> is set each time a new stack is created.
    If set, it means that the system attempted to start at least one new thread.
    This LED value is set but never cleared.
  </li>
  <li>
    <code>LED_INIRQ</code> is set and cleared on entry and exit from each interrupt.
    If interrupts are working okay, this LED will have a dull glow.
  </li>
  <li>
    <code>LED_SIGNAL</code> is set and cleared on entry and exit from a signal handler.
    Signal handlers are tricky so this is especially useful during bring-up or a new architecture.
  </li>
  <li>
    <code>LED_ASSERTION</code> is set if an assertion occurs.
  </li>
  <li>
    <code>LED_PANIC</code> will blink at around 1Hz if the system panics and hangs.
  </li>
</ul>

<h3><a name="ledapis">4.10.3 Common LED interfaces</a></h3>

<p>
  The <code>include/nuttx/board.h</code> has declarations like:
</p>
<ul><pre>
#ifdef CONFIG_ARCH_LEDS
void board_led_initialize(void);
void board_led_on(int led);
void board_led_off(int led);
#else
# define board_led_initialize()
# define board_led_on(led)
# define board_led_off(led)
#endif
</pre></ul>
<p>
   Where:
<p>
<ul>
  <li>
  <p>
    <code>void board_led_initialize(void)</code> is called early in power-up initialization to initialize the LED hardware.
  </p>
  <small><blockquote>
    <b>NOTE:</b> In most architectures, <code>board_led_initialize()</code> is called from board-specific initialization logic.
    But there are a few architectures where this initialization function is still called from common chip architecture logic.
    This interface is nott, however, a common board interface in any event.
  </blockquote>
  <blockquote>
    <b>WARNING:</b> This interface name will eventually be removed; do not use it in new board ports.
    New implementations should not use the naming convention for common board interfaces, but should instted use the naming conventions for microprocessor-specific interfaces or the board-specific interfaces (such as <code>stm32_led_initialize()</code>).
  </blockquote></small>
  </li>
  <li>
  <p>
    <code>board_led_on(int led)</code> is called to instantiate the LED presentation of the event.
    The <code>led</code> argument is one of the definitions provided in <code><i>&lt;board-name&gt;</i>/include/board.h</code>.
  </p>
  </li>
  <p>
  <li>
    <code>board_led_off(int led</code>is called to terminate the LED presentation of the event.
    The <code>led</code> argument is one of the definitions provided in <code><i>&lt;board-name&gt;</i>/include/board.h</code>.
    Note that only <code>LED_INIRQ</code>, <code>LED_SIGNAL</code>, <code>LED_ASSERTION</code>, and <code>LED_PANIC</code>
    indications are terminated.
  </p>
  </li>
</ul>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
    <td>
      <h1><a name="NxFileSystem">5.0 NuttX File System</a></h1>
    </td>
  </tr>
</table>

<p><b>Overview</b>.
  NuttX includes an optional, scalable file system.
  This file-system may be omitted altogether; NuttX does not depend on the presence
  of any file system.
</p>

<p><b>Pseudo Root File System</b>.
  Or, a simple <i>in-memory</i>, <i>pseudo</i> file system can be enabled.
  This simple file system can be enabled setting the CONFIG_NFILE_DESCRIPTORS
  option to a non-zero value (see <a href="#apndxconfigs">Appendix A</a>).
  This is an <i>in-memory</i> file system because it does not require any
  storage medium or block driver support.
  Rather, file system contents are generated on-the-fly as referenced via
  standard file system operations (open, close, read, write, etc.).
  In this sense, the file system is <i>pseudo</i> file system (in the
  same sense that the Linux <code>/proc</code> file system is also
  referred to as a pseudo file system).
</p>

<p>
  Any user supplied data or logic can be accessed via the pseudo-file system.
  Built in support is provided for character and block <a href="#DeviceDrivers">drivers</a> in the
  <code>/dev</code> pseudo file system directory.
</p>

<p><b>Mounted File Systems</b>
  The simple in-memory file system can be extended my mounting block
  devices that provide access to true file systems backed up via some
  mass storage device.
  NuttX supports the standard <code>mount()</code> command that allows
  a block driver to be bound to a mountpoint within the pseudo file system
  and to a file system.
  At present, NuttX supports the standard VFAT and ROMFS file systems,
  a special, wear-leveling NuttX FLASH File System (NXFFS),
  as well as a Network File System client (NFS version 3, UDP).
</p>

<p><b>Comparison to Linux</b>
  From a programming perspective, the NuttX file system appears very similar
  to a Linux file system.
  However, there is a fundamental difference:
  The NuttX root file system is a pseudo file system and true file systems may be
  mounted in the pseudo file system.
  In the typical Linux installation by comparison, the Linux root file system
  is a true file system and pseudo file systems may be mounted in the true,
  root file system.
  The approach selected by NuttX is intended to support greater scalability
  from the very tiny platform to the moderate platform.
</p>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
    <td>
      <h1><a name="DeviceDrivers">6.0 NuttX Device Drivers</a></h1>
    </td>
  </tr>
</table>

<p>
  NuttX supports a variety of device drivers including:
  <ul>
    <li><i>Character</i> Device Drivers,</li>
    <li><i>Block</i> Device Drivers, and</li>
    <li>Other <i>Specialized</i> Drivers.</li>
  </ul>
  These different device driver types are discussed in the following paragraphs.
  Note: device driver support requires that the <i>in-memory</i>, <i>pseudo</i> file system
  is enabled by setting the CONFIG_NFILE_DESCRIPTORS in the NuttX configuration file to a
  non-zero value.
</p>

<h2><a name="chardrivers">6.1 Character Device Drivers</a></h2>

<p>
  Character device drivers have these properties:
</p>
<ul>
  <li>
    <p>
    <b><code>include/nuttx/fs/fs.h</code></b>.
    All structures and APIs needed to work with character drivers are provided in this header file.
    </p>
  </li>
  <li>
    <p>
    <b><code>struct file_operations</code></b>.
    Each character device driver must implement an instance of <code>struct file_operations</code>.
    That structure defines a call table with the following methods:
    <ul>
     <p><code>int open(FAR struct file *filep);</code><br>
     <code>int close(FAR struct file *filep);</code><br>
     <code>ssize_t read(FAR struct file *filep, FAR char *buffer, size_t buflen);</code><br>
     <code>ssize_t write(FAR struct file *filep, FAR const char *buffer, size_t buflen);</code><br>
     <code>off_t seek(FAR struct file *filep, off_t offset, int whence);</code><br>
     <code>int ioctl(FAR struct file *filep, int cmd, unsigned long arg);</code><br>
     <code>int poll(FAR struct file *filep, struct pollfd *fds, bool setup);</code></p>
    </ul>
    </p>
  </li>
  <li>
    <p>
    <b><code>int register_driver(const char *path, const struct file_operations *fops, mode_t mode, void *priv);</code></b>.
    Each character driver registers itself by calling <code>register_driver()</code>, passing it the
    <code>path</code> where it will appear in the <a href="#NxFileSystem">pseudo-file-system</a> and it's
    initialized instance of <code>struct file_operations</code>.
    </p>
  </li>
  <li>
    <p>
    <b>User Access</b>.
    After it has been registered, the character driver can be accessed by user code using the standard
    <a href="NuttxUserGuide.html#driveroperations">driver operations</a> including
    <code>open()</code>, <code>close()</code>, <code>read()</code>, <code>write()</code>, etc.
    </p>
  </li>
  <li>
    <p>
    <b>Specialized Character Drivers</b>.
    Within the common character driver framework, there are different specific varieties of <i>specialized</i> character drivers.
    The unique requirements of the underlying device hardware often mandates some customization of the character driver.
    These customizations tend to take the form of:
    </p>
    <ul>
      <li>
        Device-specific <code>ioctl()</code> commands used to performed specialized operations on the device.
        These <code>ioctl()</code> will be documented in header files under <code>include/nuttx</code> that detail the specific device interface.
      </li>
      <li>
        Specialized I/O formats.
        Some devices will require that <code>read()</code> and/or <code>write()</code> operations use data conforming to a specific format, rather than a plain stream of bytes.
        These specialized I/O formats will be documented in header files under <code>include/nuttx</code> that detail the specific device interface.
        The typical representation of the I/O format will be a C structure definition.
      </li>
    </ul>
    <p>
    The specialized character drivers support by NuttX are documented in the following paragraphs.
    </p>
  </li>
  <li>
    <p>
    <b>Examples</b>:
    <code>drivers/dev_null.c</code>, <code>drivers/fifo.c</code>, <code>drivers/serial.c</code>, etc.
    </p>
 </li>
</ul>

<h3><a name="serialdrivers">6.1.1 Serial Device Drivers</a></h3>

<ul>
  <li>
    <p>
    <b><code>include/nuttx/serial/serial.h</code></b>.
    All structures and APIs needed to work with serial drivers are provided in this header file.
    </p>
  </li>
  <li>
    <p>
    <b><code>struct uart_ops_s</code></b>.
    Each serial device driver must implement an instance of <code>struct uart_ops_s</code>.
    That structure defines a call table with the following methods:
    <ul>
     <p><code>int setup(FAR struct uart_dev_s *dev);</code><br>
     <code>void shutdown(FAR struct uart_dev_s *dev);</code><br>
     <code>int attach(FAR struct uart_dev_s *dev);</code><br>
     <code>void detach(FAR struct uart_dev_s *dev);</code><br>
     <code>int ioctl(FAR struct file *filep, int cmd, unsigned long arg);</code><br>
     <code>int receive(FAR struct uart_dev_s *dev, unsigned int *status);</code><br>
     <code>void rxint(FAR struct uart_dev_s *dev, bool enable);</code><br>
     <code>bool rxavailable(FAR struct uart_dev_s *dev);</code><br>
     <code>#ifdef CONFIG_SERIAL_IFLOWCONTROL</code><br>
     <code>bool rxflowcontrol(FAR struct uart_dev_s *dev, unsigned int nbuffered, bool upper);</code><br>
     <code>#endif</code><br>
     <code>void send(FAR struct uart_dev_s *dev, int ch);</code><br>
     <code>void txint(FAR struct uart_dev_s *dev, bool enable);</code><br>
     <code>bool txready(FAR struct uart_dev_s *dev);</code><br>
     <code>bool txempty(FAR struct uart_dev_s *dev);</code></p>
    </ul>
    </p>
  </li>
  <li>
    <p>
    <b><code>int uart_register(FAR const char *path, FAR uart_dev_t *dev);</code></b>.
    A serial driver may register itself by calling <code>uart_register()</code>, passing it the
    <code>path</code> where it will appear in the <a href="#NxFileSystem">pseudo-file-system</a> and it's
    initialized instance of <code>struct uart_ops_s</code>.
    By convention, serial device drivers are registered at paths like <code>/dev/ttyS0</code>, <code>/dev/ttyS1</code>, etc.
    See the <code>uart_register()</code> implementation in <code>drivers/serial.c</code>.
    </p>
  </li>
  <li>
    <p>
    <b>User Access</b>.
    Serial drivers are, ultimately, normal <a href="#chardrivers">character drivers</a> and are accessed as other character drivers.
    </p>
  </li>
  <li>
    <p>
    <b>Examples</b>:
    <code>arch/arm/src/chip/lm_serial.c</code>, <code>arch/arm/src/lpc214x/lpc214x_serial.c</code>, <code>arch/z16/src/z16f/z16f_serial.c</code>, etc.
    </p>
  </li>
</ul>

<h3><a name="tscdrivers">6.1.1 Touchscreen Device Drivers</a></h3>

<p>
  NuttX supports a two-part touchscreen driver architecture.
</p>
<ol>
  <li>
    An &quot;upper half&quot;, generic driver that provides the common touchscreen interface to application level code, and
  </li>
  <li>
    A &quot;lower half&quot;, platform-specific driver that implements the low-level touchscreen controls to implement the touchscreen functionality.
  </li>
</ol>
<p>
  Files supporting the touchscreen controller (TSC) driver can be found in the following locations:
</p>
<ul>
  <li><b>Interface Definition</b>.
    The header files for NuttX touchscreen drivers reside in the <code>include/nuttx/include/input</code> directory.
    The interface between the touchscreen controller &quot;upper half&quot; and &quot;lower half&quot; drivers are <i>not</i> common, but vary from controller-to-controller.
    Because of this, each touchscreen driver has its own unique header file that describes the &quot;upper half&quot;/&quot;lower half&quot; interface in that directory.
    The application level interface to each touchscreen driver, on the other hand, <i>is</i> the same for each touchscreen driver and is described <code>include/nuttx/include/input/touchscreen.h</code>.
    The touchscreen driver uses a standard character driver framework but read operations return specially formatted data.
  </li>
  <li><b>&quot;Upper Half&quot; Driver</b>.
    The controller-specific, &quot;upper half&quot; touchscreen drivers reside in the directory <code>drivers/input</code>.
  </li>
  <li><b>&quot;Lower Half&quot; Drivers</b>.
    Platform-specific touchscreen drivers reside in either: (1) The <code>arch/</code><i>&lt;architecture&gt;</i><code>/src/</code><i>&lt;chip&gt;</i> directory for the processor architectures that have build in touchscreen controllers or (2) the <code>configs/</code><i>&lt;board&gt;</i><code>/src/</code> directory for boards that use an external touchscreen controller chip.
  </li>
</ul>

<h3><a name="analogdrivers">6.1.2 Analog (ADC/DAC) Drivers</a></h3>
<p>
  The NuttX analog drivers are split into two parts:
</p>
<ol>
  <li>
    An &quot;upper half&quot;, generic driver that provides the common analog interface to application level code, and
  </li>
  <li>
    A &quot;lower half&quot;, platform-specific driver that implements the low-level controls to implement the analog functionality.
  </li>
</ol>
<ul>
  <li>
    General header files for the NuttX analog drivers reside in <code>include/nuttx/analog/</code>.
    These header files includes both the application level interface to the analog driver as well as the interface between the &quot;upper half&quot; and &quot;lower half&quot; drivers.
  </li>
  <li>
    Common analog logic and share-able analog drivers reside in the <code>drivers/analog/</code>.
  </li>
  <li>
    Platform-specific drivers reside in <code>arch/</code><i>&lt;architecture&gt;</i><code>/src/</code><i>&lt;chip&gt;</i> directory for the specific processor <i>&lt;architecture&gt;</i> and for the specific <i>&lt;chip&gt;</i> analog peripheral devices.
  </li>
</ul>

<h4><a name="adcdrivers">6.1.3.1 ADC Drivers</a></h4>
<ul>
  <li>
    <code>include/nuttx/analog/adc.h</code>.
    All structures and APIs needed to work with ADC drivers are provided in this header file.
    This header file includes:
    <ol>
      <li>
        Structures and interface descriptions needed to develop a low-level,
        architecture-specific, ADC driver.
      </li>
      <li>
        To register the ADC driver with a common ADC character driver.
      </li>
      <li>
        Interfaces needed for interfacing user programs with the common ADC character driver.
      </li>
    </ol>
  </li>
  <li>
    <code>drivers/analog/adc.c</code>.
    The implementation of the common ADC character driver.
  </li>
</ul>

<h4><a name="dacdrivers">6.1.3.2 DAC Drivers</a></h4>
<ul>
  <li>
    <code>include/nuttx/analog/dac.h</code>.
    All structures and APIs needed to work with DAC drivers are provided in this header file.
    This header file includes:
    <ol>
      <li>
        Structures and interface descriptions needed to develop a low-level,
        architecture-specific, DAC driver.
      </li>
      <li>
        To register the DAC driver with a common DAC character driver.
      </li>
      <li>
        Interfaces needed for interfacing user programs with the common DAC character driver.
      </li>
    </ol>
  </li>
  <li>
    <code>drivers/analog/dac.c</code>.
    The implementation of the common DAC character driver.
  </li>
</ul>

<h3><a name="pwmdrivers">6.1.4 PWM Drivers</a></h3>
<p>
  For the purposes of this driver, a PWM device is any device that generates periodic output pulses of controlled frequency and pulse width.
  Such a device might be used, for example, to perform pulse-width modulated output or frequency/pulse-count modulated output
  (such as might be needed to control a stepper motor).
</p>
<p>
  The NuttX PWM driver is split into two parts:
</p>
<ol>
  <li>
    An &quot;upper half&quot;, generic driver that provides the common PWM interface to application level code, and
  </li>
  <li>
    A &quot;lower half&quot;, platform-specific driver that implements the low-level timer controls to implement the PWM functionality.
  </li>
</ol>
<p>
  Files supporting PWM can be found in the following locations:
</p>
<ul>
  <li><b>Interface Definition</b>.
    The header file for the NuttX PWM driver reside at <code>include/nuttx/pwm.h</code>.
    This header file includes both the application level interface to the PWM driver as well as the interface between the &quot;upper half&quot; and &quot;lower half&quot; drivers.
    The PWM module uses a standard character driver framework.
    However, since the PWM driver is a devices control interface and not a data transfer interface,
    the majority of the functionality available to the application is implemented in driver ioctl calls.
  </li>
  <li><b>&quot;Upper Half&quot; Driver</b>.
    The generic, &quot;upper half&quot; PWM driver resides at <code>drivers/pwm.c</code>.
  </li>
  <li><b>&quot;Lower Half&quot; Drivers</b>.
    Platform-specific PWM drivers reside in <code>arch/</code><i>&lt;architecture&gt;</i><code>/src/</code><i>&lt;chip&gt;</i> directory for the specific processor <i>&lt;architecture&gt;</i> and for the specific <i>&lt;chip&gt;</i> PWM peripheral devices.
  </li>
</ul>

<h3><a name="candrivers">6.1.5 CAN Drivers</a></h3>
<p>
  NuttX supports only a very low-level CAN driver.
  This driver supports only the data exchange and does not include any high-level CAN protocol.
  The NuttX CAN driver is split into two parts:
</p>
<ol>
  <li>
    An &quot;upper half&quot;, generic driver that provides the common CAN interface to application level code, and
  </li>
  <li>
    A &quot;lower half&quot;, platform-specific driver that implements the low-level timer controls to implement the CAN functionality.
  </li>
</ol>
<p>
  Files supporting CAN can be found in the following locations:
</p>
<ul>
  <li><b>Interface Definition</b>.
    The header file for the NuttX CAN driver reside at <code>include/nuttx/can.h</code>.
    This header file includes both the application level interface to the CAN driver as well as the interface between the &quot;upper half&quot; and &quot;lower half&quot; drivers.
    The CAN module uses a standard character driver framework.
  </li>
  <li><b>&quot;Upper Half&quot; Driver</b>.
    The generic, &quot;upper half&quot; CAN driver resides at <code>drivers/can.c</code>.
  </li>
  <li><b>&quot;Lower Half&quot; Drivers</b>.
    Platform-specific CAN drivers reside in <code>arch/</code><i>&lt;architecture&gt;</i><code>/src/</code><i>&lt;chip&gt;</i> directory for the specific processor <i>&lt;architecture&gt;</i> and for the specific <i>&lt;chip&gt;</i> CAN peripheral devices.
  </li>
</ul>

<h3><a name="quadencoder">6.1.6 Quadrature Encoder Drivers</a></h3>
<p>
  NuttX supports a low-level, two-part Quadrature Encoder driver.
</p>
<ol>
  <li>
    An &quot;upper half&quot;, generic driver that provides the common Quadrature Encoder interface to application level code, and
  </li>
  <li>
    A &quot;lower half&quot;, platform-specific driver that implements the low-level timer controls to implement the Quadrature Encoder functionality.
  </li>
</ol>
<p>
  Files supporting the Quadrature Encoder can be found in the following locations:
</p>
<ul>
  <li><b>Interface Definition</b>.
    The header file for the NuttX Quadrature Encoder driver reside at <code>include/nuttx/sensors/qencoder.h</code>.
    This header file includes both the application level interface to the Quadrature Encoder driver as well as the interface between the &quot;upper half&quot; and &quot;lower half&quot; drivers.
    The Quadrature Encoder module uses a standard character driver framework.
  </li>
  <li><b>&quot;Upper Half&quot; Driver</b>.
    The generic, &quot;upper half&quot; Quadrature Encoder driver resides at <code>drivers/sensors/qencoder.c</code>.
  </li>
  <li><b>&quot;Lower Half&quot; Drivers</b>.
    Platform-specific Quadrature Encoder drivers reside in <code>arch/</code><i>&lt;architecture&gt;</i><code>/src/</code><i>&lt;chip&gt;</i> directory for the specific processor <i>&lt;architecture&gt;</i> and for the specific <i>&lt;chip&gt;</i> Quadrature Encoder peripheral devices.
  </li>
</ul>

<h3><a name="timerdriver">6.1.7 Timer Drivers</a></h3>
<p>
  NuttX supports a low-level, two-part timer driver.
</p>
<ol>
  <li>
    An &quot;upper half&quot;, generic driver that provides the common timer interface to application level code, and
  </li>
  <li>
    A &quot;lower half&quot;, platform-specific driver that implements the low-level timer controls to implement the timer functionality.
  </li>
</ol>
<p>
  Files supporting the timer driver can be found in the following locations:
</p>
<ul>
  <li><b>Interface Definition</b>.
    The header file for the NuttX timer driver reside at <code>include/nuttx/timers/timer.h</code>.
    This header file includes both the application level interface to the timer driver as well as the interface between the &quot;upper half&quot; and &quot;lower half&quot; drivers.
    The timer driver uses a standard character driver framework.
  </li>
  <li><b>&quot;Upper Half&quot; Driver</b>.
    The generic, &quot;upper half&quot; timer driver resides at <code>drivers/timers/timer.c</code>.
  </li>
  <li><b>&quot;Lower Half&quot; Drivers</b>.
    Platform-specific timer drivers reside in <code>arch/</code><i>&lt;architecture&gt;</i><code>/src/</code><i>&lt;chip&gt;</i> directory for the specific processor <i>&lt;architecture&gt;</i> and for the specific <i>&lt;chip&gt;</i> timer peripheral devices.
  </li>
</ul>

<h3><a name="rtcriver">6.1.8 RTC Drivers</a></h3>
<p>
  NuttX supports a low-level, two-part RealTime Clock (RTC) driver.
</p>
<ol>
  <li>
    An &quot;upper half&quot;, generic driver that provides the common RTC interface to application level code, and
  </li>
  <li>
    A &quot;lower half&quot;, platform-specific driver that implements the low-level timer controls to implement the RTC functionality.
  </li>
</ol>
<p>
  Files supporting the RTC driver can be found in the following locations:
</p>
<ul>
  <li><b>Interface Definition</b>.
    The header file for the NuttX RTC driver reside at <code>include/nuttx/timers/rtc.h</code>.
    This header file includes both the application level interface to the RTC driver as well as the interface between the &quot;upper half&quot; and &quot;lower half&quot; drivers.
    The RTC driver uses a standard character driver framework.
  </li>
  <li><b>&quot;Upper Half&quot; Driver</b>.
    The generic, &quot;upper half&quot; RTC driver resides at <code>drivers/timers/rtc.c</code>.
  </li>
  <li><b>&quot;Lower Half&quot; Drivers</b>.
    Platform-specific RTC drivers reside in <code>arch/</code><i>&lt;architecture&gt;</i><code>/src/</code><i>&lt;chip&gt;</i> directory for the specific processor <i>&lt;architecture&gt;</i> and for the specific <i>&lt;chip&gt;</i> RTC peripheral devices.
  </li>
</ul>

<h3><a name="wdogdriver">6.1.9 Watchdog Timer Drivers</a></h3>
<p>
  NuttX supports a low-level, two-part watchdog timer driver.
</p>
<ol>
  <li>
    An &quot;upper half&quot;, generic driver that provides the common watchdog timer interface to application level code, and
  </li>
  <li>
    A &quot;lower half&quot;, platform-specific driver that implements the low-level timer controls to implement the watchdog timer functionality.
  </li>
</ol>
<p>
  Files supporting the watchdog timer driver can be found in the following locations:
</p>
<ul>
  <li><b>Interface Definition</b>.
    The header file for the NuttX watchdog timer driver reside at <code>include/nuttx/timers/watchdog.h</code>.
    This header file includes both the application level interface to the watchdog timer driver as well as the interface between the &quot;upper half&quot; and &quot;lower half&quot; drivers.
    The watchdog timer driver uses a standard character driver framework.
  </li>
  <li><b>&quot;Upper Half&quot; Driver</b>.
    The generic, &quot;upper half&quot; watchdog timer driver resides at <code>drivers/timers/watchdog.c</code>.
  </li>
  <li><b>&quot;Lower Half&quot; Drivers</b>.
    Platform-specific watchdog timer drivers reside in <code>arch/</code><i>&lt;architecture&gt;</i><code>/src/</code><i>&lt;chip&gt;</i> directory for the specific processor <i>&lt;architecture&gt;</i> and for the specific <i>&lt;chip&gt;</i> watchdog timer peripheral devices.
  </li>
</ul>

<h3><a name="kbddriver">6.1.10 Keyboard/Keypad Drivers</a></h3>
<p>
  <b>Keypads vs. Keyboards</b>
  Keyboards and keypads are really the same devices for NuttX.
  A keypad is thought of as simply a keyboard with fewer keys.
</p>
<p>
  <b>Special Commands</b>.
  In NuttX, a keyboard/keypad driver is simply a character driver that may have an (optional) encoding/decoding layer on the data returned by the character driver.
  A keyboard may return simple text data (alphabetic, numeric, and punctuation) or control characters (enter,  control-C, etc.) when a key is pressed.
  We can think about this the &quot;normal&quot; keyboard data stream.
  However, in addition, most keyboards support actions that cannot be represented as text or control data.
  Such actions include things like cursor controls (home, up arrow, page down, etc.), editing functions (insert, delete, etc.), volume controls, (mute, volume up, etc.) and other special functions.
  In this case, some special encoding may be required to multiplex the normal text data and special command key press data streams.
</p>
<p>
  <b>Key Press and Release Events</b>
  Sometimes the time that a key is released is needed by applications as well.
  Thus, in addition to normal and special key press events, it may also be necessary to encode normal and special key release events.
</p>
<p>
  <b>Encoding/Decoding</b> Layer</b>.
  An optional encoding/decoding layer can be used with the basic character driver to encode the keyboard events into the text data stream.
  The function interfaces that comprise that encoding/decoding layer are defined in the header file <code>include/nuttx/input/kbd_code.h</code>.
  These functions provide an matched set of (a) driver encoding interfaces, and (b) application decoding interfaces.
</p>
<ol>
  <li>
    <p>
      <b>Driver Encoding Interfaces</b>.
      These are interfaces used by the keyboard/keypad driver to encode keyboard events and data.
    </p>
    <ul>
      <li>
        <p>
          <b><code>kbd_press()</code></b>
        </p>
        <p><b>Function Prototype:</b></p>
          <ul><pre>
#include &lt;nuttx/streams.h&gt;
#include &lt;nuttx/input/kbd_codec.h&gt;
void kbd_press(int ch, FAR struct lib_outstream_s *stream);
</pre></ul>
        <p><b>Description:</b></p>
        <ul>
          Indicates a normal key press event.
          Put one byte of normal keyboard  data into the output stream.
        </ul>
        <p><b>Input Parameters:</b></p>
        <ul>
          <li>
            <code>ch</code>:  The character to be added to the output stream.
          </li>
          <li>
            <code>stream</code>:  An instance of <code>lib_outstream_s</code> to perform the actual low-level put operation.
          </li>
        </ul>
        <p><b>Returned Value:</b></p>
        <ul>
          None.
        </ul>
      </li>
      <li>
        <p>
          <b><code>kbd_release()</code></b>
        </p>
        <p><b>Function Prototype:</b></p>
          <ul><pre>
#include &lt;nuttx/streams.h&gt;
#include &lt;nuttx/input/kbd_codec.h&gt;
void kbd_release(uint8_t ch, FAR struct lib_outstream_s *stream);
</pre></ul>
        <p><b>Description:</b></p>
        <ul>
          Encode the release of a normal key.
        </ul>
        <p><b>Input Parameters:</b></p>
        <ul>
          <li>
            <code>ch</code>:  The character associated with the key that was released.
          </li>
          <li>
            <code>stream</code>:  An instance of <code>lib_outstream_s</code> to perform the actual low-level put operation.
          </li>
        </ul>
        <p><b>Returned Value:</b></p>
        <ul>
          None.
        </ul>
      </li>
      <li>
        <p>
          <b><code>kbd_specpress()</code></b>
        </p>
        <p><b>Function Prototype:</b></p>
          <ul><pre>
#include &lt;nuttx/streams.h&gt;
#include &lt;nuttx/input/kbd_codec.h&gt;
void kbd_specpress(enum kbd_keycode_e keycode, FAR struct lib_outstream_s *stream);
</pre></ul>
        <p><b>Description:</b></p>
        <ul>
           Denotes a special key press event.
           Put one special keyboard command into the output stream.
         </ul>
        <p><b>Input Parameters:</b></p>
        <ul>
          <li>
            <code>keycode</code>:  The command to be added to the output stream.
            The enumeration <code>enum kbd_keycode_e keycode</code> identifies all commands known to the system.
          </li>
          <li>
            <code>stream</code>:  An instance of <code>lib_outstream_s</code> to perform the actual low-level put operation.
          </li>
        </ul>
        <p><b>Returned Value:</b></p>
        <ul>
          None.
        </ul>
      </li>
      <li>
        <p>
          <b><code>kbd_specrel()</code></b>
        </p>
        <p><b>Function Prototype:</b></p>
          <ul><pre>
#include &lt;nuttx/streams.h&gt;
#include &lt;nuttx/input/kbd_codec.h&gt;
void kbd_specrel(enum kbd_keycode_e keycode, FAR struct lib_outstream_s *stream);
</pre></ul>
        <p><b>Description:</b></p>
        <ul>
           Denotes a special key release event.
           Put one special keyboard command into the output stream.
         </ul>
        <p><b>Input Parameters:</b></p>
        <ul>
          <li>
            <code>keycode</code>:  The command to be added to the output stream.
            The enumeration <code>enum kbd_keycode_e keycode</code> identifies all commands known to the system.
          </li>
          <li>
            <code>stream</code>:  An instance of <code>lib_outstream_s</code> to perform the actual low-level put operation.
          </li>
        </ul>
        <p><b>Returned Value:</b></p>
        <ul>
          None.
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>
      <b>Application Decoding Interfaces</b>.
      These are user interfaces to decode the values returned by the keyboard/keypad driver.
    </p>
    <ul>
      <li>
        <p>
          <b><code>kbd_decode()</code></b>
        </p>
        <p><b>Function Prototype:</b></p>
          <ul><pre>
#include &lt;nuttx/streams.h&gt;
#include &lt;nuttx/input/kbd_codec.h&gt;
int kbd_decode(FAR struct lib_instream_s *stream, FAR struct kbd_getstate_s *state, FAR uint8_t *pch);
</pre></ul>
        <p><b>Description:</b></p>
        <ul>
           Get one byte of data or special command from the driver provided input buffer.
        </ul>
        <p><b>Input Parameters:</b></p>
        <ul>
          <li>
            <code>stream</code>:  An instance of <code>lib_instream_s</code> to perform the actual low-level get operation.
          </li>
          <li>
            <code>pch</code>:  The location to save the returned value.
            This may be either a normal, character code or a special command (i.e., a value from <code>enum kbd_getstate_s</code>.
          </li>
          <li>
            <code>state</code>:  A user provided buffer to support parsing.
            This structure should be cleared the first time that <code>kbd_decode()</code> is called.
          </li>
        </ul>
        <p><b>Returned Value:</b></p>
        <ul>
          <li>
            <b><code>KBD_PRESS</code> (0)</b>:
            Indicates the successful receipt of normal, keyboard data.
            This corresponds to a keypress event.
            The returned value in <code>pch</code> is a simple byte of text or control data.
          </li>
          <li>
            <b><code>KBD_RELEASE</code> (1)</b>:
            Indicates a key release event.
            The returned value in <code>pch</code> is the byte of text or control data corresponding to the released key.
          </li>
          <li>
            <b><code>KBD_SPECPRESS</code> (2)</b>:
             Indicates the successful receipt of a special keyboard command.
             The returned value in <code>pch</code> is a value from <code>enum kbd_getstate_s</code>.
          </li>
          <li>
            <b><code>KBD_SPECREL</code> (3)</b>:
            Indicates a special command key release event.
             The returned value in <code>pch</code> is a value from <code>enum kbd_getstate_s</code>.
          </li>
          <li>
            <b><code>KBD_ERROR</code> (<code>EOF</code>)</b>:
            An error has getting the next character (reported by the <code>stream</code>).
            Normally indicates the end of file.
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ol>
<p>
  <b>I/O Streams</b>.
  Notice the use of the abstract I/O streams in these interfaces.
  These stream interfaces are defined in <code>include/nuttx/streams.h</code>.
</p>

<h2><a name="blockdrivers">6.2 Block Device Drivers</a></h2>

<p>
  Block device drivers have these properties:
</p>
<ul>
  <li>
    <p>
    <b><code>include/nuttx/fs/fs.h</code></b>.
    All structures and APIs needed to work with block drivers are provided in this header file.
    </p>
  </li>
  <li>
    <p>
    <b><code>struct block_operations</code></b>.
    Each block device driver must implement an instance of <code>struct block_operations</code>.
    That structure defines a call table with the following methods:
    <ul>
     <p><code>int open(FAR struct inode *inode);</code><br>
     <code>int close(FAR struct inode *inode);</code><br>
     <code>ssize_t read(FAR struct inode *inode, FAR unsigned char *buffer, size_t start_sector, unsigned int nsectors);</code><br>
     <code>ssize_t write(FAR struct inode *inode, FAR const unsigned char *buffer, size_t start_sector, unsigned int nsectors);</code><br>
     <code>int geometry(FAR struct inode *inode, FAR struct geometry *geometry);</code><br>
     <code>int ioctl(FAR struct inode *inode, int cmd, unsigned long arg);</code></p>
    </ul>
    </p>
  </li>
  <li>
    <p>
    <b><code>int register_blockdriver(const char *path, const struct block_operations *bops, mode_t mode, void *priv);</code></b>.
    Each block driver registers itself by calling <code>register_blockdriver()</code>, passing it the
    <code>path</code> where it will appear in the <a href="#NxFileSystem">pseudo-file-system</a> and it's
    initialized instance of <code>struct block_operations</code>.
    </p>
  </li>
  <li>
    <p>
    <b>User Access</b>.
    Users do not normally access block drivers directly, rather, they access block drivers
    indirectly through the <code>mount()</code> API.
    The <code>mount()</code> API binds a block driver instance with a file system and with a mountpoint.
    Then the user may use the block driver to access the file system on the underlying media.
    <i>Example</i>: See the <code>cmd_mount()</code> implementation in <code>apps/nshlib/nsh_fscmds.c</code>.
    </p>
  </li>
  <li>
    <p>
    <b>Accessing a Character Driver as a Block Device</b>.
    See the loop device at <code>drivers/loop.c</code>.
    <i>Example</i>: See the <code>cmd_losetup()</code> implementation in <code>apps/nshlib/nsh_fscmds.c</code>.
    </p>
  </li>
  <li>
    <p>
    <b>Accessing a Block Driver as Character Device</b>.
    See the Block-to-Character (BCH) conversion logic in <code>drivers/bch/</code>.
    <i>Example</i>: See the <code>cmd_dd()</code> implementation in <code>apps/nshlib/nsh_ddcmd.c</code>.
    </p>
  </li>
  <li>
    <p>
    <b>Examples</b>.
    <code>drivers/loop.c</code>, <code>drivers/mmcsd/mmcsd_spi.c</code>, <code>drivers/ramdisk.c</code>, etc.
    </p>
  </li>
</ul>

<h2><a name="specdrivers">6.3 Specialized Device Drivers</a></h2>

<p>
  All device drivers that are accessible to application logic are either:  (1) Character device drivers that can be accessed via the standard driver operations (<code>open()</code>, <code>close()</code>, <code>read()</code>, <code>write()</code>, etc.), or (2) block drivers that can be accessing only as part of mounting a file system or other special use cases as described in the preceding paragraph.
</p>
<p>
  In addition to this, there are also specialized &quot;drivers&quot; that can be used only within the OS logic itself and are not accessible to application logic.  These specialized drivers are discussed in the following paragraphs.
</p>

<h3><a name="ethdrivers">6.3.1 Ethernet Device Drivers</a></h3>

<ul>
  <li>
    <p>
    <b><code>include/nuttx/net/netdev.h</code></b>.
    All structures and APIs needed to work with Ethernet drivers are provided in this header file.
    The structure <code>struct net_driver_s</code> defines the interface and is passed to uIP via
    <code>netdev_register()</code>.
    </p>
  </li>
  <li>
    <p>
    <b><code>int netdev_register(FAR struct net_driver_s *dev, enum net_lltype_e lltype);</code></b>.
    Each Ethernet driver registers itself by calling <code>netdev_register()</code>.
    </p>
  </li>
  <li>
    <p>
    <b>Examples</b>:
    <code>drivers/net/dm90x0.c</code>, <code>arch/drivers/arm/src/c5471/c5471_ethernet.c</code>, <code>arch/z80/src/ez80/ez80_emac.c</code>, etc.
    </p>
  </li>
</ul>

<h3><a name="spidrivers">6.3.2 SPI Device Drivers</a></h3>

<ul>
  <li>
    <p>
    <b><code>include/nuttx/spi/spi.h</code></b>.
    All structures and APIs needed to work with SPI drivers are provided in this header file.
    </p>
  </li>
  <li>
    <p>
    <b><code>struct spi_ops_s</code></b>.
    Each SPI device driver must implement an instance of <code>struct spi_ops_s</code>.
    That structure defines a call table with the following methods:
    <ul>
     <p><code>void lock(FAR struct spi_dev_s *dev);</code></p>
     <p><code>void select(FAR struct spi_dev_s *dev, enum spi_dev_e devid, bool selected);</code><br>
     <code>uint32_t setfrequency(FAR struct spi_dev_s *dev, uint32_t frequency);</code><br>
     <code>void setmode(FAR struct spi_dev_s *dev, enum spi_mode_e mode);</code><br>
     <code>void setbits(FAR struct spi_dev_s *dev, int nbits);</code><br>
     <code>uint8_t status(FAR struct spi_dev_s *dev, enum spi_dev_e devid);</code><br>
     <code>uint16_t send(FAR struct spi_dev_s *dev, uint16_t wd);</code><br>
     <code>void exchange(FAR struct spi_dev_s *dev, FAR const void *txbuffer, FAR void *rxbuffer, size_t nwords);</code><br>
     <p><code>int registercallback(FAR struct spi_dev_s *dev, mediachange_t callback, void *arg);</code></p>
    </ul>
    </p>
  <li>
    <p>
      <b>Binding SPI Drivers</b>.
      SPI drivers are not normally directly accessed by user code, but are usually bound to another,
      higher level device driver.
      See for example, <code>int mmcsd_spislotinitialize(int minor, int slotno, FAR struct spi_dev_s *spi)</code> in <code>drivers/mmcsd/mmcsd_spi.c</code>.
      In general, the binding sequence is:
    </p>
    <p>
      <ol>
        <li>Get an instance of <code>struct spi_dev_s</code> from the hardware-specific SPI device driver, and </li>
        <li>Provide that instance to the initialization method of the higher level device driver.</li>
      </ol>
    </p>
  </li>
  <li>
    <p>
      <b>Examples</b>:
      <code>drivers/loop.c</code>, <code>drivers/mmcsd/mmcsd_spi.c</code>, <code>drivers/ramdisk.c</code>, etc.
    </p>
  </li>
</ul>

<h3><a name="i2cdrivers">6.3.3 I2C Device Drivers</a></h3>

<ul>
  <li>
    <p>
    <b><code>include/nuttx/i2c/i2c.h</code></b>.
    All structures and APIs needed to work with I2C drivers are provided in this header file.
    </p>
  </li>
  <li>
    <p>
    <b><code>struct i2c_ops_s</code></b>.
    Each I2C device driver must implement an instance of <code>struct i2c_ops_s</code>.
    That structure defines a call table with the following methods:
    <ul>
     <p><code>uint32_t setfrequency(FAR struct i2c_dev_s *dev, uint32_t frequency);</code><br>
     <code>int setaddress(FAR struct i2c_dev_s *dev, int addr, int nbits);</code><br>
     <code>int write(FAR struct i2c_dev_s *dev, const uint8_t *buffer, int buflen);</code><br>
     <code>int read(FAR struct i2c_dev_s *dev, uint8_t *buffer, int buflen);</code></p>
    </p>
  </ul>
  <li>
    <p>
      <b>Binding I2C Drivers</b>.
      I2C drivers are not normally directly accessed by user code, but are usually bound to another,
      higher level device driver.
      In general, the binding sequence is:
    </p>
    <p>
      <ol>
        <li>Get an instance of <code>struct i2c_dev_s</code> from the hardware-specific I2C device driver, and </li>
        <li>Provide that instance to the initialization method of the higher level device driver.</li>
      </ol>
    </p>
  </li>
  <li>
    <p>
      <b>Examples</b>:
      <code>arch/z80/src/ez80/ez80_i2c.c</code>, <code>arch/z80/src/z8/z8_i2c.c</code>, etc.
    </p>
  </li>
</ul>

<h3><a name="fbdrivers">6.3.4 Frame Buffer Drivers</a></h3>

<ul>
  <li>
    <p>
      <b><code>include/nuttx/video/fb.h</code></b>.
      All structures and APIs needed to work with frame buffer drivers are provided in this header file.
    </p>
  </li>
  <li>
    <p>
      <b><code>struct fb_vtable_s</code></b>.
      Each frame buffer device driver must implement an instance of <code>struct fb_vtable_s</code>.
      That structure defines a call table with the following methods:
    </p>
    <p>
      Get information about the video controller configuration and the configuration of each color plane.
    </p>
    <ul>
     <p><code>int (*getvideoinfo)(FAR struct fb_vtable_s *vtable, FAR struct fb_videoinfo_s *vinfo);</code><br>
     <code>int (*getplaneinfo)(FAR struct fb_vtable_s *vtable, int planeno, FAR struct fb_planeinfo_s *pinfo);</code></p>
    </ul>
    <p>
      The following are provided only if the video hardware supports RGB color mapping:
    </p>
    <ul>
     <p><code>int (*getcmap)(FAR struct fb_vtable_s *vtable, FAR struct fb_cmap_s *cmap);</code><br>
     <code>int (*putcmap)(FAR struct fb_vtable_s *vtable, FAR const struct fb_cmap_s *cmap);</code></p>
    </ul>
    <p>
      The following are provided only if the video hardware supports a hardware cursor:
    </p>
    <ul>
     <p><code>int (*getcursor)(FAR struct fb_vtable_s *vtable, FAR struct fb_cursorattrib_s *attrib);</code><br>
     <code>int (*setcursor)(FAR struct fb_vtable_s *vtable, FAR struct fb_setcursor_s *settings);</code></p>
    </ul>
  </li>
  <li>
    <p>
      <b>Binding Frame Buffer Drivers</b>.
      Frame buffer drivers are not normally directly accessed by user code, but are usually bound to another,
      higher level device driver.
      In general, the binding sequence is:
    </p>
    <p>
      <ol>
        <li>Get an instance of <code>struct fb_vtable_s</code> from the hardware-specific frame buffer device driver, and </li>
        <li>Provide that instance to the initialization method of the higher level device driver.</li>
      </ol>
    </p>
  </li>
  <li>
    <p>
      <b>Examples</b>:
      <code>arch/sim/src/up_framebuffer.c</code>.
      See also the usage of the frame buffer driver in the <code>graphics/</code> directory.
    </p>
  </li>
</ul>

<h3><a name="lcddrivers">6.3.5 LCD Drivers</a></h3>

<ul>
  <li>
    <p>
      <b><code>include/nuttx/lcd/lcd.h</code></b>.
      Structures and APIs needed to work with LCD drivers are provided in this header file.
      This header file also depends on some of the same definitions used for the frame buffer driver as provided in <code>include/nuttx/video/fb.h</code>.
    </p>
  </li>
  <li>
    <p>
      <b><code>struct lcd_dev_s</code></b>.
      Each LCD device driver must implement an instance of <code>struct lcd_dev_s</code>.
      That structure defines a call table with the following methods:
    </p>
    <p>
      Get information about the LCD video controller configuration and the configuration of each LCD color plane.
    </p>
    <ul>
    <p>
       <code>int (*getvideoinfo)(FAR struct lcd_dev_s *dev, FAR struct fb_videoinfo_s *vinfo);</code><br>
       <code>int (*getplaneinfo)(FAR struct lcd_dev_s *dev, unsigned int planeno, FAR struct lcd_planeinfo_s *pinfo);</code>
     </p>
    </ul>
    <p>
      The following are provided only if the video hardware supports RGB color mapping:
    </p>
    <ul>
     <p>
       <code>int (*getcmap)(FAR struct lcd_dev_s *dev, FAR struct fb_cmap_s *cmap);</code><br>
       <code>int (*putcmap)(FAR struct lcd_dev_s *dev, FAR const struct fb_cmap_s *cmap);</code>
     </p>
    </ul>
    <p>
      The following are provided only if the video hardware supports a hardware cursor:
    </p>
    <ul>
     <p>
       <code>int (*getcursor)(FAR struct lcd_dev_s *dev, FAR struct fb_cursorattrib_s *attrib);</code><br>
       <code>int (*setcursor)(FAR struct lcd_dev_s *dev, FAR struct fb_setcursor_s *settings)</code>
     </p>
    </ul>
    <p>
      Get the LCD panel power status (0: full off - <code>CONFIG_LCD_MAXPOWER</code>: full on).
      On backlit LCDs, this setting may correspond to the backlight setting.
    </p>
    <ul>
     <p>
       <code>int (*getpower)(struct lcd_dev_s *dev);</code>
     </p>
    </ul>
    <p>
      Enable/disable LCD panel power (0: full off - <code>CONFIG_LCD_MAXPOWER</code>: full on).
      On backlit LCDs, this setting may correspond to the backlight setting.
    </p>
    <ul>
     <p>
       <code>int (*setpower)(struct lcd_dev_s *dev, int power);</code>
     </p>
    </ul>
    <p>
      Get the current contrast setting (0-CONFIG_LCD_MAXCONTRAST) */
    </p>
    <ul>
     <p>
       <code>int (*getcontrast)(struct lcd_dev_s *dev);</code>
     </p>
    </ul>
    <p>
      Set LCD panel contrast (0-CONFIG_LCD_MAXCONTRAST)
    </p>
    <ul>
     <p>
       <code>int (*setcontrast)(struct lcd_dev_s *dev, unsigned int contrast);</code>
     </p>
    </ul>
  </p>
  <li>
    <p>
      <b>Binding LCD Drivers</b>.
      LCD drivers are not normally directly accessed by user code, but are usually bound to another,
      higher level device driver.
      In general, the binding sequence is:
    </p>
    <p>
      <ol>
        <li>Get an instance of <code>struct lcd_dev_s</code> from the hardware-specific LCD device driver, and </li>
        <li>Provide that instance to the initialization method of the higher level device driver.</li>
      </ol>
    </p>
  </li>
  <li>
    <p>
      <b>Examples</b>:
      <code>drivers/lcd/nokia6100.c</code>, <code>drivers/lcd/p14201.c</code>, <code>configs/sam3u-ek/src/up_lcd.c.</code>
      See also the usage of the LCD driver in the <code>graphics/</code> directory.
    </p>
  </li>
</ul>

<h3><a name="mtddrivers">6.3.6 Memory Technology Device Drivers</a></h3>

<ul>
  <li>
    <p>
      <b><code>include/nuttx/mtd/mtd.h</code></b>.
      All structures and APIs needed to work with MTD drivers are provided in this header file.
    </p>
  </li>
  <li>
    <p>
      <b><code>struct mtd_dev_s</code></b>.
      Each MTD device driver must implement an instance of <code>struct mtd_dev_s</code>.
      That structure defines a call table with the following methods:
    </p>
    <p>
      Erase the specified erase blocks (units are erase blocks):
    </p>
    <ul>
     <p><code>int (*erase)(FAR struct mtd_dev_s *dev, off_t startblock, size_t nblocks);</code></p>
    </ul>
    <p>
      Read/write from the specified read/write blocks:
    </p>
    <ul>
     <p><code>ssize_t (*bread)(FAR struct mtd_dev_s *dev, off_t startblock, size_t nblocks, FAR uint8_t *buffer);</code><br>
     <code>ssize_t (*bwrite)(FAR struct mtd_dev_s *dev, off_t startblock, size_t nblocks, FAR const uint8_t *buffer);</code></p>
    </ul>
    <p>
      Some devices may support byte oriented reads (optional).
      Most MTD devices are inherently block oriented so byte-oriented accesses are not supported.
      It is recommended that low-level drivers not support read() if it requires buffering.
    </p>
    <ul>
     <p><code>ssize_t (*read)(FAR struct mtd_dev_s *dev, off_t offset, size_t nbytes, FAR uint8_t *buffer);</code></p>
    </ul>
    <p>
      Some devices may also support byte oriented writes (optional).
      Most MTD devices are inherently block oriented so byte-oriented accesses are not supported.
      It is recommended that low-level drivers not support read() if it requires buffering.
      This interface is only available if <code>CONFIG_MTD_BYTE_WRITE</code> is defined.
    </p>
    <ul>
     <p><code>ssize_t (*write)(FAR struct mtd_dev_s *dev, off_t offset, size_t nbytes, FAR const uint8_t *buffer);</code></p>
    </ul>
    <p>
      Support other, less frequently used commands:
    </p>
    <ul>
      <li><code>MTDIOC_GEOMETRY</code>:  Get MTD geometry</li>
      <li><code>MTDIOC_XIPBASE:</code>: Convert block to physical address for eXecute-In-Place</li>
      <li><code>MTDIOC_BULKERASE</code>: Erase the entire device</li>
    </ul>
    <p>
      is provided via a single <code>ioctl</code> method (see <code>include/nuttx/fs/ioctl.h</code>):
    </p>
    <ul>
     <p><code>int (*ioctl)(FAR struct mtd_dev_s *dev, int cmd, unsigned long arg);</code></p>
    </ul>
  </li>
  <li>
    <p>
      <b>Binding MTD Drivers</b>.
      MTD drivers are not normally directly accessed by user code, but are usually bound to another,
      higher level device driver.
      In general, the binding sequence is:
    </p>
    <p>
      <ol>
        <li>Get an instance of <code>struct mtd_dev_s</code> from the hardware-specific MTD device driver, and </li>
        <li>Provide that instance to the initialization method of the higher level device driver.</li>
      </ol>
    </p>
  </li>
  <li>
    <p>
      <b>Examples</b>:
      <code>drivers/mtd/m25px.c</code> and <code>drivers/mtd/ftl.c</code>
    </p>
  </li>
</ul>

<h3><a name="sdiodrivers">6.3.7 SDIO Device Drivers</a></h3>

<ul>
  <li>
    <p>
      <b><code>include/nuttx/sdio.h</code></b>.
      All structures and APIs needed to work with SDIO drivers are provided in this header file.
    </p>
  </li>
  <li>
    <p>
      <b><code>struct sdio_dev_s</code></b>.
      Each SDIO device driver must implement an instance of <code>struct sdio_dev_s</code>.
      That structure defines a call table with the following methods:
    </p>
    <p>
      Mutual exclusion:
    </p>
    <ul>
      <p>
        <code>#ifdef CONFIG_SDIO_MUXBUS</code><br>
        <code>  int (*lock)(FAR struct sdio_dev_s *dev, bool lock);</code><br>
        <code>#endif</code>
      </p>
    </ul>
    <p>
      Initialization/setup:
    </p>
    <ul>
     <p><code>void (*reset)(FAR struct sdio_dev_s *dev);</code><br>
     <code>uint8_t (*status)(FAR struct sdio_dev_s *dev);</code><br>
     <code>void (*widebus)(FAR struct sdio_dev_s *dev, bool enable);</code><br>
     <code>void (*clock)(FAR struct sdio_dev_s *dev, enum sdio_clock_e rate);</code><br>
     <code>int (*attach)(FAR struct sdio_dev_s *dev);</code><br>
    </ul>
    <p>
      Command/Status/Data Transfer:
    </p>
    <ul>
     <p><code>int (*sendcmd)(FAR struct sdio_dev_s *dev, uint32_t cmd, uint32_t arg);</code><br>
     <code>int (*recvsetup)(FAR struct sdio_dev_s *dev, FAR uint8_t *buffer, size_t nbytes);</code><br>
     <code>int (*sendsetup)(FAR struct sdio_dev_s *dev, FAR const uint8_t *buffer, size_t nbytes);</code><br>
     <code>int (*cancel)(FAR struct sdio_dev_s *dev);</code><br>
     <code>int (*waitresponse)(FAR struct sdio_dev_s *dev, uint32_t cmd);</code><br>
     <code>int (*recvR1)(FAR struct sdio_dev_s *dev, uint32_t cmd, uint32_t *R1);</code><br>
     <code>int (*recvR2)(FAR struct sdio_dev_s *dev, uint32_t cmd, uint32_t R2[4]);</code><br>
     <code>int (*recvR3)(FAR struct sdio_dev_s *dev, uint32_t cmd, uint32_t *R3);</code><br>
     <code>int (*recvR4)(FAR struct sdio_dev_s *dev, uint32_t cmd, uint32_t *R4);</code><br>
     <code>int (*recvR5)(FAR struct sdio_dev_s *dev, uint32_t cmd, uint32_t *R5);</code><br>
     <code>int (*recvR6)(FAR struct sdio_dev_s *dev, uint32_t cmd, uint32_t *R6);</code><br>
     <code>int (*recvR7)(FAR struct sdio_dev_s *dev, uint32_t cmd, uint32_t *R7);</code></p>
    </ul>
    <p>
      Event/Callback support:
    </p>
    <ul>
     <p><code>void (*waitenable)(FAR struct sdio_dev_s *dev, sdio_eventset_t eventset);</code><br>
     <code>sdio_eventset_t (*eventwait)(FAR struct sdio_dev_s *dev, uint32_t timeout);</code><br>
     <code>void (*callbackenable)(FAR struct sdio_dev_s *dev, sdio_eventset_t eventset);</code><br>
     <code>int (*registercallback)(FAR struct sdio_dev_s *dev, worker_t callback, void *arg);</code></p>
    </ul>
    <p>
      DMA support:
    </p>
    <ul>
     <p><code>bool (*dmasupported)(FAR struct sdio_dev_s *dev);</code><br>
     <code>int (*dmarecvsetup)(FAR struct sdio_dev_s *dev, FAR uint8_t *buffer, size_t buflen);</code><br>
     <code>int (*dmasendsetup)(FAR struct sdio_dev_s *dev, FAR const uint8_t *buffer,  size_t buflen);</code></p>
    </ul>
  </li>
  <li>
    <p>
      <b>Binding SDIO Drivers</b>.
      SDIO drivers are not normally directly accessed by user code, but are usually bound to another,
      higher level device driver.
      In general, the binding sequence is:
    </p>
    <p>
      <ol>
        <li>Get an instance of <code>struct sdio_dev_s</code> from the hardware-specific SDIO device driver, and </li>
        <li>Provide that instance to the initialization method of the higher level device driver.</li>
      </ol>
    </p>
  </li>
  <li>
    <p>
      <b>Examples</b>:
      <code>arch/arm/src/stm32/stm32_sdio.c</code> and <code>drivers/mmcsd/mmcsd_sdio.c</code>
    </p>
  </li>
</ul>

<h3><a name="usbhostdrivers">6.3.8 USB Host-Side Drivers</a></h3>

<ul>
  <li>
    <p>
      <b><code>include/nuttx/usb/usbhost.h</code></b>.
      All structures and APIs needed to work with USB host-side drivers are provided in this header file.
    </p>
  </li>
  <li>
    <p>
      <b><code>struct usbhost_driver_s</code> and <code>struct usbhost_connection_s</code></b>.
      Each USB host controller driver must implement an instance of <code>struct usbhost_driver_s</code> and <code>struct usbhost_connection_s</code>:
      <code>struct usbhost_driver_s</code> provides the interface between the USB host driver and the USB class driver;
      <code>struct usbhost_connection_s</code> provides the interface between the USB host driver and platform-specific connection management and device enumeration logic.
      These structures are defined in <code>include/nuttx/usb/usbhost.h</code>.
    </p>
    <p>
      <b>Examples</b>:
      <code>arch/arm/src/lpc17xx/lpc17_usbhost.c</code>,
      <code>arch/arm/src/stm32/stm32_otgfshost.c</code>,
      <code>arch/arm/src/sama5/sam_ohci.c</code>, and
      <code>arch/arm/src/sama5/sam_ehci.c</code>.
    </p>
  </li>
  <li>
    <p>
      <b><code>struct usbhost_class_s</code></b>.
      Each USB host class driver must implement an instance of <code>struct usbhost_class_s</code>.
      This structure is also defined in <code>include/nuttx/usb/usbhost.h</code>.
    </p>
    <p>
      <b>Examples</b>:
      <code>drivers/usbhost/usbhost_storage.c</code>
    </p>
  </li>
  <li>
    <p>
      <b>USB Host Class Driver Registry</b>.
      The NuttX USB host infrastructure includes a <i>registry</i>.
      During its initialization, each USB host class driver must call the interface, <code>usbhost_registerclass()</code>
      in order add its interface to the registry.
      Later, when a USB device is connected, the USB host controller will look up the USB host class driver that is needed to support the connected device in this registry.
    </p>
    <p>
      <b>Examples</b>:
      <code>drivers/usbhost/usbhost_registry.c</code>, <code>drivers/usbhost/usbhost_registerclass.c</code>, and <code>drivers/usbhost/usbhost_findclass.c</code>,
    </p>
  </li>
  <li>
    <p>
      <b>Detection and Enumeration of Connected Devices</b>.
      Each USB host device controller supports two methods that are used to detect and enumeration newly connected devices
      (and also detect disconnected devices):
    </p>
    <p>
      <ul>
        <li>
          <p>
            <code>int (*wait)(FAR struct usbhost_connection_s *drvr, FAR const bool *connected);</code>
          </p>
          <p>
            Wait for a device to be connected or disconnected.
          </p>
        </li>
        <li>
          <p>
            <code>int (*enumerate)(FAR struct usbhost_connection_s *drvr, int rhpndx);</code>
          </p>
          <p>
            Enumerate the device connected to a root hub port.
            As part of this enumeration process, the driver will
            (1) get the device's configuration descriptor,
            (2) extract the class ID info from the configuration descriptor,
            (3) call <code>usbhost_findclass(</code>) to find the class that supports this device,
            (4) call the <code>create()</code> method on the <code>struct usbhost_registry_s interface</code> to get a class instance, and
            finally (5) call the <code>connect()</code> method of the <code>struct usbhost_class_s</code> interface.
            After that, the class is in charge of the sequence of operations.
          </p>
      </ul>
    </p>
  </li>
  <li>
    <p>
      <b>Binding USB Host-Side Drivers</b>.
      USB host-side controller drivers are not normally directly accessed by user code,
      but are usually bound to another, higher level USB host class driver.
      The class driver exports the standard NuttX device interface so that the connected USB device can be accessed just as with other, similar, on-board devices.
      For example, the USB host mass storage class driver (<code>drivers/usbhost/usbhost_storage.c</code>) will register a standard, NuttX block driver interface (like <code>/dev/sda</code>)
      that can be used to mount a file system just as with any other other block driver instance.
      In general, the binding sequence is:
    </p>
    <p>
      <ol>
        <li>
          <p>
            Each USB host class driver includes an initialization entry point that is called from the
            application at initialization time.
            This driver calls <code>usbhost_registerclass()</code> during this initialization in order to makes itself available in the event the device that it supports is connected.
          </p>
          <p>
            <b>Examples</b>:
            The function <code>usbhost_msc_initialize()</code> in the file <code>drivers/usbhost/usbhost_storage.c</code>
          </p>
        </li>
        <li>
          <p>
            Each application must include a <i>waiter</i> thread thread that (1) calls the USB host controller driver's <code>wait()</code> to detect the connection of a device, and then
            (2) call the USB host controller driver's <code>enumerate</code> method to bind the registered USB host class driver to the USB host controller driver.
          </p>
          <p>
            <b>Examples</b>:
            The function <code>nsh_waiter()</code> in the file <code>configs/nucleus2g/src/up_nsh.c</code> and
            the function <code>nsh_waiter()</code> in the file <code>configs/olimex-lpc1766stk/src/up_nsh.c</code>.
          </p>
        </li>
        <li>
          <p>
            As part of its operation during the binding operation, the USB host class driver will register an instances of a standard NuttX driver under the <code>/dev</code> directory.
            To repeat the above example, the USB host mass storage class driver (<code>drivers/usbhost/usbhost_storage.c</code>) will register a standard, NuttX block driver interface (like <code>/dev/sda</code>)
            that can be used to mount a file system just as with any other other block driver instance.
          </p>
          <p>
            <b>Examples</b>:
            See the call to <code>register_blockdriver()</code> in the function <code>usbhost_initvolume()</code> in the file <code>drivers/usbhost/usbhost_storage.c</code>.
          </p>
        </li>
      </ol>
    </p>
  </li>
</ul>

<h3><a name="usbdevdrivers">6.3.9 USB Device-Side Drivers</a></h3>

<ul>
  <li>
    <p>
      <b><code>include/nuttx/usb/usbdev.h</code></b>.
      All structures and APIs needed to work with USB device-side drivers are provided in this header file.
    </p>
  </li>
  <li>
    <p>
      <b><code>include/nuttx/usb/usbdev_trace.h</code></b>.
      Declarations needed to work with the NuttX USB device driver trace capability.
      That USB trace capability is detailed in <a href="UsbTrace.html">separate document</a>.
    </p>
  </li>
  <li>
    <p>
      <b><code>struct usbdev_s</code></b>.
      Each USB device controller driver must implement an instance of <code>struct usbdev_s</code>.
      This structure is defined in <code>include/nuttx/usb/usbdev.h</code>.
    </p>
    <p>
      <b>Examples</b>:
      <code>arch/arm/src/dm320/dm320_usbdev.c</code>, <code>arch/arm/src/lpc17xx/lpc17_usbdev.c</code>,
      <code>arch/arm/src/lpc214x/lpc214x_usbdev.c</code>, <code>arch/arm/src/lpc313x/lpc313x_usbdev.c</code>, and
       <code>arch/arm/src/stm32/stm32_usbdev.c</code>.
    </p>
  </li>
  <li>
    <p>
      <b><code>struct usbdevclass_driver_s</code></b>.
      Each USB device class driver must implement an instance of <code>struct usbdevclass_driver_s</code>.
      This structure is also defined in <code>include/nuttx/usb/usbdev.h</code>.
    </p>
    <p>
      <b>Examples</b>:
      <code>drivers/usbdev/pl2303.c</code> and <code>drivers/usbdev/usbmsc.c</code>
    </p>
  </li>
  <li>
    <p>
      <b>Binding USB Device-Side Drivers</b>.
      USB device-side controller drivers are not normally directly accessed by user code,
      but are usually bound to another, higher level USB device class driver.
      The class driver is then configured to export the USB device functionality.
      In general, the binding sequence is:
    </p>
    <p>
      <ol>
        <li>
          <p>
            Each USB device class driver includes an initialization entry point that is called from the
            application at initialization time.
          </p>
          <p>
            <b>Examples</b>:
            The function <code>usbdev_serialinitialize()</code> in the file <code>drivers/usbdev/pl2303.c</code> and
            the function <code></code> in the file <code>drivers/usbdev/usbmsc.c</code>
          </p>
        </li>
        <li>
          <p>
            These initialization functions called the driver API, <code>usbdev_register()</code>.
            This driver function will <i>bind</i> the USB class driver to the USB device controller driver,
            completing the initialization.
          </p>
        </li>
      </ol>
    </p>
  </li>
</ul>

<h2><a name="pwrmgmt">6.4 Power Management</a></h2>

<h3><a name="pmoverview">6.4.1 Overview</a></h3>
<p>
  NuttX supports a simple power management (PM) sub-system.  This sub-system:
</p>
<ul>
  <li>
    <p>
      Monitors driver activity, and
    </p>
  </li>
  <li>
    <p>
      Provides hooks to place drivers (and the whole system) into reduce power
      modes of operation.
    </p>
  </li>
</ul>
<p>
  <center><img src="pm.png"></center>
</p>
<p>
  The PM sub-system integrates the MCU idle loop with a collection of device drivers to support:
</p>
<ul>
  <li>
    <p>
      Reports of relevant driver or other system activity.
    </p>
  </li>
  <li>
    <p>
      Registration and callback mechanism to interface with individual device drivers.
    </p>
  </li>
  <li>
    <p>
      IDLE time polling of overall driver activity.
    </p>
  </li>
  <li>
    <p>
      Coordinated, global, system-wide transitions to lower power usage states.
    </p>
  </li>
</ul>
<p>
  Various &quot;sleep&quot; and low power consumption states have various names and are sometimes used in conflicting ways.
  In the NuttX PM logic, we will use the following terminology:
</p>
<dl>
  <dt><code>NORMAL</code>
  <dd>The normal, full power operating mode.
  <dt><code>IDLE</code>
  <dd>This is still basically normal operational mode, the system is,
      however, <code>IDLE</code> and some simple simple steps to reduce power
      consumption provided that they do not interfere with normal
      Operation.  Simply dimming the a backlight might be an example
      somethat that would be done when the system is idle.
  <dt><code>STANDBY</code>
  <dd>Standby is a lower power consumption mode that may involve more
      extensive power management steps such has disabling clocking or
      setting the processor into reduced power consumption modes. In
      this state, the system should still be able to resume normal
      activity almost immediately.
  <dt><code>SLEEP</code>
  <dd>The lowest power consumption mode.  The most drastic power
      reduction measures possible should be taken in this state. It
      may require some time to get back to normal operation from
      <code>SLEEP</code> (some MCUs may even require going through reset).
</dl>
<p>
  These various states are represented with type <code>enum pm_state_e</code> in <code>include/nuttx/power/pm.h</code>.
</p>

<h3><a name="pminterfaces">6.4.2 Interfaces</a></h3>
<p>
  All PM interfaces are declared in the file <code>include/nuttx/power/pm.h</code>.
</p>

<h4><a name="pminitialize">6.4.2.1 <code>pm_initialize()</code></a></h4>
<p><b>Function Prototype:</b></p>
<ul><pre>
#include &lt;nuttx/power/pm.h&gt;
void pm_initialize(void);
</pre></ul>
<p><b>Description:</b>
This function is called by MCU-specific one-time at power on reset in order to initialize the power management capabilities.
This function must be called <i>very</i> early in the initialization sequence <i>before</i> any other device drivers are initialize (since they may attempt to register with the power management subsystem).
</p>
<p><b>Input Parameters:</b>
None
</p>
<p><b>Returned Value:</b>
None
</p>

<h4><a name="pmregister">6.4.2.2 <code>pm_register()</code></a></h4>
<p><b>Function Prototype:</b></p>
<ul><pre>
#include &lt;nuttx/power/pm.h&gt;
int pm_register(FAR struct pm_callback_s *callbacks);
</pre></ul>
<p><b>Description:</b>
  This function is called by a device driver in order to register to receive power management event callbacks.
  Refer to the <a href="#pmcallbacks">PM Callback</a> section for more details.
</p>
<p><b>Input Parameters:</b>
 <dl>
   <dt><code>callbacks</code>
   <dd>An instance of <code>struct pm_callback_s</code> providing the driver callback functions.
 </dl>
</p>
<p><b>Returned Value:</b>
Zero (<code>OK</code>) on success; otherwise a negated <code>errno</code> value is returned.
</p>

<h4><a name="pmactivity">6.4.2.3 <code>pm_activity()</code></a></h4>
<p><b>Function Prototype:</b></p>
<ul><pre>
#include &lt;nuttx/power/pm.h&gt;
void pm_activity(int priority);
</pre></ul>
<p><b>Description:</b>
 This function is called by a device driver to indicate that it is performing meaningful activities (non-idle).
 This increment an activity count and/or will restart a idle timer and prevent entering reduced power states.
</p>
<p><b>Input Parameters:</b>
 <dl>
   <dt><code>priority</code>
   <dd>
     Activity priority, range 0-9.
     Larger values correspond to higher priorities.
     Higher priority activity can prevent the system from entering reduced power states for a longer period of time.
     As an example, a button press might be higher priority activity because it means that the user is actively interacting with the device.
 </dl>
</p>
<p><b>Returned Value:</b>
  None
</p>
<p><b>Assumptions:</b>
  This function may be called from an interrupt handler (this is the ONLY PM function that may be called from an interrupt handler!).
</p>

<h4><a name="pmcheckstate">6.4.2.4 <code>pm_checkstate()</code></a></h4>
<p><b>Function Prototype:</b></p>
<ul><pre>
#include &lt;nuttx/power/pm.h&gt;
enum pm_state_e pm_checkstate(void);
</pre></ul>
<p><b>Description:</b>
  This function is called from the MCU-specific IDLE loop to monitor the power management conditions.
  This function returns the &quot;recommended&quot; power management state based on the PM configuration and activity reported in the last sampling periods.
  The power management state is not automatically changed, however.
  The IDLE loop must call <code>pm_changestate()</code> in order to make the state change.
</p>
<p>
  These two steps are separated because the platform-specific IDLE loop may have additional situational information that is not available to the PM sub-system.
  For example, the IDLE loop may know that the battery charge level is very low and may force lower power states even if there is activity.
</p>
<p>
  NOTE: That these two steps are separated in time and, hence, the IDLE loop could be suspended for a long period of time between calling <code>pm_checkstate()</code> and <code>pm_changestate()</code>.
  The IDLE loop may need to make these calls atomic by either disabling interrupts until the state change is completed.
</p>
<p><b>Input Parameters:</b>
  None
</p>
<p><b>Returned Value:</b>
  The recommended power management state.
</p>

<h4><a name="pmchangestate">6.4.2.5 <code>pm_changestate()</code></a></h4>
<p><b>Function Prototype:</b></p>
<ul><pre>
#include &lt;nuttx/power/pm.h&gt;
 int pm_changestate(enum pm_state_e newstate);
</pre></ul>
<p><b>Description:</b>
  This function is used by platform-specific power management logic.
  It will announce the power management power management state change to all drivers that have registered for power management event callbacks.
</p>
<p><b>Input Parameters:</b>
 <dl>
   <dt><code>newstate</code>
   <dd>Identifies the new PM state
 </dl>
</p>
<p><b>Returned Value:</b>
  0 (<code>OK</code>) means that the callback function for all registered drivers returned <code>OK</code> (meaning that they accept the state change).
  Non-zero means that one of the drivers refused the state change.
  In this case, the system will revert to the preceding state.
</p>
<p><b>Assumptions:</b>
   It is assumed that interrupts are disabled when this function is called.
   This function is probably called from the IDLE loop... the lowest priority task in the system.
   Changing driver power management states may result in renewed system activity and, as a result, can
   suspend the IDLE thread before it completes the entire state change unless interrupts are disabled throughout the state change.
</p>

<h3><a name="pmcallbacks">6.4.3 Callbacks</a></h3>
<p>
  The <code>struct pm_callback_s</code> includes the pointers to the driver callback functions.
  This structure is defined <code>include/nuttx/power/pm.h</code>.
  These callback functions can be used to provide power management information to the driver.
</p>

<h4><a name="pmprepare">6.4.3.1 <code>prepare()</code></a></h4>
<p><b>Function Prototype:</b></p>
<ul><pre>
int (*prepare)(FAR struct pm_callback_s *cb, enum pm_state_e pmstate);
</pre></ul>
<p><b>Description:</b>
   Request the driver to prepare for a new power state.
   This is a warning that the system is about to enter into a new power state.
   The driver should begin whatever operations that may be required to enter power state.
   The driver may abort the state change mode by returning a non-zero value from the callback function.
</p>
<p><b>Input Parameters:</b>
 <dl>
   <dt><code>cb</code>
   <dd>Returned to the driver.
   The driver version of the callback structure may include additional, driver-specific state data at the end of the structure.
   <dt><code>pmstate</code>
   <dd>Identifies the new PM state
 </dl>
</p>
<p><b>Returned Value:</b>
   Zero (<code>OK</code>) means the event was successfully processed and that the driver is prepared for the PM state change.
   Non-zero means that the driver is not prepared to perform the tasks needed achieve this power setting and will cause the state change to be aborted.
   NOTE:  The <code>prepare()</code> method will also be called when reverting from lower back to higher power consumption modes (say because another driver refused a lower power state change).
   Drivers are not permitted to return non-zero values when reverting back to higher power
   consumption modes!
</p>

<h4><a name="pmnotify">6.4.3.1 <code>notify()</code></a></h4>
<p><b>Function Prototype:</b></p>
<ul><pre>
#include &lt;nuttx/power/pm.h&gt;
void (*notify)(FAR struct pm_callback_s *cb, enum pm_state_e pmstate);
</pre></ul>
<p><b>Description:</b>
  Notify the driver of new power state.
  This callback is called after all drivers have had the opportunity to prepare for the new power  state.
</p>
<p><b>Input Parameters:</b>
 <dl>
   <dt><code>cb</code>
   <dd>Returned to the driver.
   The driver version of the callback structure may include additional, driver-specific state data at the end of the structure.
   <dt><code>pmstate</code>
   <dd>Identifies the new PM state
 </dl>
</p>
<p><b>Returned Value:</b>
  None.
  The driver already agreed to transition to the low power consumption state when when it returned <code>OK</code> to the <code>prepare()</code> call.
</p>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
    <td>
      <h1><a name="apndxconfigs">Appendix A:  NuttX Configuration Settings</a></h1>
    </td>
  </tr>
</table>

<p>
  At one time, this section provided a list of all NuttX configuration variables.
  However, NuttX has since converted to use the <a href="http://ymorin.is-a-geek.org/projects/kconfig-frontends">kconfig-frontends</a> tools.
  Now, the NuttX configuration is determined by a self-documenting set of <code>Kconfig</code> files.
</p>
<p>
  The current NuttX configuration variables are also documented in separate, auto-generated configuration variable document.
  That configuration variable document is generated using the <code>kconfig2html</code> tool that can be found in the <code>nuttx/tools</code> directory.
  That tool analyzes the NuttX Kconfig files and generates excruciatingly boring HTML document.
</p>
<p>
  The latest boring configuration variable documentation can be regenerated at any time using that tool or, more appropriately, the wrapper script at <code>nuttx/tools/mkconfigvars.sh</code>.
  That script will generate the file <code>nuttx/Documentation/NuttXConfigVariables.html</code>.
<p>
  The version of <code>NuttXConfigVariables.html</code> for the last released version of NuttX can also be found <a href="http://nuttx.org/Documentation/NuttXConfigVariables.html">online</a>.
</p>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
    <td>
      <h1><a name="apndxtrademarks">Appendix B:  Trademarks</a></h1>
    </td>
  </tr>
</table>

  <li>ARM, ARM7 ARM7TDMI, ARM9, ARM920T, ARM926EJS, Cortex-M3 are trademarks of Advanced RISC Machines, Limited.</li>
  <li>Cygwin is a trademark of Red Hat, Incorporated.</li>
  <li>Linux is a registered trademark of Linus Torvalds.</li>
  <li>Eagle-100 is a trademark of <a href=" http://www.micromint.com/">Micromint USA, LLC</a>.
  <li>LPC2148 is a trademark of NXP Semiconductors.</li>
  <li>TI is a trade name of Texas Instruments Incorporated.</li>
  <li>UNIX is a registered trademark of The Open Group.</li>
  <li>VxWorks is a registered trademark of Wind River Systems, Incorporated.</li>
  <li>ZDS, ZNEO, Z16F, Z80, and Zilog are a registered trademark of Zilog, Inc.</li>

<p>
  NOTE: NuttX is <i>not</i> licensed to use the POSIX trademark.  NuttX uses the POSIX
  standard as a development guideline only.
</p>

</body>
</html>


