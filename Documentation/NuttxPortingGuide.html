<html>
<head>
<title>NuttX Porting Guide</title>
<meta name="author" content="Gregory Nutt">
<link rel="stylesheet" href="style.css">
</head>

<body>

<div class="container">
<div class="toc">
<table width ="100%">
  <tr bgcolor="#e4e4e4">
    <td>
  <h1>Table of Contents</h1>
    </td>
  </tr>
</table>

<ul>
  <a href="#Introduction">1.0 Introduction</a><br>
  <a href="#DirectoryStructure">2.0 Directory Structure</a>
  <ul>
    <a href="#DirStructDocumentation">2.1 nuttx/Documentation</a><br>
    <a href="#DirStructArch">2.2 nuttx/arch/</a>
    <ul>
      <a href="#archdirectorystructure">2.2.1 Subdirectory Structure</a><br>
      <a href="#summaryofarchfiles">2.2.2 Summary of Files</a><br>
      <a href="#supportedarchitectures">2.2.3 Supported Architectures</a>
    </ul>
    <a href="#DirStructBinFmt">2.3 nuttx/binfmt/</a><br>
    <a href="#DirStructAudio">2.4 nuttx/audio/</a><br>
    <a href="#DirStructConfigs">2.5 nuttx/boards/</a>
    <ul>
      <a href="#boardsdirectorystructure">2.5.1 Subdirectory Structure</a><br>
      <a href="#summaryofconfigfiles">2.5.2 Summary of Files</a>
      <ul>
        <a href="#boardlogic">2.5.2.1 Board Specific Logic</a><br>
        <a href="#boardconfigsubdirs">2.5.2.2 Board Specific Configuration Sub-Directories</a>
      </ul>
      <a href="#supportedboards">2.5.3 Supported Boards</a><br>
      <a href="#newboardconfig">2.5.4 Adding a New Board Configuration</a>
    </ul>
    <a href="#DirStructDrivers">2.6 nuttx/drivers/</a><br>
    <a href="#DirStructCrypto">2.7 nuttx/crypto/</a><br>
    <a href="#DirStructFs">2.8 nuttx/fs/</a><br>
    <a href="#DirStructGraphics">2.9 nuttx/graphics/</a><br>
    <a href="#DirStructInclude">2.10 nuttx/include/</a><br>
    <a href="#DirStructLib">2.11 nuttx/lib/</a><br>
    <a href="#DirStructLibC">2.12 nuttx/libs/libc/</a><br>
    <a href="#DirStructLibXX">2.13 nuttx/libs/libxx/</a><br>
    <a href="#DirStructMm">2.14 nuttx/mm/</a><br>
    <a href="#DirStructNet">2.15 nuttx/net</a><br>
    <a href="#DirStructSched">2.16 nuttx/sched/</a><br>
    <a href="#DirStructSyscall">2.17 nuttx/syscall/</a><br>
    <a href="#DirStructTools">2.18 nuttx/tools/</a><br>
    <a href="#DirStructWireless">2.19 nuttx/wireless/</a><br>
    <a href="#topmakefile">2.20 nuttx/Makefile</a><br>
  </ul>
  <a href="#configandbuild">3.0 Configuring and Building</a>
  <ul>
    <a href="#configuringnuttx">3.1 Configuring NuttX</a><br>
    <a href="#buildingnuttx">3.2 Building NuttX</a>
  </ul>
  <a href="#ArchAPIs">4.0 Architecture APIs</a>
  <ul>
    <a href="#naming">4.1 Naming and Header File Conventions</a><br>
    <a href="#imports">4.2 APIs Exported by Architecture-Specific Logic to NuttX</a>
    <ul>
      <a href="#upinitialize">4.2.1 <code>up_initialize()</code></a><br>
      <a href="#upidle">4.2.2 <code>up_idle()</code></a><br>
      <a href="#upinitialstate">4.2.3 <code>up_initial_state()</code></a><br>
      <a href="#upcreatestack">4.2.4 <code>up_create_stack()</code></a><br>
      <a href="#upusestack">4.2.5 <code>up_use_stack()</code></a><br>
      <a href="#upstackframe">4.2.6 <code>up_stack_frame()</code></a><br>
      <a href="#upreleasestack">4.2.7 <code>up_release_stack()</code></a><br>
      <a href="#upunblocktask">4.2.8 <code>up_unblock_task()</code></a><br>
      <a href="#upblocktask">4.2.9 <code>up_block_task()</code></a><br>
      <a href="#upreleasepending">4.2.10 <code>up_release_pending()</code></a><br>
      <a href="#upreprioritizertr">4.2.11 <code>up_reprioritize_rtr()</code></a><br>
      <a href="#upexit">4.2.12 <code>up_exit()</code></a><br>
      <a href="#upassert">4.2.13 <code>up_assert()</code></a><br>
      <a href="#upschedulesigaction">4.2.14 <code>up_schedule_sigaction()</code></a><br>
      <a href="#upallocateheap">4.2.15 <code>up_allocate_heap()</code></a><br>
      <a href="#upinterruptcontext">4.2.16 <code>up_interrupt_context()</code></a><br>
      <a href="#updisableirq">4.2.17 <code>up_disable_irq()</code></a><br>
      <a href="#upenableirq">4.2.18 <code>up_enable_irq()</code></a><br>
      <a href="#upprioritizeirq">4.2.19 <code>up_prioritize_irq()</code></a><br>
      <a href="#upputc">4.2.20 <code>up_putc()</code></a><br>
    </ul>
    <a href="#boardimports">4.3 APIs Exported by Board-Specific Logic to NuttX</a>
    <ul>
      <a href="#boardearlyinit">4.3.1 <code>board_early_initialize()</code></a><br>
      <a href="#boardlateinit">4.3.2 <code>board_late_initialize()</code></a><br>
    </ul>
    <a href="#systemtime">4.4 System Time and Clock</a>
    <ul>
      <a href="#basictimer">4.4.1 Basic System Timer</a><br>
      <a href="#timerhw">4.4.2 Hardware</a><br>
      <a href="#systcktime">4.4.3 System Tick and Time</a><br>
      <a href="#tickless">4.4.4 Tickless OS</a><br>
      <a href="#Watchdogs">4.4.5 Watchdog Timer Interfaces</a>
    </ul>
    <a href="#workqueues">4.5 Work Queues</a>
    <ul>
      <a href="#wqclasses">4.5.1 Classes of Work Queues</a>
      <ul>
        <a href="#hpwork">4.5.1.1 High Priority Kernel Work queue</a><br>
        <a href="#lpwork">4.5.1.2 Low Priority Kernel Work Queue</a><br>
        <a href="#usrwork">4.5.1.3 User-Mode Work Queue</a>
      </ul>
      <a href="#cmnwqifs">4.5.2 Common Work Queue Interfaces</a>
      <ul>
        <a href="#wqids">4.5.2.1 Work Queue IDs</a><br>
        <a href="#wqiftypes">4.5.2.2 Work Queue Interface Types</a><br>
        <a href="#wqintfs">4.5.2.3 Work Queue Interfaces</a>
        <ul>
          <a href="#workqueue">4.5.2.3.1 <code>work_queue()</code></a><br>
          <a href="#workcancel">4.5.2.3.2 <code>work_cancel()</code></a><br>
          <a href="#worksignal">4.5.2.3.3 <code>work_signal()</code></a><br>
          <a href="#workavailable">4.5.2.3.4 <code>work_available()</code></a><br>
          <a href="#workusrstart">4.5.2.3.5 <code>work_usrstart()</code></a><br>
          <a href="#lpworkboostpriority">4.5.2.3.6 <code>lpwork_boostpriority()</code></a><br>
          <a href="#lpworkrestorepriority">4.5.2.3.7 <code>lpwork_restorepriority()</code></a>
        </ul>
      </ul>
    </ul>
    <a href="#addrenv">4.6 Address Environments</a>
    <ul>
      <a href="#up_addrenv_create">4.6.1 <code>up_addrenv_create()</code></a><br>
      <a href="#up_addrenv_destroy">4.6.2 <code>up_addrenv_destroy()</code></a><br>
      <a href="#up_addrenv_vtext">4.6.3 <code>up_addrenv_vtext()</code></a><br>
      <a href="#up_addrenv_vdata">4.6.4 <code>up_addrenv_vdata()</code></a><br>
      <a href="#up_addrenv_heapsize">4.6.5 <code>up_addrenv_heapsize()</code></a><br>
      <a href="#up_addrenv_select">4.6.6 <code>up_addrenv_select()</code></a><br>
      <a href="#up_addrenv_restore">4.6.7 <code>up_addrenv_restore()</code></a><br>
      <a href="#up_addrenv_clone">4.6.8 <code>up_addrenv_clone()</code></a><br>
      <a href="#up_addrenv_attach">4.6.9 <code>up_addrenv_attach()</code></a><br>
      <a href="#up_addrenv_detach">4.6.10 <code>up_addrenv_detach()</code></a><br>
      <a href="#up_addrenv_ustackalloc">4.6.11 <code>up_addrenv_ustackalloc()</code></a><br>
      <a href="#up_addrenv_ustackfree">4.6.12 <code>up_addrenv_ustackfree()</code></a><br>
      <a href="#up_addrenv_vustack">4.6.13 <code>up_addrenv_vustack()</code></a><br>
      <a href="#up_addrenv_ustackselect">4.6.14 <code>up_addrenv_ustackselect()</code></a><br>
      <a href="#up_addrenv_kstackalloc">4.6.15 <code>up_addrenv_kstackalloc()</code></a><br>
      <a href="#up_addrenv_kstackfree">4.6.16 <code>up_addrenv_kstackfree()</code></a>
    </ul>
    <a href="#exports">4.7 APIs Exported by NuttX to Architecture-Specific Logic</a>
    <ul>
      <a href="#osstart">4.7.1 <code>nx_start()</code></a><br>
      <a href="#listmgmt">4.7.2 OS List Management APIs</a><br>
      <a href="#schedprocesstimer">4.7.3 <code>nxsched_process_timer()</code></a><br>
      <a href="#schedtimerexpiration">4.7.4 <code>nxsched_timer_expiration()</code></a><br>
      <a href="#schedalarmexpiration">4.7.5 <code>nxsched_alarm_expiration()</code></a><br>
      <a href="#irqdispatch">4.7.6 <code>irq_dispatch()</code></a>
    </ul>
    <a href="#internalOS">4.8 Application OS vs. Internal OS Interfaces</a><br>
    <a href="#boardctl">4.9 <code>boardctl()</code> Application Interface</a><br>
    <a href="#boardsmp">4.10 Symmetric Multiprocessing (SMP) Application Interface</a>
    <ul>
      <a href="#uptestset">4.10.1 <code>up_testset()</code></a><br>
      <a href="#upcpuindex">4.10.2 <code>up_cpu_index()</code></a><br>
      <a href="#upcpustart">4.10.3 <code>up_cpu_start()</code></a><br>
      <a href="#upcpupause">4.10.4 <code>up_cpu_pause()</code></a><br>
      <a href="#upcpuresume">4.10.5 <code>up_cpu_resume()</code></a>
    </ul>
    <a href="#shm">4.11 Shared Memory</a>
    <ul>
      <a href="#upshmat">4.11.1 <code>up_shmat()</code></a><br>
      <a href="#upshmdt">4.11.2 <code>up_shmdt()</code></a><br>
    </ul>
    <a href="#demandpaging">4.12 On-Demand Paging</a><br>
    <a href="#ledsupport">4.13 LED Support</a>
    <ul>
      <a href="#ledheaders">4.13.1 Header Files</a><br>
      <a href="#leddefinitions">4.13.2 LED Definitions</a><br>
      <a href="#ledapis">4.13.3 Common LED interfaces</a>
    </ul>
    <a href="#iobs">4.14 I/O Buffer Management</a>
    <ul>
      <a href="#iobconfig">4.14.1 Configuration Options</a><br>
      <a href="#iobthrottle">4.14.2 Throttling</a><br>
      <a href="#iobtypes">4.14.3 Public Types</a><br>
      <a href="#iobprotos">4.14.4 Public Function Prototypes</a>
    </ul>
  </ul>
  <a href="#NxFileSystem">5.0 NuttX File System</a><br>
  <a href="#DeviceDrivers">6.0 NuttX Device Drivers</a>
  <ul>
    <a href="#chardrivers">6.1 Character Device Drivers</a><br>
    <ul>
       <a href="#serialdrivers">6.1.1 Serial Device Drivers</a><br>
       <a href="#tscdrivers">6.1.2 Touchscreen Device Drivers</a><br>
       <a href="#analogdrivers">6.1.3 Analog (ADC/DAC) Drivers</a><br>
       <a href="#pwmdrivers">6.1.4 PWM Drivers</a><br>
       <a href="#candrivers">6.1.5 CAN Drivers</a><br>
       <a href="#quadencoder">6.1.6 Quadrature Encoder Drivers</a><br>
       <a href="#timerdriver">6.1.7 Timer Drivers</a><br>
       <a href="#rtcriver">6.1.8 RTC Drivers</a><br>
       <a href="#wdogdriver">6.1.9 Watchdog Timer Drivers</a><br>
       <a href="#kbddriver">6.1.10 Keyboard/Keypad Drivers</a><br>
    </ul>
    <a href="#blockdrivers">6.2 Block Device Drivers</a><br>
    <a href="#specdrivers">6.3 Specialized Device Drivers</a>
    <ul>
       <a href="#ethdrivers">6.3.1 Ethernet Device Drivers</a><br>
       <a href="#spidrivers">6.3.2 SPI Device Drivers</a><br>
       <a href="#i2cdrivers">6.3.3 I2C Device Drivers</a><br>
       <a href="#fbdrivers">6.3.4 Frame Buffer Drivers</a><br>
       <a href="#lcddrivers">6.3.5 LCD Drivers</a><br>
       <a href="#mtddrivers">6.3.6 Memory Technology Device Drivers</a><br>
       <a href="#sdiodrivers">6.3.7 SDIO Device Drivers</a><br>
       <a href="#usbhostdrivers">6.3.8 USB Host-Side Drivers</a><br>
       <a href="#usbdevdrivers">6.3.9 USB Device-Side Drivers</a><br>
       <a href="#usbdevdrivers">6.3.10 SocketCAN Device Drivers</a><br>
    </ul>
    <a href="#syslog">6.4 SYSLOG</a>
    <ul>
       <a href="#syslogif">6.4.1 SYSLOG Interfaces</a><br>
       <a href="#syslogchannels">6.4.2 SYSLOG Channels</a><br>
       <a href="#syslogoptions">6.4.3 SYSLOG Channel Options</a><br>
       <a href="#ramlog">6.4.4 RAM Logging Device</a>
    </ul>
    <a href="#pwrmgmt">6.5 Power Management</a>
    <ul>
       <a href="#pmoverview">6.5.1 Overview</a><br>
       <a href="#pminterfaces">6.5.2 Interfaces</a><br>
       <a href="#pmcallbacks">6.5.3 Callbacks</a>
    </ul>
  </ul>
  <a href="#apndxconfigs">Appendix A: NuttX Configuration Settings</a><br>
  <a href="#apndxtrademarks">Appendix B:  Trademarks</a>
</ul>
</div>

<div class="main">

<hr><hr>
<table width ="100%">
  <tr align="center" bgcolor="#e4e4e4">
    <td>
      <h1><big><font color="#3c34ec">
        <i>NuttX RTOS Porting Guide</i>
      </font></big></h1>
      <p>Last Updated: April 7, 2020</p>
    </td>
  </tr>
</table>
<hr><hr>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
    <td>
      <h1>1.0 <a name="Introduction">Introduction</a></h1>
    </td>
  </tr>
</table>

<p><b>Overview</b>
  This document provides and overview of the NuttX build and configuration
  logic and provides hints for the incorporation of new processor/board architectures
  into the build.
</p>
<p>
  See also <code>arch/README.txt</code> and <code>boards/README.txt</code>.
</p>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
    <td>
      <h1>2.0 <a name="DirectoryStructure">Directory Structure</a></h1>
    </td>
  </tr>
</table>

<p>
  <b>Directory Structure</b>.
  The general directory layout for NuttX is very similar to the directory structure
  of the Linux kernel -- at least at the most superficial layers.
  At the top level is the main makefile and a series of sub-directories identified
  below and discussed in the following paragraphs:
</p>
<ul><pre>
.
|- nuttx
|   |-- <a href="#topmakefile">Makefile</a>
|   |-- Kconfig
|   |-- <a href="#DirStructDocumentation">Documentation</a>
|   |   `-- <i>(documentation files)</i>/
|   |-- <a href="#DirStructArch">arch</a>/
|   |   |-- Kconfig
|   |   |-- <i>&lt;arch-name&gt;</i>/
|   |   |   |-- include/
|   |   |   |   |--<i>&lt;chip-name&gt;</i>/
|   |   |   |   |  `-- <i>(chip-specific header files)</i>
|   |   |   |   |--<i>&lt;other-chips&gt;</i>/
|   |   |   |   `-- <i>(architecture-specific header files)</i>
|   |   |   `-- src/
|   |   |       |--<i>&lt;chip-name&gt;</i>/
|   |   |       |  `-- <i>(chip-specific source files)</i>
|   |   |       |--<i>&lt;other-chips&gt;</i>/
|   |   |       `-- <i>(architecture-specific source files)</i>
|   |   `-- <i>&lt;other-architecture directories&gt;</i>/
|   |-- <a href="#DirStructAudio">audio</a>/
|   |   |-- Makefile
|   |   |-- Kconfig
|   |   `-- <i>(common audio source files)</i>
|   |-- <a href="#DirStructBinFmt">binfmt</a>/
|   |   |-- Makefile
|   |   |-- Kconfig
|   |   |-- <i>(binfmt-specific sub-directories)</i>/
|   |   |   `-- <i>(binfmt-specific source files)</i>
|   |   `-- <i>(common binfmt source files)</i>
|   |-- <a href="#DirStructConfigs">boards</a>/
|   |   |-- <i>&lt;architecture-name&gt;</i>/
|   |   |   |-- <i>&lt;chip-name&gt;</i>/
|   |   |   |   |-- <i>&lt;board-name&gt;</i>/
|   |   |   |   |   |-- include/
|   |   |   |   |   |   `-- <i>(other board-specific header files)</i>
|   |   |   |   |   |-- src/
|   |   |   |   |   |   `-- <i>(board-specific source files)</i>
|   |   |   |   |   `- configs/
|   |   |   |   |         |---<i>&lt;config-name&gt;</i>/
|   |   |   |   |         |   `-- <i>(board configuration-specific source files)</i>
|   |   |   |   |         `---<i>(other configuration sub-directories for this board)</i>/
|   |   |   |   `-- <i>&lt;(other board directories)&gt;</i>/
|   |   |   `-- <i>&lt;(other chip directories)&gt;</i>/
|   |   `-- <i>&lt;(other architecture directories)&gt;</i>/
|   |-- crypto
|   |   |-- Makefile
|   |   |-- Kconfig
|   |   `-- <i>(common crypto source files)</i>
|   |-- <a href="#DirStructDrivers">drivers</a>/
|   |   |-- Makefile
|   |   |-- Kconfig
|   |   |-- <i>(driver-specific sub-directories)/</i>
|   |   |   `-- <i>(driver-specific source files)</i>
|   |   `-- <i>(common driver source files)</i>
|   |-- <a href="#DirStructFs">fs</a>/
|   |   |-- Makefile
|   |   |-- Kconfig
|   |   |-- <i>(file system-specific sub-directories)</i>/
|   |   |   `-- <i>(file system-specific source files)</i>
|   |   `-- <i>(common file system source files)</i>
|   |-- <a href="#DirStructGraphics">graphics</a>/
|   |   |-- Makefile
|   |   |-- Kconfig
|   |   |-- <i>(feature-specific sub-directories)</i>/
|   |   |   `-- <i>(feature-specific source files library source files)</i>
|   |   `-- <i>(common graphics-related source files)</i>
|   |-- <a href="#DirStructInclude">include</a>/
|   |   |-- <i>(standard header files)</i>
|   |   |-- <i>(standard include sub-directories)</i>
|   |   |   `-- <i>(more standard header files)</i>
|   |   |-- <i>(non-standard include sub-directories)</i>
|   |       `-- <i>(non-standard header files)</i>
|   |-- libs/
|   |   |-- <a href="#DirStructLibC">libc</a>/
|   |   |   |-- Makefile
|   |   |   |-- Kconfig
|   |   |   `-- <i>(libc source files)</i>
|   |   |-- libdsp/
|   |   |   |-- Makefile
|   |   |   |-- Kconfig
|   |   |   `-- <i>(libdsp source files)</i>
|   |   |-- libnx/
|   |   |   |-- Makefile
|   |   |   |-- Kconfig
|   |   |   `-- <i>(libdsp source files)</i>
|   |   `-- <a href="#DirStructLibXX">libxx</a>/
|   |       |-- Makefile
|   |       |-- Kconfig
|   |       `-- <i>(libxx source files)</i>
|   |-- <a href="#DirStructMm">mm</a>/
|   |   |-- Makefile
|   |   |-- Kconfig
|   |   `-- <i>(memory management source files)</i>
|   |-- <a href="#DirStructNet">net</a>/
|   |   |-- Makefile
|   |   |-- Kconfig
|   |   |-- arp/
|   |   |   `-- <i>(ARP source files)</i>
|   |   |-- devif/
|   |   |   `-- <i>(Ethernet device interface source files)</i>
|   |   |-- icmp/
|   |   |   `-- <i>(ICMP source files)</i>
|   |   |-- igmp/
|   |   |   `-- <i>(IGMP source files)</i>
|   |   |-- iob/
|   |   |   `-- <i>(I/O buffering source files)</i>
|   |   |-- ipv6/
|   |   |   `-- <i>(IPv6 source files)</i>
|   |   |-- netdev/
|   |   |   `-- <i>(Socket device interface source files)</i>
|   |   |-- pkt/
|   |   |   `-- <i>(Packet socket source files)</i>
|   |   |-- route/
|   |   |   `-- <i>(Routing table source files)</i>
|   |   |-- socket/
|   |   |   `-- <i>(BSD socket source files)</i>
|   |   |-- tcp/
|   |   |   `-- <i>(TCP source files)</i>
|   |   |-- udp/
|   |   |   `-- <i>(UDP source files)</i>
|   |   `-- utils/
|   |       `-- <i>(Miscellaneous, utility source files)</i>
|   |-- pass1/
|   |   `-- Makefile
|   |-- <a href="#DirStructSched">sched</a>/
|   |   |-- Makefile
|   |   |-- Kconfig
|   |   `-- <i>(sched source files)</i>
|   |-- <a href="#DirStructSysCall">syscall</a>/
|   |   |-- Makefile
|   |   |-- Kconfig
|   |   `-- <i>(syscall source files)</i>
|   |-- <a href="#DirStructTools">tools</a>/
|   |   `-- <i>(miscellaneous scripts and programs)</i>
|   `-- <a href="#DirStructWireless">wireless</a>/
|       |-- Makefile
|       |-- Kconfig
|       `-- <i>(wireless source files)</i>
`- apps
    |-- builtin/
    |   |-- Makefile
    |   |-- Make.defs
    |   |-- Kconfig
    |   `-- <i>(builtin source files)</i>
    |-- canutils/
    |   |-- Makefile
    |   |-- Make.defs
    |   |-- Kconfig
    |   `-- <i>(can utililities sub-directories)</i>
    |-- fsutils/
    |   |-- Makefile
    |   |-- Make.defs
    |   |-- Kconfig
    |   `-- <i>(File system utilities sub-directories)</i>
    |-- gpsutils/
    |   |-- Makefile
    |   |-- Make.defs
    |   |-- Kconfig
    |   `-- <i>(GPS utilities sub-directories)</i>
    |-- include/
    |   `-- <i>(Include sub-directories)</i>
    |-- interpreters/
    |   |-- Makefile
    |   |-- Make.defs
    |   |-- Kconfig
    |   `-- <i>(Interpreter sub-directories)</i>
    |-- modbus/
    |   |-- Makefile
    |   |-- Make.defs
    |   |-- Kconfig
    |   `-- <i>(Modbus source files)</i>
    |-- <a href="#DirStructNetUtils">netutils</a>/
    |   |-- Makefile
    |   |-- Make.defs
    |   |-- Kconfig
    |   |-- <i>(network feature sub-directories)</i>/
    |   |   `-- <i>(network utilities sub-directories)</i>
    |   `-- <i>(netutils common files)</i>
    |-- <a href="#DirStructNshLib">nshlib</a>/
    |   |-- Makefile
    |   |-- Make.defs
    |   |-- Kconfig
    |   `-- <i>NuttShell (NSH) files</i>
    |-- platform/
    |   |-- Makefile
    |   |-- Make.defs
    |   |-- Kconfig
    |   `-- <i>(Platform-specific sub-directories)</i>
    |-- system/
    |   |-- Makefile
    |   |-- Make.defs
    |   |-- Kconfig
    |   `-- <i>(System utilities sub-directories)</i>
    |-- testing/
    |   |-- Makefile
    |   |-- Make.defs
    |   |-- Kconfig
    |   `-- <i>(Test support sub-directories)</i>
    |-- wireless/
    |   |-- Makefile
    |   |-- Make.defs
    |   |-- Kconfig
    |   `-- <i>(Wireless utilities sub-directories)</i>
    `-- <a href="#DirStructExamples">examples</a>/
        `-- <i>(example)</i>/
            |-- Makefile
            |-- Make.defs
            |-- Kconfig
            `-- <i>(example sub-directories)</i>
</pre></ul>

<p>
  <b>Configuration Files</b>.
  The NuttX configuration consists of logic in processor architecture directories, <i>chip/SoC</i> directories, and board configuration directories.
  The complete configuration is specified by several settings in the NuttX configuration file.
</p>
<ul>
  <li>
    <p>
      <i>Processor architecture specific files</i>.
      These are the files contained in the <code>arch/</code><i>&lt;arch-name&gt;</i><code>/</code> directory and are discussed in a paragraph <a href="#archdirectorystructure">below</a>.
      As an example, all ARM processor architectures are provided under the <code>arch/arm/</code> directory which is selected with the <code>CONFIG_ARCH=&quot;arm&quot;</code> configuration option.
    </p>
    <p>
      Variants of the processor architecture may be provided in sub-directories of the
      Extending this example, the ARMv7-M ARM family is supported by logic in <code>arch/arm/include/armv7-m</code> and <code>arch/arm/src/armv7-m</code> directories which are selected by the <code>CONFIG_ARCH_CORTEXM3=y</code>, <code>CONFIG_ARCH_CORTEXM4=y</code>, or  <code>CONFIG_ARCH_CORTEXM7=y</code> configuration options
    </p>
  </li>
  <li>
    <p>
      <i>Chip/SoC specific files</i>.
      Each processor architecture is embedded in a <i>System-on-a-Chip</i> (SoC) architecture.
      The full SoC architecture includes the processor architecture plus chip-specific interrupt logic, clocking logic, general purpose I/O (GPIO) logic, and specialized, internal peripherals (such as UARTs, USB, etc.).
    </p>
    <p>
      These chip-specific files are contained within chip-specific sub-directories also under the
      <code>arch/</code><i>&lt;arch-name&gt;</i><code>/</code> directory and are selected via
      the <code>CONFIG_ARCH_CHIP</code> selection.
    </p>
    <p>
      As an example, the STMicro STM32 SoC architecture is based on the ARMv7-M processor and is supported by logic in the <code>arch/arm/include/stm32</code> and <code>arch/arm/src/stm32</code> directories which are selected with the <code>CONFIG_ARCH_CHIP="stm32"</code> configuration setting.
    </p>
  </li>
  <li>
    <p>
      <i>Board specific configurations</i>.
      In order to be usable, the chip must be contained in a board environment.
      The board configuration defines additional properties of the board including such things as peripheral LEDs, external peripherals (such as networks, USB, etc.).
    </p>
    <p>
      These board-specific configuration files can be found in the
      <code>boards/</code><i>&lt;arch-name&gt;</i><code>/</code><i>&lt;chip-name&gt;</i><code>/</code><i>&lt;board-name&gt;</i><code>/</code> sub-directories and are discussed
      in a paragraph <a href="#boardsdirectorystructure">below</a>.
    </p>
    <p>
      The directory <code>boards/arm/stm32/stm32f4disovery/</code>, as an example, holds board-specific logic for the STM32F4 Discovery board and is selected via the <code>CONFIG_ARCH_BOARD=&quot;stm32f4discovery&quot;</code> configuration setting.
    </p>
  </li>
</ul>

<h2>2.1 <a name="DirStructDocumentation">Documentation</a></h2>

<p>
  General documentation for the NuttX OS resides in this directory.
</p>

<h2>2.2 <a name="DirStructArch">nuttx/arch</a></h2>

<h3><a name="archdirectorystructure">2.2.1 Subdirectory Structure</a></h3>
<p>
  This directory contains several sub-directories, each containing
  architecture-specific logic.
  The task of porting NuttX to a new processor consists of
  add a new subdirectory under <code>arch/</code> containing logic specific
  to the new architecture.
  The complete board port in is defined by the architecture-specific code in this
  directory (plus the board-specific configurations in the <code>config/</code>
  subdirectory).
  Each architecture must provide a subdirectory, <i>&lt;arch-name&gt;</i>
  under <code>arch/</code> with the following characteristics:
</p>
<ul><pre>
<i>&lt;arch-name&gt;</i>/
|-- include/
|   |--<i>&lt;chip-name&gt;</i>/
|   |  `-- <i>(chip-specific header files)</i>
|   |--<i>&lt;other-chips&gt;</i>/
|   |-- arch.h
|   |-- irq.h
|   |-- types.h
|   |-- limits.h
|   `-- syscall.h
`-- src/
    |--<i>&lt;chip-name&gt;</i>/
    |  `-- <i>(chip-specific source files)</i>
    |--<i>&lt;other-chips&gt;</i>/
    |-- Makefile
    `-- <i>(architecture-specific source files)</i>
</pre></ul>

<h3><a name="summaryofarchfiles">2.2.2 Summary of Files</a></h3>
<ul>
  <li>
    <code>include/</code><i>&lt;chip-name&gt;</i><code>/</code>
    This sub-directory contains chip-specific header files.
  </li>
  <li>
    <code>include/arch.h</code>:
    This is a hook for any architecture specific definitions that may
    be needed by the system.  It is included by <code>include/nuttx/arch.h</code>.
  </li>
  <li>
    <code>include/types.h</code>:
    This provides architecture/toolchain-specific definitions for
    standard types.  This file should <code>typedef</code>:
    <ul><code>
      _int8_t, _uint8_t, _int16_t, _uint16_t, _int32_t, _uint32_t_t
    </code></ul>
    <p>and if the architecture supports 24- or 64-bit integers</p>
    <ul><code>
      _int24_t, _uint24_t, int64_t, uint64_t
    </code></ul>
    <p>
      NOTE that these type names have a leading underscore character.  This
      file will be included(indirectly) by include/stdint.h and typedef'ed to
      the final name without the underscore character.  This roundabout way of
      doings things allows the stdint.h to be removed from the include/
      directory in the event that the user prefers to use the definitions
      provided by their toolchain header files
    </p>
    <p>
      And finally
    </p>
    <ul><code>
      irqstate_t
    </code></ul>
    <p>
      Must be defined to the be the size required to hold the interrupt
     enable/disable state.
    </p>
    <p>
      This file will be included by include/sys/types.h and be made
      available to all files.
    </p>
  </li>
  <li>
    <code>include/irq.h</code>:
    This file needs to define some architecture specific functions (usually
    inline if the compiler supports inlining) and some structures.  These include:
    <ul>
      <li>
        <code>struct xcptcontext</code>:
        This structures represents the saved context of a thread.
      </li>
      <li>
        <code>irqstate_t up_irq_save(void)</code>:
        Used to disable all interrupts.
        In the case of multi-CPU platforms, this function disables interrupts on CPUs.
      </li>
      <li>
        <code>void up_irq_restore(irqstate_t flags)</code>:
        Used to restore interrupt enables to the same state as before <code>up_irq_save()</code> was called.
      </li>
    </ul>
    <p>
      This file must also define <code>NR_IRQS</code>, the total number of IRQs supported
       by the board.
    </p>
  </li>
  <li>
    <code>include/syscall.h</code>:
    This file needs to define some architecture specific functions (usually
    inline if the compiler supports inlining) to support software interrupts
    or <i>syscall</i>s that can be used all from user-mode applications into
    kernel-mode NuttX functions.
    This directory must always be provided to prevent compilation errors.
    However, it need only contain valid function declarations if the architecture
    supports the <code>CONFIG_BUILD_PROTECTED</code> or <code>CONFIG_BUILD_KERNEL</code>configurations.
    <ul>
      <li>
        <code>uintptr_t sys_call0(unsigned int nbr)</code>:
        <code>nbr</code> is one of the system call numbers that can be found in <code>include/sys/syscall.h</code>.
        This function will perform a system call with no (additional) parameters.
      </li>
      <li>
        <code>uintptr_t sys_call1(unsigned int nbr, uintptr_t parm1)</code>:
        <code>nbr</code> is one of the system call numbers that can be found in <code>include/sys/syscall.h</code>.
        This function will perform a system call with one (additional) parameter.
      </li>
      <li>
        <code>uintptr_t sys_call2(unsigned int nbr, uintptr_t parm1, uintptr_t parm2)</code>:
        <code>nbr</code> is one of the system call numbers that can be found in <code>include/sys/syscall.h</code>.
        This function will perform a system call with two (additional) parameters.
      </li>
      <li>
        <code>uintptr_t sys_call3(unsigned int nbr, uintptr_t parm1, uintptr_t parm2, uintptr_t parm3)</code>:
        <code>nbr</code> is one of the system call numbers that can be found in <code>include/sys/syscall.h</code>.
        This function will perform a system call with three (additional) parameters.
      </li>
      <li>
        <code>uintptr_t sys_call4(unsigned int nbr, uintptr_t parm1, uintptr_t parm2, uintptr_t parm3, uintptr_t parm4)</code>:
        <code>nbr</code> is one of the system call numbers that can be found in <code>include/sys/syscall.h</code>.
        This function will perform a system call with four (additional) parameters.
      </li>
      <li>
        <code>uintptr_t sys_call5(unsigned int nbr, uintptr_t parm1, uintptr_t parm2, uintptr_t parm3, uintptr_t parm4, uintptr_t parm5)</code>:
        <code>nbr</code> is one of the system call numbers that can be found in <code>include/sys/syscall.h</code>.
        This function will perform a system call with five (additional) parameters.
      </li>
      <li>
        <code>uintptr_t sys_call6(unsigned int nbr, uintptr_t parm1, uintptr_t parm2, uintptr_t parm3, uintptr_t parm4, uintptr_t parm5, uintptr_t parm6)</code>:
        <code>nbr</code> is one of the system call numbers that can be found in <code>include/sys/syscall.h</code>.
        This function will perform a system call with six (additional) parameters.
      </li>
    </ul>
    <p>
      This file must also define <code>NR_IRQS</code>, the total number of IRQs supported
       by the board.
    </p>
  </li>
  <li>
    <code>src/</code><i>&lt;chip-name&gt;</i><code>/</code>
    This sub-directory contains chip-specific source files.
  </li>
  <li>
    <code>src/Makefile</code>:
    This makefile will be executed to build the targets <code>src/libup.a</code> and
    <code>src/up_head.o</code>.  The <code>up_head.o</code> file holds the entry point into the system
    (power-on reset entry point, for example).  It will be used in
    the final link with <code>libup.a</code> and other system archives to generate the
    final executable.
  </li>
  <li>
    <i>(architecture-specific source files)</i>.
    The file <code>include/nuttx/arch.h</code> identifies all of the APIs that must
    be provided by the architecture specific logic.  (It also includes
    <code>arch/</code><i>&lt;arch-name&gt;</i><code>/arch.h</code> as described above).
  </li>
</ul>

<h3><a name="supportedarchitectures">2.2.3 Supported Architectures</a></h3>
<p>
   <b>Architecture- and Chip-Specific Directories</b>.
   All processor architecture-specific directories are maintained in sub-directories of
   the <code>arch/</code> directory.
   Different chips or SoC's may implement the same processor core.
   Chip-specific logic can be found in sub-directories under the architecture
   directory.
   Current architecture/chip directories are summarized below:
</p>
<ul>
  <li><code>arch/sim</code>:
    A user-mode port of NuttX to the x86 Linux or Cygwin platform is available.
    The purpose of this port is primarily to support OS feature development.
    This port does not support interrupts or a real timer (and hence no
    round robin scheduler)  Otherwise, it is complete.
  </li>
  <p>NOTE: In principle, this user mode port should run in any POSIX environment.
    This target will probably not run &quot;out-of-the-box&quot; in unverified POSIX environments due to the many host environment dependencies.
  </p>

  <li><code>arch/arm</code>:
    This directory holds common ARM architectures.
  </li>

  <li><code>arch/avr</code>:
    This directory holds common AVR and AVR32 architectures.
  </li>

  <li><code>arch/mips</code>:
    This directory holds common MIPS architectures.  This include PIC32MX and PIC32MZ.
  </li>

  <li><code>arch/misoc</code>:
    This directory supports the Misoc LM3 architecture.
  </li>

  <li><code>arch/or1K</code>:
    This directory supports the OpenRISC mor1kx architecture.
  </li>

  <li><code>arch/renesas</code>:
    This directory is the home for various Renesas architectures, currently only the M16C and vererable SuperH-1 architectures.
  </li>

  <li><code>arch/risc-v</code>:
    This directory supports the RISC-V NR5 architecture.
  </li>

  <li><code>arch/xtensa</code>:
    This directory supports the Xtensa LX6 architecture as used by the ESP32.
  </li>

  <li><code>arch/z16f</code>:
    Zilog z16f Microcontroller.
  </li>

  <li><code>arch/z80</code>:
    This directory holds 8-bit ZiLOG architectures.  At present, this includes the
    Zilog z80, ez80Acclaim! and z8Encore! Microcontrollers.
  </li>
</ul>

<h2>2.3 <a name="DirStructBinFmt">nuttx/binfmt</a></h2>

<p>
  The <code>binfmt/</code> subdirectory contains logic for loading binaries in the file
  system into memory in a form that can be used to execute them.
</p>

<h2>2.4 <a name="DirStructAudio">nuttx/audio</a></h2>

<p>
  The <code>audio/</code> subdirectory contains the NuttX audio sub-system.
</p>

<h2>2.5 <a name="DirStructConfigs">nuttx/boards</a></h2>
<p>
  The <code>boards/</code> subdirectory contains custom logic and board configuration data for each board.
  These board-specific configurations plus the architecture-specific configurations in the <code>arch/</code> subdirectory complete define a customized port of NuttX.
</p>

<h3><a name="boardsdirectorystructure">2.5.1 Subdirectory Structure</a></h3>
<p>
  The <code>boards/</code> directory contains board specific configuration files.  Each board must
  provide a sub-directory &lt;board-name&gt; under <code>boards/</code><i>&lt;arch-name&gt;</i><code>/</code>><i>&lt;chip-name&gt;</i><code>/</code> with the following characteristics:
</p>
<ul><pre>
<i>&lt;board-name&gt;</i>
|-- Kconfig
|-- include/
|   |-- board.h
|   `-- <i>(board-specific header files)</i>
|-- src/
|   |-- Makefile
|   `-- <i>(board-specific source files)</i>
|-- configs/
|   |-- <i>&lt;config1-dir&gt;</i>
|   |   |-- Make.defs (optional)
|   |   `-- defconfig
|   |-- <i>&lt;config2-dir&gt;</i>
|   |   |-- Make.defs
|   |   `-- defconfig
|   ...
|-- scripts/
|   |-- <i>(linker script files)</i>
|   `-- Make.defs <i>(optional)</i>
`-- <i>(other board-specific configuration sub-directories)</i>/
</pre></ul>

<h3><a name="summaryofconfigfiles">2.5.2 Summary of Files</a></h3>
<h4><a name="boardlogic">2.5.2.1 Board Specific Logic</a></h4>
<ul>
  <li>
    <code>include/</code>:
    This directory contains board specific header files.
    This directory will be linked as <code>include/arch/board</code> at configuration time
    and can be included via <code>#include &lt;arch/board/header.h&gt;</code>.
    These header file can only be included by files in <code>arch/</code><i>&lt;arch-name&gt;</i><code>/include/</code>
    and <code>arch/</code><i>&lt;arch-name&gt;</i><code>/src/</code>.
  </li>
  <li>
    <code>src/</code>:
    This directory contains board specific drivers.
    This directory will be linked as <i>&lt;config&gt;</i><code>/arch/</code><i>&lt;arch-name&gt;</i><code>/src/board</code> at configuration
    time and will be integrated into the build system.
  </li>
  <li>
    <code>src/Makefile</code>:
    This makefile will be invoked to build the board specific drivers.
    It must support the following targets:  <code>libext$(LIBEXT)</code>, <code>clean</code>, and <code>distclean</code>.
  </li>
</ul>
<h4><a name="boardconfigsubdirs">2.5.2.2 Board Specific Configuration Sub-Directories</a></h4>
<p>
  The <code>boards/</code><i>&lt;arch-name&gt;</i><code>/</code><i>&lt;chip-name&gt;</i><code>/</code><i>&lt;board-name&gt;</i><code>/configs</code> sub-directory holds all of the
  files that are necessary to configure NuttX for the particular board.
  A board may have various different configurations using the common source files.
  Each board configuration is described by two files:  <code>Make.defs</code> and <code>defconfig</code>.
  Typically, each set of configuration files is retained in a separate configuration sub-directory
  (<i>&lt;config1-dir&gt;</i>, <i>&lt;config2-dir&gt;</i>, .. in the above diagram).
</p>
<p>
  NOTE: That the <code>Make.defs</code> file may reside in one of two locations:
  There may be a unique Make.defs file for each configuration in the configuration directory <i>OR</i>
  if that file is absent, there may be a common board <code>Make.defs</code> file in the <code>/scripts</code> directory.
  The <code>Make.defs</code> file in the configuration takes precedence if it is present.
</p>
<p>
  The procedure for configuring NuttX is described <a href="#configuringnuttx">below</a>,
  This paragraph will describe the contents of these configuration files.
</p>
<ul>
  <li>
    <code>Make.defs</code>: This makefile fragment provides architecture and
    tool-specific build options.  It will be included by all other
    makefiles in the build (once it is installed).  This make fragment
    should define:
    <ul>
      <li>Tools: <code>CC</code>, <code>LD</code>, <code>AR</code>, <code>NM</code>, <code>OBJCOPY</code>, <code>OBJDUMP</code></li>
      <li>Tool options: <code>CFLAGS</code>, <code>LDFLAGS</code></li>
    </ul>
    <p>
      When this makefile fragment runs, it will be passed <code>TOPDIR</code> which
      is the path to the root directory of the build.  This makefile
      fragment should include:
    </p>
    <ul>
      <li><code>$(TOPDIR)/.config </code> : Nuttx configuration</li>
      <li><code>$(TOPDIR)/tools/Config.mk</code>  : Common definitions</li>
    </ul>
    <p>
      Definitions in the <code>Make.defs</code> file probably depend on some of the
      settings in the .<code>config</code> file.  For example, the <code>CFLAGS</code> will most likely be
      different if <code>CONFIG_DEBUG_FEATURES=y</code>.
    </p>
    <p>
      The included <code>tools/Config.mk</code> file contains additional definitions that may
      be overridden in the architecture-specific Make.defs file as necessary:
    </p>
    <ul>
      <li><code>COMPILE</code>, <code>ASSEMBLE</code>, <code>ARCHIVE</code>, <code>CLEAN</code>, and <code>MKDEP</code> macros</li>
    </ul>
  </li>
  <li>
    <p>
      <code>defconfig</code>: This is a configuration file similar to the Linux
      configuration file.  In contains variable/value pairs like:
    </p>
    <ul>
      <li><code>CONFIG_VARIABLE</code>=value</li>
    </ul>
    <p>
      This configuration file will be used at build time:
    </p>
    <ol>
      <li>As a makefile fragment included in other makefiles, and</li>
      <li>to generate <code>include/nuttx/config.h</code> which is included by
          most C files in the system.</li>
    </ol>
  </li>
</ul>

<h3><a name="supportedboards">2.5.3 Supported Boards</a></h3>
<p>
  All of the specific boards supported by NuttX are identified in the  <a href="https://bitbucket.org/nuttx/nuttx/src/master/boards/README.txt" target="_blank">README.txt</a> file.
</p>
<h3><a name="newboardconfig">2.5.4 Adding a New Board Configuration</a></h3>
<p>
  Okay, so you have created a new board configuration directory.
  Now, how do you hook this board into the configuration system so that you can select with <code>make menuconfig</code>?
</p>
<p>
  You will need modify the file <code>boards/Kconfig</code>.
  Let's look at the STM32F4-Discovery configuration in the <code>Kconfig</code> file and see how we would add a new board directory to the configuration.
  For this configuration let's say that you new board resides in the directory <code>boards/myarch/mychip/myboard</code>;
  It uses an MCU selected with <code>CONFIG_ARCH_CHIP_MYMCU</code>; and you want the board to be selected with <code>CONFIG_ARCH_BOARD_MYBOARD</code>.
  Then here is how you can clone the STM32F4-Discovery configuration in <code>boards/Kconfig</code> to support your new board configuration.
</p>
<p>
  In <code>boards/Kconfig</code> for the stm32f4-discovery, you will see a configuration definition like this:
<p>
<ul><pre>
config ARCH_BOARD_STM32F4_DISCOVERY
    bool "STMicro STM32F4-Discovery board"
    depends on ARCH_CHIP_STM32F407VG
    select ARCH_HAVE_LEDS
    select ARCH_HAVE_BUTTONS
    select ARCH_HAVE_IRQBUTTONS
    ---help---
        STMicro STM32F4-Discovery board based on the STMicro STM32F407VGT6 MCU.
</pre></ul>
<p>
  The above selects the STM32F4-Discovery board.
  The <code>select</code> lines say that the board has both LEDs and buttons and that the board can generate interrupts from the button presses.
  You can just copy the above configuration definition to a new location (notice that they the configurations are in alphabetical order).
  Then you should edit the configuration to support your board.
  The final configuration definition might look something like:
</p>
<ul><pre>
config ARCH_BOARD_MYBOARD
    bool "My very own board configuration"
    depends on ARCH_CHIP_MYMCU
    select ARCH_HAVE_LEDS
    select ARCH_HAVE_BUTTONS
    select ARCH_HAVE_IRQBUTTONS
    ---help---
        This options selects the board configuration for my very own board
        based on the MYMCU processor.
</pre></ul>
<p>
  Later in the <code>boards/Kconfig</code> file, you will see a long, long string configuration with lots of defaults like this:
</p>
<ul><pre>
config ARCH_BOARD
    string
    default "amber"               if ARCH_BOARD_AMBER
    default "avr32dev1"           if ARCH_BOARD_AVR32DEV1
    default "c5471evm"            if ARCH_BOARD_C5471EVM
...
    default "stm32f4discovery"    if ARCH_BOARD_STM32F4_DISCOVERY
...
</pre></ul>
<p>
  This logic will assign string value to a configuration variable called <code>CONFIG_ARCH_BOARD</code> that will name the directory where the board-specific files reside.
  In our case, these files reside in <code>boards/myarch/mychip/myboard</code> and we add the following to the long list of defaults (again in alphabetical order):
</p>
<ul><pre>
    default "myboard"             if ARCH_BOARD_MYBOARD
</pre></ul>
<p>
  Now the build system knows where to find your board configuration!
</p>
<p>
  And finally, add something like this near the bottom of <code>boards/myarch/mychip/myboard</code>:
</p>
<ul><pre>
if ARCH_BOARD_MYBOARD
source "boards/myarch/mychip/myboard/Kconfig"
endif
</pre></ul>
<p>
  This includes additional, board-specific configuration variable definitions in <code>boards/myarch/mychip/myboard/Kconfig</code>.
</p>

<h2>2.6 <a name="DirStructCrypto">nuttx/crypto</a></h2>

<p>
  This sub-directory holds the NuttX cryptographic sub-system.
</p>

<h2>2.7 <a name="DirStructDrivers">nuttx/drivers</a></h2>

<p>
  This directory holds architecture-independent device drivers.
</p>
<ul><pre>
drivers/
|-- Kconfig
|-- Makefile
|-- 1wire/
|   |-- Kconfig
|   |-- Make.defs
|   `-- <i>(1-wire device source files)</i>
|-- analog/
|   |-- Kconfig
|   |-- Make.defs
|   `-- <i>(ADC and DAC driver source files)</i>
|-- audio/
|   |-- Kconfig
|   |-- Make.defs
|   `-- <i>(Audio device source files)</i>
|-- bch/
|   |-- Kconfig
|   |-- Make.defs
|   `-- <i>(BCH driver source files)</i>
|-- can/
|   |-- Kconfig
|   |-- Make.defs
|   `-- <i>(CAN driver source files)</i>
|-- contactless/
|   |-- Kconfig
|   |-- Make.defs
|   `-- <i>(Contactless device driver source files)</i>
|-- eeprom/
|   |-- Kconfig
|   |-- Make.defs
|   `-- <i>(EEPROM character driver source files)</i>
|-- i2c/
|   |-- Kconfig
|   |-- Make.defs
|   `-- <i>(I2C device driver source files)</i>
|-- input/
|   |-- Kconfig
|   |-- Make.defs
|   `-- <i>(Touchscreen and keypad driver source files)</i>
|-- ioexpander/
|   |-- Kconfig
|   |-- Make.defs
|   `-- <i>(I/O expander and GPIO-related driver source files)</i>
|-- lcd/
|   |-- Kconfig
|   |-- Make.defs
|   `-- <i>(LCD driver source files)</i>
|-- leds/
|   |-- Kconfig
|   |-- Make.defs
|   `-- <i>(LED device driver source files)</i>
|-- loop/
|   |-- Kconfig
|   |-- Make.defs
|   `-- <i>(Loop device driver source files)</i>
|-- mmcsd/
|   |-- Kconfig
|   |-- Make.defs
|   `-- <i>(MMC/SD card driver source files)</i>
|-- modem/
|   |-- Kconfig
|   |-- Make.defs
|   `-- <i>(Modem driver source files)</i>
|-- mtd/
|   |-- Kconfig
|   |-- Make.defs
|   `-- <i>(Memory technology device driver source files)</i>
|-- net/
|   |-- Kconfig
|   |-- Make.defs
|   `-- <i>(Network driver source files)</i>
|-- pipes/
|   |-- Kconfig
|   |-- Make.defs
|   `-- <i>(Pipe and FIFO driver source files)</i>
|-- power/
|   |-- Kconfig
|   |-- Make.defs
|   `-- <i>(Power-related driver source files)</i>
|-- sensors/
|   |-- Kconfig
|   |-- Make.defs
|   `-- <i>(Sensor driver source files)</i>
|-- serial/
|   |-- Kconfig
|   |-- Make.defs
|   `-- <i>(Front-end character drivers for chip-specific UARTs, 16550 UART support, and Pseudo-Terminal support)</i>
|-- spi/
|   |-- Kconfig
|   |-- Make.defs
|   `-- <i>(SPI-related drivers and helper functions)</i>
|-- syslog/
|   |-- Kconfig
|   |-- Make.defs
|   `-- <i>(System logging device support)</i>
|-- timers/
|   |-- Kconfig
|   |-- Make.defs
|   `-- <i>(Timer-based device driver support)</i>
|-- usbdev/
|   |-- Kconfig
|   |-- Make.defs
|   `-- <i>(USB device driver source files)</i>
|-- usbhost/
|   |-- Kconfig
|   |-- Make.defs
|   `-- <i>(USB host driver source files)</i>
|-- usbmisc/
|   |-- Kconfig
|   |-- Make.defs
|   `-- <i>(Miscellaneous USB driver source files)</i>
|-- usbmonitor/
|   |-- Kconfig
|   |-- Make.defs
|   `-- <i>(USB monitor source files)</i>
|-- video/
|   |-- Kconfig
|   |-- Make.defs
|   `-- <i>(Video driver source files)</i>
|-- wireless/
|   |-- Kconfig
|   |-- Make.defs
|   `-- <i>(Wireless driver source files)</i>
`-- <i>(Various uncategorized driver source files)</i>
</pre></ul>

<h2>2.8 <a name="DirStructFs">nuttx/fs</a></h2>

<p>
  This directory contains the NuttX file system.
  This file system is described <a href="#NxFileSystem">below</a>.
</p>
<ul><pre>
fs/
|-- Kconfig
|-- Makefile
|-- binfs/
|   |-- Kconfig
|   |-- Make.defs
|   `-- <i>(BINFS file system source files)</i>
|-- cromfs/
|   |-- Kconfig
|   |-- Make.defs
|   `-- <i>(CROMFS file system source files)</i>
|-- dirent/
|   |-- Kconfig
|   |-- Make.defs
|   `-- <i>(VFS directory access source files)</i>
|-- driver/
|   |-- Kconfig
|   |-- Make.defs
|   `-- <i>(Driver registration OS internal interfaces)</i>
|-- fat/
|   |-- Kconfig
|   |-- Make.defs
|   `-- <i>(FAT file system source files)</i>
|-- inode/
|   |-- Kconfig
|   |-- Make.defs
|   `-- <i>(Pseudo-file system OS internal interfaces)</i>
|-- hostfs/
|   |-- Kconfig
|   |-- Make.defs
|   `-- <i>(HOSTFS file system source files)</i>
|-- mmap/
|   |-- Kconfig
|   |-- Make.defs
|   `-- <i>(RAM-based file mapping source files)</i>
|-- mount/
|   |-- Kconfig
|   |-- Make.defs
|   `-- <i>(Mount point-related OS internal interfaces)</i>
|-- mqueue/
|   |-- Kconfig
|   |-- Make.defs
|   `-- <i>(POSIX message queue OS internal interfaces)</i>
|-- nfs/
|   |-- Kconfig
|   |-- Make.defs
|   `-- <i>(NFS client file system source files)</i>
|-- nxffs/
|   |-- Kconfig
|   |-- Make.defs
|   `-- <i>(NuttX Flash File System (NXFFS) source files)</i>
|-- procfs/
|   |-- Kconfig
|   |-- Make.defs
|   `-- <i>(PROCFS pseudo-file system source files)</i>
|-- romfs/
|   |-- Kconfig
|   |-- Make.defs
|   `-- <i>(ROMFS file system source files)</i>
|-- smartfs/
|   |-- Kconfig
|   |-- Make.defs
|   `-- <i>(SmartFS file system source files)</i>
|-- unionfs/
|   |-- Kconfig
|   |-- Make.defs
|   `-- <i>(UnionFS file system source files)</i>
|-- userfs/
|   |-- Kconfig
|   |-- Make.defs
|   `-- <i>(UserFS file system source files)</i>
|-- vfs/
|   |-- Kconfig
|   |-- Make.defs
|   `-- <i>(VFS OS internal interfaces)</i>
 `-- <i>(common file system source files)</i>
</pre></ul>

<h2>2.9 <a name="DirStructGraphics">nuttx/graphics</a></h2>

<p>
  This directory contains files for graphics/video support under NuttX.
</p>
<ul><pre>
graphics/
|-- Kconfig
|-- Makefile
|-- nxbe/
|   |-- Make.defs
|   `-- <i>(NuttX graphics back-end (NXBE) source files)</i>
|-- nxglib/
|   |-- Make.defs
|   `-- <i>(NuttX graphics library (NXGL) source files)</i>
|-- nxmu/
|   |-- Make.defs
|   `-- <i>(NuttX graphics multi-user (NXMU) server source files)</i>
|-- nxterm/
|   |-- Make.defs
|   `-- <i>(NX terminal (NxTerm) source files)</i>
|-- vnc/
|   |-- Make.defs
|   `-- <i>(VNC client/server source files)</i>
`-- <i>(common file system source files)</i>
</pre></ul>

<h2>2.10 <a name="DirStructInclude">nuttx/include</a></h2>
<p>
  This directory holds NuttX header files.
  Standard header files file retained in can be included in the <i>normal</i> fashion:
</p>
<ul>
  <code>include &lt;stdio.h&gt;</code><br>
  <code>include &lt;sys/types.h&gt;</code><br>
  etc.
</ul>
<p>
  Directory structure:
</p>
<ul><pre>
include/
|-- <i>(standard header files)</i>
|-- arpa/
|   `-- <i>(Standard header files)</i>
|-- cxx/
|   `-- <i>(C++ standard header files)</i>
|-- netinet/
|   `-- <i>(Standard header files)</i>
|-- netpacket/
|   `-- <i>(Protocol-specific header files.  Most non-standard)</i>
|-- nuttx/
|   |-1wire/
|   |  `-- <i>(1-wire driver header files)</i>
|   |-analog/
|   |  `-- <i>(Analog driver header files)</i>
|   |-audio/
|   |  `-- <i>(Audio driver header files)</i>
|   |-binfmt/
|   |  `-- <i>(Binary format header files)</i>
|   |-contactless/
|   |  `-- <i>(Contactless driver header files)</i>
|   |-crypto/
|   |  `-- <i>(Cryptographic support header files)</i>
|   |-drivers/
|   |  `-- <i>(Miscellaneous driver header files)</i>
|   |-eeprom/
|   |  `-- <i>(EEPROM driver header files)</i>
|   |-fs/
|   |  `-- <i>(File System header files)</i>
|   |-i2c/
|   |  `-- <i>(I2C-related header files)</i>
|   |-input/
|   |  `-- <i>(Input device driver header files)</i>
|   |-ioexpander/
|   |  `-- <i>(I/O expander and GPIO driver header files)</i>
|   |-lcd/
|   |  `-- <i>(LCD driver header files)</i>
|   |-leds/
|   |  `-- <i>(LED driver header files)</i>
|   |-lib/
|   |  `-- <i>(Non-standard C library driver header files)</i>
|   |-mm/
|   |  `-- <i>(Memory management header files)</i>
|   |-modem/
|   |  `-- <i>(Modem driver header files)</i>
|   |-mtd/
|   |  `-- <i>(Memory technology device header files)</i>
|   |-net/
|   |  `-- <i>(Networking header files)</i>
|   |-nx/
|   |  `-- <i>(NX graphics header files)</i>
|   |-power/
|   |  `-- <i>(Power management header files)</i>
|   |-sensors/
|   |  `-- <i>(Sensor device driver header files)</i>
|   |-serial/
|   |  `-- <i>(Serial driver header files)</i>
|   |-spi/
|   |  `-- <i>(SPI-related header files)</i>
|   |-syslog/
|   |  `-- <i>(SYSLOG header files)</i>
|   |-timers/
|   |  `-- <i>(Timer-related driver header files)</i>
|   |-usb/
|   |  `-- <i>(USB driver header files)</i>
|   |-video/
|   |  `-- <i>(Video-related driver header files)</i>
|   `-wireless/
|      `-- <i>(Wireless device driver header files)</i>
`- sys/
    `-- <i>(More standard header files)</i>
</pre></ul>

<h2>2.11 <a name="DirStructLib">nuttx</a></h2>

<p>
  This is a (almost) empty directory that has a holding place for generated static libraries.
  The NuttX build system generates a collection of such static libraries in this directory during the compile phase.
  These libraries are then in a known place for the final link phase where they are accessed to generated the final binaries.
</p>

<h2>2.12 <a name="DirStructLibC">nuttx/libs/libc</a></h2>
<p>
  This directory holds a collection of standard libc-like functions with custom
  interfaces into NuttX.
</p>
<p>
  Normally the logic in this file builds to a single library (<code>libc.a</code>).
  However, if NuttX is built as a separately compiled kernel (with <code>CONFIG_BUILD_PROTECTED=y</code> or <code>CONFIG_BUILD_KERNEL=y</code>), then the contents of this directory are built as two libraries:
  One for use by user programs (<code>libc.a</code>) and one for use only within the &lt;kernel&gt; space (<code>libkc.a</code>).
</p>
<p>
  These user/kernel space libraries (along with the sycalls of <a href="#DirStructSyscall"><code>nuttx/syscall</code></a>) are needed to support the two differing protection domains.
</p>
<p>
  Directory structure:
</p>
<ul><pre>
libc/
|-- aio/
|   `-- <i>(Implementation of functions from aio.h)</i>
|-- audio/
|   `-- <i>(Implementation of audio-related functions)</i>
|-- dirent/
|   `-- <i>(Implementation of functions from dirent.h)</i>
|-- dllfch/
|   `-- <i>(Implementation of functions from dlfcn.h)</i>
|-- fixedmath/
|   `-- <i>(Implementation of functions from fixedmath.h)</i>
|-- hex2bin/
|   `-- <i>(Implementation of functions from hex2bin.h)</i>
|-- inttypes/
|   `-- <i>(Implementation of functions from inttypes.h)</i>
|-- libgen/
|   `-- <i>(Implementation of functions from libgen.h)</i>
|-- locale/
|   `-- <i>(Implementation of functions from locale.h)</i>
|-- lzf/
|   `-- <i>(Implementation of functions from lzf.h)</i>
|-- machine/
|   `-- <i>(Implementations of platform-specific logic)</i>
|-- math/
|   `-- <i>(Implementation of functions from fixedmath.h)</i>
|-- misc/
|   `-- <i>(Implementation of miscellaneous library functions)</i>
|-- modlib/
|   `-- <i>(Implementation of functions from nuttx/lib/modlib.h)</i>
|-- net/
|   `-- <i>(Implementation of network-related library functions)</i>
|-- netdb/
|   `-- <i>(Implementation of functions from netdb.h)</i>
|-- pthread/
|   `-- <i>(Implementation of functions from pthread.h)</i>
|-- queue/
|   `-- <i>(Implementation of functions from queue.h)</i>
|-- sched/
|   `-- <i>(Implementation of some functions from sched.h)</i>
|-- semaphore/
|   `-- <i>(Implementation of some functions from semaphore.h)</i>
|-- signal/
|   `-- <i>(Implementation of some functions from signal.h)</i>
|-- spawn/
|   `-- <i>(Implementation of some functions from spawn.h)</i>
|-- stdio/
|   `-- <i>(Implementation of functions from stdio.h)</i>
|-- stdlib/
|   `-- <i>(Implementation of functions from stdlib.h)</i>
|-- string/
|   `-- <i>(Implementation of functions from string.h)</i>
|-- symtab/
|   `-- <i>(Implementation of symbol-table library functions)</i>
|-- syslog/
|   `-- <i>(Implementation of functions from syslog.h)</i>
|-- termios/
|   `-- <i>(Implementation of functions from termios.h)</i>
|-- time/
|   `-- <i>(Implementation of some functions from time.h)</i>
|-- tls/
|   `-- <i>(Implementation of some functions from tls.h)</i>
|-- uio/
|   `-- <i>(Implementation of some functions from uio.h)</i>
|-- unistd/
|   `-- <i>(Implementation of some functions from unistd.h)</i>
|-- userfs/
|   `-- <i>(Implementation of application side internals of UserFS)</i>
|-- wchar/
|   `-- <i>(Implementation of some functions from wchar.h.  Not fully functional.)</i>
|-- wctype/
|   `-- <i>(Implementation of some functions from wctype.h.  Not fully functional.)</i>
|-- wqueue/
|   `-- <i>(Implementation of some functions from wqueue.h)</i>
`-- zoneinfo/
    `-- <i>(Implementation of timezone database)</i>

</pre></ul>

<h2>2.13 <a name="DirStructLibXX">nuttx/libs/libxx</a></h2>
<p>
  This directory holds a tiny, minimal standard std C++ that can be used to
  build some, simple C++ applications in NuttX.
</p>

<h2>2.14 <a name="DirStructMm">nuttx/mm</a></h2>
<p>
  This is the NuttX memory manager.
</p>

<h2>2.15 <a name="DirStructNet">nuttx/net</a></h2>
<p>
  This directory contains the implementation of the NuttX networking layer including internal socket APIs.
</P>

<h2>2.16 <a name="DirStructSched">nuttx/sched</a></h2>
<p>
  The files forming core of the NuttX RTOS reside here.
</p>

<h2>2.17 <a name="DirStructSyscall">nuttx/syscall</a></h2>
<p>
  If NuttX is built as a separately compiled kernel (with <code>CONFIG_BUILD_PROTECTED=y</code> or <code>CONFIG_BUILD_KERNEL=y</code>),
  then the contents of this directory are built.
  This directory holds a syscall interface that can be used for communication
  between user-mode applications and the kernel-mode RTOS.
</p>

<h2>2.18 <a name="DirStructTools">nuttx/tools</a></h2>
<p>
  This directory holds a collection of tools and scripts to simplify
  configuring, building and maintaining NuttX.
</p>
<ul><pre>
tools/
|-- Makefile.host
|-- Makefile.export
|-- Makefile.unix, Makefile.win, FlatLibs.mk, KernelLibs.mk, LibTargets.mk, ProtectedLibs.mk
|-- README.txt
|-- b16.c
|-- bdf-converter.c
|-- cfgparser.c
|-- cfgparser.h
|-- cmpconfig.c
|-- cnvwindeps.c
|-- configure.sh / configure.bat / configure.c
|-- copydir.sh / copydir.bat
|-- define.sh / define.bat
|-- discovery.py
|-- incdir.sh / incdir.bat
|-- indent.sh
|-- initialconfig.c
|-- kconfig2html.c / mkconfigvars.sh
|-- link.sh / link.bat
|-- mkconfig.c
|-- mkctags.sh
|-- mkdeps.c
|-- mkexport.sh
|-- mkfsdata.pl
|-- mknulldeps.sh
|-- mkromfsimg.sh
|-- mksymtab.c
|-- mksyscall.c
|-- mkversion.c
|-- mkwindeps.sh
|-- noteinfo.c
|-- nxstyle.c
|-- pic32mx/mkpichex.c
|-- refresh.sh
|-- sethost.sh
|-- showsize.sh
|-- testbuild.sh
|-- uncrustify.cfg
|-- unlink.sh / unlink.bat
|-- version.sh
|-- xmlrpc_test.py
`-- zipme.sh
</pre></ul>

<p>
  Refer to the README file in the <code>tools</code> directory for more information about the individual files.
  Some of these tools are discussed below as well in the discussion of <a href="#configandbuild">configuring and building</a> NuttX.
</p>

<h2>2.19 <a name="DirStructWireless">nuttx/wireless</a></h2>

<p>
  This directory holds support for hardware-independent wireless support.
</p>

<h2>2.20 <a name="topmakefile">nuttx/Makefile</a></h2>
<p>
  The top-level <code>Makefile</code> in the <code>$(TOPDIR)</code> directory contains all of the top-level control
  logic to build NuttX.
  Use of this <code>Makefile</code> to build NuttX is described <a href="#buildingnuttx">below</a>.
</p>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
    <td>
      <h1>3.0 <a name="configandbuild">Configuring and Building</a></h1>
    </td>
  </tr>
</table>

<h2><a name="configuringnuttx">3.1 Configuring NuttX</a></h2>
<p>
  <b>Manual Configuration</b>.
  Configuring NuttX requires only copying the
  <a href="#boardconfigsubdirs">board-specific configuration files</a> into the top level directory which appears in the make files as the make variable, <code>$(TOPDIR)</code>.
  This could be done manually as follows:
</p>
<ul>
  <li>Copy <code>boards/</code><i>&lt;arch-name&gt;</i><code>/</code><i>&lt;chip-name&gt;</i><code>/</code><i>&lt;board-name&gt;</i><code>/configs/[</code><i>&lt;config-dir&gt;</i><code>/]Make.defs</code> to <code>$(TOPDIR)/Make.defs</code> (see NOTE below),</li>
  <li>Copy <code>boards/</code><i>&lt;arch-name&gt;</i><code>/</code><i>&lt;chip-name&gt;</i><code>/</code><i>&lt;board-name&gt;</i><code>/configs/[</code><i>&lt;config-dir&gt;</i><code>/]defconfig</code> to <code>$(TOPDIR)/.config</code></li>
</ul>

<p>
  Where <i>&lt;board-name&gt;</i> is the name of one of the sub-directories of the
  NuttX <a href="#DirStructConfigs"><code>boards/</code></a> directory.
  This sub-directory name corresponds to one of the supported boards
  identified <a href="#supportedboards">above</a>.
  &lt;config-dir&gt; is the optional, specific configuration directory for the board.
  And &lt;app-dir&gt; is the location of the optional application directory.
</p>
<p>
  NOTE:  Recall that the <code>Make.defs</code> file may reside in either the <code>boards/</code><i>&lt;arch-name&gt;</i><code>/</code><i>&lt;chip-name&gt;</i><code>/</code><i>&lt;board-name&gt;</i>/<code>configs/[</code><i>&lt;config-dir&gt;</i></code> directory or in the <code>boards/</code><i>&lt;arch-name&gt;</i><code>/</code><i>&lt;chip-name&gt;</i><code>/</code><i>&lt;board-name&gt;</i>/<code>scripts</code>.
</p>
<p>
  <b>Automated Configuration</b>.
  There is a script that automates these steps.  The following steps will
  accomplish the same configuration:
</p>
<ul><pre>
  tools/configure.sh [OPTIONS] <i>&lt;board-name&gt;</i>[:<i>&lt;config-dir&gt;</i>]
</pre></ul>

<p>
  There is an alternative Windows batch file, <code>configure.bat</code>,  that can be used instead of <code>configure.sh</code> in the windows native environment like:
</p>
<ul><pre>
  tools\configure.bat <i>&lt;board-name&gt;</i>:<i>&lt;config-dir&gt;</i>
</pre></ul>
<p>
  And, to make sure that other platforms are supported, there is also a C program at <code>tools/configure.c</code> that can be compiled to establish the board configuration on all platforms.
</p>
<p><blockquote><small>
  NOTE (2019-08-6):  As of this writing, changes to the boards/ directly have made <code>configure.bat</code> unusable.
  For the native Windows environment, <code>configure.c</code> is recommended until that batch file can be repaired.
</small></blockquote></p>
<p>
  See <code>tools/README.txt</code> for more information about these scripts.
  Or use the -h option with <code>configure.sh></code>
</p>
<ul><pre>
$ tools/configure.sh -h

USAGE: tools/configure.sh [-d] [-l|m|c|u|g|n] [-a &lt;app-dir&gt;] &lt;board-name&gt;[:&lt;config-name&gt;]

Where:
  -l selects the Linux (l) host environment.
  -m selects the macOS (m) host environment.
  -c selects the Windows host and Cygwin (c) environment.
  -u selects the Windows host and Ubuntu under Windows 10 (u) environment.
  -g selects the Windows host and MinGW/MSYS environment.
  -n selects the Windows host and Windows native (n) environment.
  Default: Use host setup in the defconfig file
  Default Windows: Cygwin
  &lt;board-name&gt; is the name of the board in the <code>boards/</code> directory
  &lt;config-name&gt; is the name of the board configuration sub-directory
  &lt;app-dir&gt; is the path to the apps/ directory, relative to the nuttx
     directory
</pre></ul>

<p>
  If your application directory is not in the standard location (<code>../apps</code> or <code>../apps-&lt;version&gt;</code>),
  then you should also specify the location of the application directory on the command line like:
</p>
<ul><pre>
  tools/configure.sh -a &lt;app-dir&gt; <i>&lt;board-name&gt;</i>[:<i>&lt;config-dir&gt;</i>]
</pre></ul>

<p>
  <b>Version Files</b>.
  The NuttX build expects to find a version file located in the top-level NuttX build directory.
  That version file is called <code>.version</code>.
  The correct version file is installed in each versioned NuttX released.
  However, if you are working from an GIT snapshot, then there will be no version file.
  If there is no version file, the top-level <code>Makefile</code> will create a dummy <code>.version</code> file on the first make.
  This dummy version file will contain all zeroes for version information.
  If that is not what you want, they you should run the <code>version.sh</code> script to create a better <code>.version</code> file.
</p>

<p>
  You can get help information from the <code>version.sh</code> script using the <code>-h</code> option.
  For example:
</p>
<ul><pre>
$ tools/version.sh -h
tools/version.sh is a tool for generation of proper version files for the NuttX build

USAGE: tools/version.sh [-d|-h] [-b &lt;build&gt;] -v &lt;major.minor&gt; &lt;outfile-path&gt;

Where:
        -b <build>
                Use this build identification string.  Default: use GIT build ID
                NOTE: GIT build information may not be available in a snapshot
        -d
                Enable script debug
        -h
                show this help message and exit
        -v <major.minor>
        -v &lt;major.minor&gt;
                The NuttX version number expressed as a major and minor number separated
                by a period
        &lt;outfile-path&gt;
                The full path to the version file to be created
</pre></ul>

<p>
  As an example, the following command will generate a version file for version 6.1 using the current GIT revision number:
</p>
<ul><pre>
tools/version.h -v 6.1 .version
</pre></ul>

<p>
  The <code>.version</code> file is also used during the build process to create a C header file at <code>include/nuttx/version.h</code> that contains the same version information.
  That version file may be used by your C applications for, as an example, reporting version information.
</p>

<p>
  <b>Additional Configuration Steps</b>.
  The remainder of configuration steps will be performed by <a href="#topmakefile"><code>$(TOPDIR)/Makefile</code></a>
  the first time the system is built as described below.
</p>

<h2><a name="buildingnuttx">3.2 Building NuttX</a></h2>
<p>
  <b>Building NuttX</b>.
   Once NuttX has been configured as described <a href="#configuringnuttx">above</a>, it may be built as follows:
</p>
<ul><pre>
cd $(TOPDIR)
make
</pre></ul>
<p>
  The <code>$(TOPDIR)</code> directory holds:
</p>
<ul>
  <li>The top level <a href="#topmakefile"><code>Makefile</code></a> that controls the NuttX build.
</ul>
<p>
  That directory also holds:
</p>
<ul>
  <li>The makefile fragment <a href="#boardconfigsubdirs"><code>.config</code></a> that describes the current configuration, and</li>
  <li>The makefile fragment <a href="#boardconfigsubdirs"><code>Make.defs</code></a> that provides customized build targets.</li>
</ul>
<p>
<b>Environment Variables</b>.
The specific environmental definitions are unique for each board but should include, as a minimum, updates to the <code>PATH</code> variable to include the full path to the architecture-specific toolchain identified in <a href="#boardconfigsubdirs"><code>Make.defs</code></a>.
</p>
<p>
  <b>First Time Make.</b>
  Additional configuration actions will be taken the first time that system is built.
  These additional steps include:
</p>
<ul>
  <li>Auto-generating the file <code>include/nuttx/config.h</code> using the <code>$(TOPDIR)/.config</code> file.</li>
  <li>Auto-generating the file  <code>$(TOPDIR)/.version</code> with version 0.0 if one does not exist.</li>
  <li>Auto-generating the file <code>include/nuttx/version.h</code> using the <code>$(TOPDIR)/.version</code> file.</li>
  <li>Creating a link to <code>$(TOPDIR)/arch/</code><i>&lt;arch-name&gt;</i><code>/include</code> at <code>$(TOPDIR)/include/arch</code>.</li>
  <li>Creating a link to <code>$(TOPDIR)/boards/</code><i>&lt;arch-name&gt;</i><code>/</code><i>&lt;chip-name&gt;</i><code>/</code><i>&lt;board-name&gt;</i><code>/include</code> at <code>$(TOPDIR)/include/arch/board</code>.</li>
  <li>Creating a link to <code>$(TOPDIR)/boards/</code><i>&lt;arch-name&gt;</i><code>/</code><i>&lt;chip-name&gt;</i><code>/</code><i>&lt;board-name&gt;</i><code>/src</code> at <code>$(TOPDIR)/arch/</code><i>&lt;arch-name&gt;</i><code>/src/board</code></li>
  <li>Creating a link to <code>${APPDIR}/include</code> at <code>$(TOPDIR)/include/apps</code></li>
  <li>Creating make dependencies.
</ul>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
    <td>
      <h1>4.0 <a name="ArchAPIs">Architecture APIs</a></h1>
    </td>
  </tr>
</table>

<p>
  The file <code>include/nuttx/arch.h</code> identifies by prototype all of the APIs that must
  be provided by the architecture specific logic.
  The internal OS APIs that architecture-specific logic must
  interface with also also identified in <code>include/nuttx/arch.h</code> or in
  other header files.
</p>

<h2><a name="naming">4.1 Naming and Header File Conventions</a></h2>

<ul>
  <li>
    <p>
      <b>Common Microprocessor Interfaces</b>.
      Any interface that is common to all microprocessors should be prefixed with <code>up_</code> and prototyped in <code>include/nuttx/arch.h</code>.
      The definitions in that header file provide the common interface between NuttX and the architecture-specific implementation in <code>arch/</code>.
    </p>
    <blockquote><small>
      <code>up_</code> is supposed to stand for microprocessor; the <code>u</code> is like the Greek letter micron: <i>ľ</i>.    So it would be <code>ľP</code> which is a common shortening of the word microprocessor.  I don't like that name very much.  I wish I would have used a more obvious prefix like <code>arch_</code> instead -- then I would not have to answer this question so often.
    </small></blockquote>
  </li>
  <li>
    <p>
      <b>Microprocessor-Specific Interfaces</b>.
      An interface which is unique to a certain microprocessor should be prefixed with the name of the microprocessor, for example <code>stm32_</code>, and be prototyped in some header file in the <code>arch/</code> directories.
    </p>
    <p>
      There is also a <code>arch/&lt;architecture&gt;/include/&lt;chip&gt;/chip.h</code> header file that can be used to communicate other microprocessor-specific information between the board logic and even application logic.
      Application logic may, for example, need to know specific capabilities of the chip.
      Prototypes in that <code>chip.h</code> header file should follow the microprocessor-specific naming convention.
    </p>
  </li>
  <li>
    <p>
      <b>Common Board Interfaces</b>.
      Any interface that is common to all boards should be prefixed with <code>board_</code> and should also be prototyped in <code>include/nuttx/board.h</code>.
      These <code>board_</code> definitions provide the interface between the board-level logic and the commaon and architecture-specific logic.
    </p>
  <li>
    <p>
      <b>Board-Specific Interfaces</b>.
      Any interface which is unique to a board should be prefixed with the board name, for example <code>stm32f4discovery_</code>.
      Sometimes the board name is too long so <code>stm32_</code> would be okay too.
      These should be prototyped in <code>boards/&lt;arch&gt;/&lt;chip&gt;/&lt;board&gt;/src/&lt;board&gt;.h</code> and should not be used outside of that directory since board-specific definitions have no meaning outside of the board directory.
  </li>
  <li>
    <p>
      <b>Scope of Inclusions</b>.
      Header files are made accessible to internal OS logic and to applications through symbolic links and through <i>include paths</i> that are provided to the C/C++ compiler.
      Through these include paths, the NuttX build system also enforces modularity in the design.
      For example, one important design principle is architectural <i>layering</i>.
      In this case I am referring to the OS as layered into application interface, common internal OS logic, and lower level platform-specific layers.
      The platform-specific layers all reside in the either <code>arch/</code> sub-directories on the <code>config/</code> subdirectories:  The former sub-directories are reserved for microcontroller-specific logic and the latter for board-specific logic.
    </p>
    <p>
      In the strict, layered NuttX architecture, the upper level OS services are always available to platform-specific logic.  However, the opposite is <i>not</i> true:  Common OS logic must never have any dependency on the lower level platform-specific code.  The OS logic must be totally agnostic about its hardware environment.  Similarly, microcontroller-specific logic was be completely ignorant of board-specific logic.
    </p>
    <p>
      This strict layering is enforced in the NuttX build system by controlling the compiler include paths:  Higher level code can never include header files from either; of the platform-specific source directories;  microcontroller-specific code can never include header files from the board-specific source directories.  The board-specific directories are, then, at the bottom of the layered hierarchy.
    </p>
    <p>
      An exception to these inclusion restrictions is the platform-specific <i>include/</i>.  These are made available to higher level OS logic.  The microcontroller-specific include directory will be linked at <code>include/arch/chip</code> and, hence, can be included like <code>#include &lt;arch/hardware/chip.h</code>.
      Similarly, the board-specific include directory will be linked at <code>include/arch/board</code> and, hence, can be included like <code>#include &lt;arch/board/board.h</code>.
    </p>
    <p>
      Keeping in the spirit of the layered architecture, these publicly visible header files must <i>not</i> export platform-specific definitions; Only platform-specific realizations of standardized declarations should be visible.
      Those <i>standardized declarations</i> should appear in common header files such as those provided by <code>include/nuttx/arch.h</code> and <code>include/nuttx/board.h</code>.
      Similarly, these publicly visible header file must <i>not</i> include files that reside in the inaccessible platform-specific source directories.
      For example, the board-specific <code>boards/&lt;arch&gt;/&lt;chip&gt;/&lt;board&gt;/include/board.h</code> header file must never include microcontroller-specific header files that reside in <code>arch/&lt;arch&gt;/src/&lt;mcu&gt;</code>.
      That practice will cause inclusion failures when the publicly visible file is included in common logic outside of the platform-specific source directories.
    </p>
  </li>
</ul>

<h2><a name="imports">4.2 APIs Exported by Architecture-Specific Logic to NuttX</a></h2>
<h3><a name="upinitialize">4.2.1 <code>up_initialize()</code></a></h3>

<p><b>Function Prototype</b>: <code>void up_initialize(void);</code></p>

<p><b>Description</b>.
  <code>up_initialize()</code> will be called once during OS
  initialization after the basic OS services have been
  initialized.  The architecture specific details of
  initializing the OS will be handled here.  Such things as
  setting up interrupt service routines, starting the
  clock, and registering <a href="#DeviceDrivers">device drivers</a> are some of the
  things that are different for each processor and hardware
  platform.
</p>
<p>
  <code>up_initialize()</code> is called after the OS initialized but
  before the init process has been started and before the
  libraries have been initialized.  OS services and driver
  services are available.
</p>

<h3><a name="upidle">4.2.2 <code>up_idle()</code></a></h3>
<p><b>Function Prototype</b>: <code>void up_idle(void);</code></p>

<p><b>Description</b>.
  <code>up_idle()</code> is the logic that will be executed
  when their is no other ready-to-run task.  This is processor
  idle time and will continue until some interrupt occurs to
  cause a context switch from the idle task.
</p>
<p>
  Processing in this state may be processor-specific. e.g.,
  this is where power management operations might be performed.
</p>

<h3><a name="upinitialstate">4.2.3 <code>up_initial_state()</code></a></h3>
<p><b>Function Prototype</b>: <code>void up_initial_state(FAR struct tcb_s *tcb);</code></p>

<p><b>Description</b>.
  A new thread is being started and a new TCB has been created.
  This function is called to initialize the processor specific portions of the new TCB.
</p>
<p>
  This function must setup the initial architecture registers and/or stack so that execution
  will begin at tcb->start on the next context switch.
</p>
<p>
  This function may also need to set up processor registers so that the new thread executes
  with the correct privileges.
  If <code>CONFIG_BUILD_PROTECTED</code> or <code>CONFIG_BUILD_KERNEL</code> have been selected in the NuttX configuration, then special initialization may need to be performed depending on the task type specified in the TCB's flags field:
  Kernel threads will require kernel-mode privileges;
  User tasks and pthreads should have only user-mode privileges.
  If neither <code>CONFIG_BUILD_PROTECTED</code> nor <code>CONFIG_BUILD_KERNEL</code> have been selected, then all threads should have kernel-mode privileges.
</p>

<h3><a name="upcreatestack">4.2.4 <code>up_create_stack()</code></a></h3>
<p><b>Function Prototype</b>: <code>STATUS up_create_stack(FAR struct tcb_s *tcb, size_t stack_size, uint8_t ttype);</code></p>

<p><b>Description</b>.
  Allocate a stack for a new thread and setup up stack-related information in the TCB.
</p>
<p>
  The following TCB fields must be initialized:
</p>
<ul>
  <li><code>adj_stack_size</code>: Stack size after adjustment for hardware,
    processor, etc.  This value is retained only for debug
    purposes.</li>
  <li><code>stack_alloc_ptr</code>: Pointer to allocated stack</li>
  <li><code>adj_stack_ptr</code>: Adjusted <code>stack_alloc_ptr</code> for HW.  The
    initial value of the stack pointer.
</ul>

<p><b>Input Parameters</b>:</p>
<ul>
  <li>
    <p>
      <code>tcb</code>: The TCB of new task.
    </p>
  </li>
  <li>
    <p>
      <code>stack_size</code>:  The requested stack size.  At least this much must be allocated.
    </p>
  </li>
  <li>
    <p>
      <code>ttype</code>:  The thread type.
      This may be one of following (defined in <code>include/nuttx/sched.h</code>):
    </p>
    <ul>
      <li><code>TCB_FLAG_TTYPE_TASK</code>: Normal user task</li>
      <li><code>TCB_FLAG_TTYPE_PTHREAD</code>: User pthread</li>
      <li><code>TCB_FLAG_TTYPE_KERNEL</code>: Kernel thread</li>
    </ul>
    <p>
      This thread type is normally available in the flags field of the TCB, however, there are certain contexts where the TCB may not be fully initialized when up_create_stack is called.
    </p>
    <p>
      If <code>CONFIG_BUILD_PROTECTED</code> or <code>CONFIG_BUILD_KERNEL</code> are defined, then this thread type may affect how the stack is allocated.  For example, kernel thread stacks should be allocated from protected kernel memory.  Stacks for user tasks and threads must come from memory that is accessible to user code.
    </p>
  </li>
</ul>

<h3><a name="upusestack">4.2.5 <code>up_use_stack()</code></a></h3>
<p><b>Function Prototype</b>:
  <code>STATUS up_use_stack(FAR struct tcb_s *tcb, FAR void *stack, size_t stack_size);</code>
</p>

<p><b>Description</b>.
  Setup up stack-related information in the TCB using pre-allocated stack memory.
  This function is called only from <code>nxtask_init()</code> when a task or kernel thread is started (never for pthreads).
</p>
<p>
  The following TCB fields must be initialized:
</p>
<ul>
  <li><code>adj_stack_size</code>: Stack size after adjustment for hardware,
    processor, etc.  This value is retained only for debug
    purposes.</li>
  <li><code>stack_alloc_ptr</code>: Pointer to allocated stack</li>
  <li><code>adj_stack_ptr</code>: Adjusted <code>stack_alloc_ptr</code> for HW.  The
    initial value of the stack pointer.
</ul>

<p><b>Input Parameters:</b></p>
<ul>
  <li>
    <code>tcb</code>: The TCB of new task.
  </li>
  <li>
    <code>stack_size</code>:  The allocated stack size.
  </li>
</ul>
<p>
  NOTE:  Unlike <code>up_stack_create()</code> and <code>up_stack_release</code>, this function does not require the task type (<code>ttype</code>) parameter.
  The TCB flags will always be set to provide the task type to <code>up_use_stack()</code> if the information needs that information.
</p>


<h3><a name="upstackframe">4.2.6 <code>up_stack_frame()</code></a></h3>
<p><b>Function Prototype</b>: <code>FAR void *up_stack_frame(FAR struct tcb_s *tcb, size_t frame_size);</code></p>

<p>
  <b>Description</b>.
  Allocate a stack frame in the TCB's stack to hold thread-specific data.
  This function may be called any time after <code>up_create_stack()</code> or <code>up_use_stack()</code> have been called but before the task has been started.
</p>
<p>
  Thread data may be kept in the stack (instead of in the TCB) if it is accessed by the user code directly.
  This includes such things as <code>argv[]</code>.
  The stack memory is guaranteed to be in the same protection domain as the thread.
</p>
<p>
  The following TCB fields will be re-initialized:
</p>
<ul>
  <li>
    <code>adj_stack_size</code>: Stack size after removal of the stack frame from the stack.
  </li>
  <li>
    <code>adj_stack_ptr</code>: Adjusted initial stack pointer after the frame has been removed from the stack.
    This will still be the initial value of the stack pointer when the task is started.
  </li>
</ul>
<p><b>Input Parameters:</b></p>
<ul>
  <li>
    <p>
      <code>tcb</code>:
      The TCB of new task.
    </p>
  </li>
  <li>
    <p>
      <code>frame_size</code>:
      The size of the stack frame to allocate.
    </p>
  </li>
</ul>
<p>
  <b>Returned Value:</b>
   A pointer to bottom of the allocated stack frame.
   NULL will be returned on any failures.
   The alignment of the returned value is the same as the alignment of the stack itself
</p>

<h3><a name="upreleasestack">4.2.7 <code>up_release_stack()</code></a></h3>
<p><b>Function Prototype</b>: <code>void up_release_stack(FAR struct tcb_s *dtcb);</code></p>

<p><b>Description</b>.
  A task has been stopped.
  Free all stack related resources retained int the defunct TCB.
</p>
<p><b>Input Parameters:</b></p>
<ul>
  <li>
    <p>
      <code>dtcb</code>:
      The TCB containing information about the stack to be released.
    </p>
  </li>
  <li>
    <p>
      <code>ttype</code>:  The thread type.
      This may be one of following (defined in <code>include/nuttx/sched.h</code>):
    </p>
    <ul>
      <li><code>TCB_FLAG_TTYPE_TASK</code>: Normal user task</li>
      <li><code>TCB_FLAG_TTYPE_PTHREAD</code>: User pthread</li>
      <li><code>TCB_FLAG_TTYPE_KERNEL</code>: Kernel thread</li>
    </ul>
    <p>
      This thread type is normally available in the flags field of the TCB, however, there are certain error recovery contexts where the TCB may not be fully initialized when up_release_stack is called.
    </p>
    <p>
      If <code>CONFIG_BUILD_PROTECTED</code> or <code>CONFIG_BUILD_KERNEL</code> are defined, then this thread type may affect how the stack is freed.
      For example, kernel thread stacks may have been allocated from protected kernel memory.
      Stacks for user tasks and threads must have come from memory that is accessible to user
    </p>
  </li>
</ul>

<h3><a name="upunblocktask">4.2.8 <code>up_unblock_task()</code></a></h3>
<p><b>Function Prototype</b>: <code>void up_unblock_task(FAR struct tcb_s *tcb);</code></p>

<p><b>Description</b>.
  A task is currently in an inactive task list
  but has been prepped to execute.  Move the TCB to the
  ready-to-run list, restore its context, and start execution.
</p>
<p>
  This function is called only from the NuttX scheduling
  logic.  Interrupts will always be disabled when this
  function is called.
</p>

<p><b>Input Parameters</b>:
<ul>
  <li><code>tcb</code>: Refers to the tcb to be unblocked.  This tcb is
    in one of the waiting tasks lists.  It must be moved to
    the ready-to-run list and, if it is the highest priority
    ready to run tasks, executed.
  </li>
</ul>

<h3><a name="upblocktask">4.2.9 <code>up_block_task()</code></a></h3>
<p><b>Function Prototype</b>: <code>void up_block_task(FAR struct tcb_s *tcb, tstate_t task_state);</code></p>

<p><b>Description</b>.
  The currently executing task at the head of
  the ready to run list must be stopped.  Save its context
  and move it to the inactive list specified by task_state.

  This function is called only from the NuttX scheduling
  logic.  Interrupts will always be disabled when this
  function is called.

<p><b>Input Parameters:</b></p>
<ul>
  <li><code>tcb</code>: Refers to a task in the ready-to-run list (normally
    the task at the head of the list).  It must be stopped, its context saved
    and moved into one of the waiting task lists.  If it was the task at the
    head of the ready-to-run list, then a context switch to the new ready to
    run task must be performed.
  </li>
  <li><code>task_state</code>: Specifies which waiting task list should be
    hold the blocked task TCB.
  </li>
</ul>

<h3><a name="upreleasepending">4.2.10 <code>up_release_pending()</code></a></h3>
<p><b>Function Prototype</b>: <code>void up_release_pending(void);</code></p>

<p><b>Description</b>.
  When tasks become ready-to-run but cannot run because pre-emption
  is disabled, they are placed into a pending task list.
  This function releases and makes ready-to-run all of the tasks that have
  collected in the pending task list.  This can cause a
  context switch if a new task is placed at the head of
  the ready to run list.
</p>
<p>
  This function is called only from the NuttX scheduling logic when
  pre-emption is re-enabled.  Interrupts will always be disabled when this
  function is called.
</p>

<h3><a name="upreprioritizertr">4.2.11 <code>up_reprioritize_rtr()</code></a></h3>
<p><b>Function Prototype</b>: <code>void up_reprioritize_rtr(FAR struct tcb_s *tcb, uint8_t priority);</code></p>

<p><b>Description</b>.
  Called when the priority of a running or
  ready-to-run task changes and the reprioritization will
  cause a context switch.  Two cases:
</p>
<ol>
  <li>
    The priority of the currently running task drops and the next
    task in the ready to run list has priority.
  </li>
  <li>
    An idle, ready to run task's priority has been raised above the
    the priority of the current, running task and it now has the
    priority.
  </li>
</ol>
<p>
  This function is called only from the NuttX scheduling
  logic.  Interrupts will always be disabled when this
  function is called.
</p>

<p><b>Input Parameters:</b></p>
<ul>
  <li>
    <code>tcb</code>: The TCB of the task that has been reprioritized
  </li>
  <li>
    <code>priority</code>: The new task priority
  </li>
</ul>

<h3><a name="up_exit">4.2.12 <code>up_exit()</code></a></h3>
<p><b>Function Prototype</b>: <code>void up_exit(int status) noreturn_function;</code></p>

<p><b>Description</b>.
  This function causes the currently executing task to cease
  to exist.  This is a special case of task_delete().
</p>
<p>
  Unlike other UP APIs, this function may be called
  directly from user programs in various states.  The
  implementation of this function should disable interrupts
  before performing scheduling operations.
</p>

<h3><a name="upassert">4.2.13 <code>up_assert()</code></a></h3>
<p><b>Function Prototype</b>:<br>
  <code>void up_assert(FAR const char *filename, int linenum);</code>
</p>

<p><b>Description</b>.
  Assertions may be handled in an architecture-specific way.
</p>

<h3><a name="upschedulesigaction">4.2.14 <code>up_schedule_sigaction()</code></a></h3>
<p><b>Function Prototype</b>:
  <code>void up_schedule_sigaction(FAR struct tcb_s *tcb, sig_deliver_t sigdeliver);</code>
</p>

<p><b>Description</b>.
  This function is called by the OS when one or more
  signal handling actions have been queued for execution.
  The architecture specific code must configure things so
  that the 'sigdeliver' callback is executed on the thread
  specified by 'tcb' as soon as possible.
</p>
<p>
  This function may be called from interrupt handling logic.
</p>
<p>
  This operation should not cause the task to be unblocked
  nor should it cause any immediate execution of sigdeliver.
  Typically, a few cases need to be considered:
</p>
<ol>
  <li>
    This function may be called from an interrupt handler
    During interrupt processing, all xcptcontext structures
    should be valid for all tasks.  That structure should
    be modified to invoke sigdeliver() either on return
    from (this) interrupt or on some subsequent context
    switch to the recipient task.
  </li>
  <li>
    If not in an interrupt handler and the tcb is NOT
    the currently executing task, then again just modify
    the saved xcptcontext structure for the recipient
    task so it will invoke sigdeliver when that task is
    later resumed.
  </li>
  <li>
    If not in an interrupt handler and the tcb IS the
    currently executing task -- just call the signal
    handler now.
  </li>
</ol>

<h3><a name="upallocateheap">4.2.15 <code>up_allocate_heap()</code></a></h3>
<p><b>Function Prototype</b>: <code>void up_allocate_heap(FAR void **heap_start, size_t *heap_size);</code></p>

<p><b>Description</b>.
  This function will be called to dynamically set aside the heap region.
</p>
<p>
  For the kernel build (<code>CONFIG_BUILD_PROTECTED=y</code> or <code>CONFIG_BUILD_KERNEL=y</code>) with both kernel- and user-space heaps (<code>CONFIG_MM_KERNEL_HEAP=y</code>), this function provides the size of the unprotected, user-space heap.
  If a protected kernel-space heap is provided, the kernel heap must be allocated (and protected) by an analogous <code>up_allocate_kheap()</code>.
</p>

<h3><a name="upinterruptcontext">4.2.16 <code>up_interrupt_context()</code></a></h3>
<p><b>Function Prototype</b>: <code>bool up_interrupt_context(void)</code></p>

<p><b>Description</b>.
  Return true if we are currently executing in the interrupt handler context.
</p>

<h3><a name="updisableirq">4.2.17 <code>up_disable_irq()</code></a></h3>
<p><b>Function Prototype</b>:</p>
<ul><pre>
#ifndef CONFIG_ARCH_NOINTC
  void up_disable_irq(int irq);
#endif
</pre></ul>

<p><b>Description</b>.
  Disable the IRQ specified by 'irq'
  On many architectures, there are three levels of interrupt enabling: (1)
  at the global level, (2) at the level of the interrupt controller,
  and (3) at the device level.  In order to receive interrupts, they
  must be enabled at all three levels.
</p>
<p>
  This function implements enabling of the device specified by 'irq'
  at the interrupt controller level if supported by the architecture
  (up_irq_save() supports the global level, the device level is hardware
  specific).
<p>
  If the architecture does not support <code>up_disable_irq</code>,
  <code>CONFIG_ARCH_NOINTC</code> should be defined in the NuttX configuration file.
  Since this API cannot be supported on all architectures, it should be
  avoided in common implementations where possible.
</p>

<h3><a name="upenableirq">4.2.18 <code>up_enable_irq()</code></a></h3>
<p><b>Function Prototype</b>:</p>
<ul><pre>
#ifndef CONFIG_ARCH_NOINTC
  void up_enable_irq(int irq);
#endif
</pre></ul>

<p><b>Description</b>.
  This function implements disabling of the device specified by 'irq'
  at the interrupt controller level if supported by the architecture
  (up_irq_restore() supports the global level, the device level is hardware
  specific).
</p>
<p>
  If the architecture does not support <code>up_disable_irq</code>,
  <code>CONFIG_ARCH_NOINTC</code> should be defined in the NuttX configuration file.
  Since this API cannot be supported on all architectures, it should be
  avoided in common implementations where possible.
</p>

<h3><a name="upprioritizeirq">4.2.19 <code>up_prioritize_irq()</code></a></h3>
<p><b>Function Prototype</b>:</p>
<ul><pre>
#ifdef CONFIG_ARCH_IRQPRIO
  void up_enable_irq(int irq);
#endif
</pre></ul>
<p><b>Description</b>.
  Set the priority of an IRQ.
</p>
<p>
  If the architecture supports <code>up_enable_irq</code>,
  <code>CONFIG_ARCH_IRQPRIO</code> should be defined in the NuttX configuration file.
  Since this API cannot be supported on all architectures, it should be
  avoided in common implementations where possible.
</p>

<h3><a name="upputc">4.2.20 <code>up_putc()</code></a></h3>

<p><b>Function Prototype</b>: <code>int up_putc(int ch);</code></p>
<p><b>Description</b>.
  This is a debug interface exported by the architecture-specific logic.
  Output one character on the console
</p>

<h2><a name="boardimports">4.3 APIs Exported by Board-Specific Logic to NuttX</a></h2>

<p>
  Exported board-specific interfaces are prototyped in the header file <code>include/nuttx/board.h</code>.
  There are many interfaces exported from board- to architecture-specific logic.
  But there are only a few exported from board-specific logic to common NuttX logic.
  Those few of those related to initialization will be discussed in this paragraph.
  There are others, like those used by <a href="#boardctl"><code>boardctl()</code></a> that will be discussed in other paragraphs.
</p>
<p>
  All of the board-specific interfaces used by the NuttX OS logic are for controlled board initialization.
  There are three points in time where you can insert custom, board-specific initialization logic:
</p>
<p>
  First, <code>&lt;arch&gt;_board_initialize()</code>:  This function is <i>not</i> called from the common OS logic, but rather from the architecture-specific power on reset logic.
  This is used only for initialization of very low-level things like configuration of GPIO pins, power settings, DRAM initialization, etc.
  The OS has not been initialized at this point, so you cannot allocate memory or initialize device drivers.
</p>
<p>
  The other two board initialization <i>hooks</i> are called from the OS start-up logic and are described in the following paragraphs:
</p>

<h3><a name="boardearlyinit">4.3.1 board_early_initialize()</a></h3>

<p>
  The next level of initialization is performed by a call to <code>up_initialize()</code> (in <code>arch/&lt;arch&gt;/src/common/up_initialize.c</code>).  The OS has been initialized at this point and it is okay to initialize drivers in this phase.
  <code>up_initialize()</code> is <i>not</i> a board-specific interface, but rather an architecture-specific, board-independent interface.
</p>
<p>
  But at this same point in time, the OS will also call a board-specific initialization function named <code>board_early_initialize()</code> if <code>CONFIG_BOARD_EARLY_INITIALIZE=y</code> is selected in the configuration.
  The context in which <code>board_early_initialize()</code> executes is suitable for early initialization of most, simple device drivers and is a logical, board-specific extension of up_initialize().
</p>
<p>
  <code>board_early_initialize()</code> runs on the startup, initialization thread.
  Some initialization operations cannot be performed on the start-up, initialization thread.
  That is because the initialization thread cannot wait for event.
  Waiting may be required, for example, to mount a file system or or initialize a device such as an SD card.
  For this reason, such driver initialize must be deferred to <code>board_late_initialize()</code>.
</p>

<h3><a name="boardlateinit">4.3.2 board_late_initialize()</a></h3>

<p>
  And, finally, just before the user application code starts.
  If <code>CONFIG_BOARD_LATE_INITIALIZE=y</code> is selected in the configuration, then an final, additional initialization call will be performed in the boot-up sequence to a function called <code>board_late_initialize()</code>.
  <code>board_late_initialize()</code> will be called well after <code>up_initialize()</code> and <code>board_early_initialize()</code> are called.
  <code>board_late_initialize()</code> will be called just before the main application task is started.
  This additional initialization phase may be used, for example, to initialize more complex, board-specific device drivers.
</p>
<p>
  Waiting for events, use of I2C, SPI, etc are permissible in the context of board_late_initialize().
  That is because <code>board_late_initialize()</code> will run on a temporary, internal kernel thread.
</p>

<h2><a name="systemtime">4.4 System Time and Clock</a></h2>

<h3><a name="basictimer">4.4.1 Basic System Timer</a></h3>

<p><b>System Timer</b>
  In most implementations, system time is provided by a timer interrupt.
  That timer interrupt runs at rate determined by <code>CONFIG_USEC_PER_TICK</code> (default 10000 microseconds or 100Hz.  If <code>CONFIG_SCHED_TICKLESS</code> is selected, the default is 100 microseconds).
  The timer generates an interrupt each <code>CONFIG_USEC_PER_TICK</code> microseconds and increments a counter called <code>g_system_timer</code>.
  <code>g_system_timer</code> then provides a time-base for calculating <i>up-time</i> and elapsed time intervals in units of <code>CONFIG_USEC_PER_TICK</code>.
  The range of <code>g_system_timer</code> is, by default, 32-bits.
  However, if the MCU supports type <code>long long</code> and <code>CONFIG_SYSTEM_TIME16</code> is selected,
  a 64-bit system timer will be supported instead.
</p>
<p><b>System Timer Accuracy</b>
  On many system, the exact timer interval specified by <code>CONFIG_USEC_PER_TICK</code> cannot be achieved due to limitations in frequencies or in dividers.
  As a result, the time interval specified by <code>CONFIG_USEC_PER_TICK</code> may only be approximate and there may be small errors in the apparent <i>up-time</i> time.
  These small errors, however, will accumulate over time and after a long period of time may have an unacceptably large error in the apparent <i>up-time</i> of the MCU.
</p>
  If the timer tick period generated by the hardware is not exactly <code>CONFIG_USEC_PER_TICK</code> <i>and</i> if there you require accurate up-time for the MCU, then there are measures that you can take:
</p>
<ul>
  <li>
    Perhaps you can adjust <code>CONFIG_USEC_PER_TICK</code> to a different value so that an exactly <code>CONFIG_USEC_PER_TICK</code> can be realized.
  </li>
  <li>
    Or you can use a technique known as <i>Delta-Sigma Modulation</i>. (Suggested by Uros Platise).  Consider the example below.
  </li>
</ul>

<p><b>Delta-Sigma Modulation Example</b>.
  Consider this case:  The system timer is a count-up timer driven at 32.768KHz.
  There are dividers that can be used, but a divider of one yields the highest accuracy.
  This counter counts up until the count equals a match value, then a timer interrupt is generated.
  The desire frequency is 100Hz (<code>CONFIG_USEC_PER_TICK</code> is 10000).
</p>
<p>
  This exact frequency of 100Hz cannot be obtained in this case.
  In order to obtain that exact frequency a match value of 327.68 would have to be provided.
  The closest integer value is 328 but the ideal match value is between 327 and 328.
  The closest value, 328, would yield an actual timer frequency of 99.9Hz!
  That will may cause significant timing errors in certain usages.
</p>
<p>
  Use of Delta-Sigma Modulation can eliminate this error in the long run.
  Consider this example implementation:
</p>
<ol>
  <li>
    Initially an accumulator is zero an the match value is programmed to 328:
<ul><pre>
accumulator = 0;
match = 328;
</pre></ul>
  </li>
  <li>
    On each timer interrupt, accumulator is updated with difference that, in this reflects, 100* the error in interval that just passed.
    So on the first timer interrupt, the accumulator would be updated like:
<ul><pre>
if (match == 328)
  {
    accumulator += 32; // 100*(328 - 327.68)
  }
else
  {
    accumulator -= 68; // (100*(327 - 327.68)
  }
</pre></ul>
  </li>
  <li>
     And on that same timer interrupt a new match value would be programmed:
<ul><pre>
if (accumulator < 0)
  {
    match = 328;
  }
else
  {
    match = 327;
  }
</pre></ul>
</ol>
<p>
  In this way, the timer interval is controlled from interrupt-to-interrupt to produce an average frequency of exactly 100Hz.
</p>

<h3><a name="timerhw">4.4.2 Hardware</a></h3>
<p>
  To enable hardware module use the following configuration options:
<p>
<ul><dl>
  <dt><code>CONFIG_RTC</code>
  <dd>Enables general support for a hardware RTC.
      Specific architectures may require other specific settings.
  <dt><code>CONFIG_RTC_EXTERNAL</code>
  <dd>Most MCUs include RTC hardware built into the chip.
      Other RTCs, <i>external</i> MCUs, may be provided as separate chips typically
      interfacing with the MCU via a serial interface such as SPI or I2C.
      These external RTCs differ from the built-in RTCs in that they cannot be initialized
      until the operating system is fully booted and can support the required serial
      communications.  <code>CONFIG_RTC_EXTERNAL</code> will configure the operating
      system so that it defers initialization of its time facilities.
  <dt><code>CONFIG_RTC_DATETIME</code>
  <dd>There are two general types of RTC:  (1) A simple battery backed counter that keeps the time when power
     is down, and (2) A full date / time RTC the provides the date and time information, often in BCD format.
     If <code>CONFIG_RTC_DATETIME</code> is selected, it specifies this second kind of RTC.
     In this case, the RTC is used to &quot;seed&quot;" the normal NuttX timer and the NuttX system timer
     provides for higher resolution time.
  <dt><code>CONFIG_RTC_HIRES</code>
  <dd>If <code>CONFIG_RTC_DATETIME</code> not selected, then the simple, battery backed counter is used.
      There are two different implementations of such simple counters based on the time resolution of the counter:
      The typical RTC keeps time to resolution of 1 second, usually supporting a 32-bit <code>time_t</code> value.
      In this case, the RTC is used to &quot;seed&quot; the normal NuttX timer and the NuttX timer provides for higher resolution time.
      If <code>CONFIG_RTC_HIRES</code> is enabled in the NuttX configuration, then the RTC provides higher resolution time and completely replaces the system timer for purpose of date and time.
  <dt><code>CONFIG_RTC_FREQUENCY</code>
  <dd>If <code>CONFIG_RTC_HIRES</code> is defined, then the frequency of the high resolution RTC must be provided.
      If <code>CONFIG_RTC_HIRES</code> is not defined, <code>CONFIG_RTC_FREQUENCY</code> is assumed to be one.
  <dt><code>CONFIG_RTC_ALARM</code>
  <dd>Enable if the RTC hardware supports setting of an alarm.
    A callback function will be executed when the alarm goes off
</dl></ul>
<p>
  which requires the following base functions to read and set time:
</p>
<ul>
  <li><code>up_rtc_initialize()</code>.
     Initialize the built-in, MCU hardware RTC per the selected configuration.
     This function is called once very early in the OS initialization sequence.
     NOTE that initialization of external RTC hardware that depends on the
     availability of OS resources (such as SPI or I2C) must be deferred
     until the system has fully booted.  Other, RTC-specific initialization
     functions are used in that case.
  </li>
  <li><code>up_rtc_time()</code>.
    Get the current time in seconds.  This is similar to the standard <code>time()</code> function.
    This interface is only required if the low-resolution RTC/counter hardware implementation selected.
    It is only used by the RTOS during initialization to set up the system time when <code>CONFIG_RTC</code> is set
    but neither <code>CONFIG_RTC_HIRES</code> nor <code>CONFIG_RTC_DATETIME</code> are set.
  </li>
  <li><code>up_rtc_gettime()</code>.
    Get the current time from the high resolution RTC clock/counter.
    This interface is only supported by the high-resolution RTC/counter hardware implementation.
    It is used to replace the system timer (<code>g_system_tick</code>).
  </li>
  <li><code>up_rtc_settime()</code>.
    Set the RTC to the provided time.
    All RTC implementations must be able to set their time based on a standard timespec.
  </li>
</ul>

<h3><a name="systcktime">4.4.3 System Tick and Time</a></h3>
<p>
  The system tick is represented by::
</p>
<ul>
  <li><code>g_system_timer</code></li>
</ul>
<p>
  Running at rate of system base timer, used for time-slicing, and so forth.
</p>
<p>
  If hardware RTC is present (<code>CONFIG_RTC</code>) and and high-resolution timing
  is enabled (<code>CONFIG_RTC_HIRES</code>), then after successful
  initialization variables are overridden by calls to <code>up_rtc_gettime()</code> which is
  running continuously even in power-down modes.
</p>
<p>
  In the case of <code>CONFIG_RTC_HIRES</code> is set the <code>g_system_timer</code>
  keeps counting at rate of a system timer, which however, is disabled in power-down mode.
  By comparing this time and RTC (actual time) one may determine the actual system active time.
  To retrieve that variable use:
</p>

<h3><a name="tickless">4.4.4 Tickless OS</a></h3>
<h4><a name="tickoverview">4.4.4.1 Tickless Overview</a></h4>

<p>
  <b>Default System Timer</b>.
  By default, a NuttX configuration uses a periodic timer interrupt that drives all system timing. The timer is provided by architecture-specific code that calls into NuttX at a rate controlled by <code>CONFIG_USEC_PER_TICK</code>. The default value of <code>CONFIG_USEC_PER_TICK</code> is 10000 microseconds which corresponds to a timer interrupt rate of 100 Hz.
</p>
<p>
  On each timer interrupt, NuttX does these things:
<p>
<ul>
  <li>Increments a counter. This counter is the system time and has a resolution of <code>CONFIG_USEC_PER_TICK</code> microseconds.
  <li>Checks if it is time to perform time-slice operations on tasks that have select round-robin scheduling.
  <li>Checks for expiration of timed events.
</ul>
<p>
  What is wrong with this default system timer? Nothing really. It is reliable and uses only a small fraction of the CPU band width. But we can do better. Some limitations of default system timer are, in increasing order of importance:
</p>
<ul>
  <li>
    <b>Overhead</b>:
    Although the CPU usage of the system timer interrupt at 100Hz is really very low, it is still mostly wasted processing time. One most timer interrupts, there is really nothing that needs be done other than incrementing the counter.
  </li>
  <li>
    <b>Resolution</b>:
    Resolution of all system timing is also determined by <code>CONFIG_USEC_PER_TICK</code>. So nothing that be time with resolution finer than 10 milliseconds be default. To increase this resolution, <code>CONFIG_USEC_PER_TICK</code> an be reduced. However, then the system timer interrupts use more of the CPU bandwidth processing useless interrupts.
  </li>
  <li>
    <b>Power Usage</b>:
    But the biggest issue is power usage. When the system is IDLE, it enters a light, low-power mode (for ARMs, this mode is entered with the <code>wfi</code> or <code>wfe</code> instructions for example). But each interrupt awakens the system from this low power mode. Therefore, higher rates of interrupts cause greater power consumption.
  </li>
</ul>
<p>
  <b><i>Tickless OS</i></b>.
  The so-called <i>Tickless OS</i> provides one solution to issue. The basic concept here is that the periodic, timer interrupt is eliminated and replaced with a one-shot, interval timer. It becomes event driven instead of polled: The default system timer is a polled design. On each interrupt, the NuttX logic checks if it needs to do anything and, if so, it does it.
</p>
<p>
  Using an interval timer, one can anticipate when the next interesting OS event will occur, program the interval time and wait for it to fire. When the interval time fires, then the scheduled activity is performed.
</p>

<h4><a name="tickplatform">4.4.4.2 Tickless Platform Support</a></h4>

In order to use the Tickless OS, one must provide special support from the platform-specific code. Just as with the default system timer, the platform-specific code must provide the timer resources to support the OS behavior.

Currently these timer resources are only provided on a few platforms. An example implementation is for the simulation is at <code>nuttx/arch/sim/src/up_tickless.c</code>.  There is another example for the Atmel SAMA5 at <code>nuttx/arch/arm/src/sama5/sam_tickless.c</code>.  These paragraphs will explain how to provide the Tickless OS support to any platform.

<h4><a name="tickoptions">4.4.4.3 Tickless Configuration Options</a></h4>
<ul>
  <li>
    <p>
      <b><code>CONFIG_ARCH_HAVE_TICKLESS</code></b>:
      If the platform provides support for the <i>Tickless OS</i>, then this setting should be selected in the <code>Kconfig</code> file for the board. Here is what the selection looks in the <code>arch/Kconfig</code> file for the simulated platform:
    </p>
<ul><pre>
config ARCH_SIM
   bool "Simulation"
   select ARCH_HAVE_TICKLESS
   ---help---
       Linux/Cygwin user-mode simulation.
</pre></ul>
    <p>
      When the simulation platform is selected, <code>ARCH_HAVE_TICKLESS</code> is automatically selected, informing the configuration system that <i>Tickless OS</i> options can be selected.
    </p>
  </li>
  <li>
    <p>
      <b><code>CONFIG_SCHED_TICKLESS</code></b>:
      If <code>CONFIG_ARCH_HAVE_TICKLESS</code> is selected, then it will enable the Tickless OS features in NuttX.
    </p>
  </li>
  <li>
    <p>
      <b><code>CONFIG_SCHED_TICKLESS_ALARM</code></b>:
      The tickless option can be supported either via a simple interval timer (plus elapsed time) or via an alarm.  The interval timer allows programming events to occur after an interval.  With the alarm, you can set a time in the future and get an event when that alarm goes off.  This option selects the use of an alarm.
    </p>
    <p>
      The advantage of an alarm is that it avoids some small timing errors; the advantage of the use of the interval timer is that the hardware requirement may be less.
    </p>
  </li>
  <li>
    <p>
      <b><code>CONFIG_USEC_PER_TICK</code></b>:
      This option is not unique to <i>Tickless OS</i> operation, but changes its relevance when the <i>Tickless OS</i> is selected.
      In the default configuration where system time is provided by a periodic timer interrupt, the default system timer is configure the timer for 100Hz or <code>CONFIG_USEC_PER_TICK=10000</code>. If <code>CONFIG_SCHED_TICKLESS</code> is selected, then there are no system timer interrupt. In this case, <code>CONFIG_USEC_PER_TICK</code> does not control any timer rates. Rather, it only determines the resolution of time reported by <code>clock_systime_ticks()</code> and the resolution of times that can be set for certain delays including watchdog timers and delayed work.
    </p>
    <p>
      In this case there is still a trade-off: It is better to have the <code>CONFIG_USEC_PER_TICK</code> as low as possible for higher timing resolution. However, the time is currently held in <code>unsigned int</code>. On some systems, this may be 16-bits in width but on most contemporary systems it will be 32-bits. In either case, smaller values of <code>CONFIG_USEC_PER_TICK</code> will reduce the range of values that delays that can be represented. So the trade-off is between range and resolution (you could also modify the code to use a 64-bit value if you really want both).
    </p>
    <p>
      The default, 100 microseconds, will provide for a range of delays up to 120 hours.
    </p>
    <p>
      This value should never be less than the underlying resolution of the timer. Errors may ensue.
    </p>
  </li>
</ul>

<h4><a name="tickimport">4.4.4.4 Tickless Imported Interfaces</a></h4>
<p>
  The interfaces that must be provided by the platform specified code are defined in <code>include/nuttx/arch.h</code>, listed below, and summarized in the following paragraphs:
</p>
<ul>
  <li>
    <a href="#uptimerinit"><i>&lt;arch&gt;</i><code>_timer_initialize()</code></a>:
    Initializes the timer facilities.  Called early in the initialization sequence (by <code>up_initialize()</code>).
  </li>
  <li>
    <a href="#uptimergettime"><code>up_timer_gettime()</code></a>:
    Returns the current time from the platform specific time source.
  </li>
</ul>
<p>
  The tickless option can be supported either via a simple interval timer (plus elapsed time) or via an alarm.  The interval timer allows programming events to occur after an interval.  With the alarm, you can set a time in* the future and get an event when that alarm goes off.
</p>
<p>
  If <code>CONFIG_SCHED_TICKLESS_ALARM</code> is defined, then the platform code must provide the following:
<p>
<ul>
  <li>
    <a href="#upalarmcancel"><code>up_alarm_cancel()</code></a>:
    Cancels the alarm.
  </li>
  <li>
    <a href="#upalarmstart"><code>up_alarm_start()</code></a>:
    Enables (or re-enables) the alarm.
  </li>
</ul>
<p>
  If <code>CONFIG_SCHED_TICKLESS_ALARM</code> is <i>not</i>defined, then the platform code must provide the following verify similar functions:
<p>
<ul>
  <li>
    <a href="#uptimercancel"><code>up_timer_cancel()</code></a>:
    Cancels the interval timer.
  </li>
  <li>
    <a href="#uptimerstart"><code>up_timer_start()</code></a>:
    Starts (or re-starts) the interval timer.
  </li>
</ul>
<p>
  Note that a platform-specific implementation would probably require two hardware timers: (1) A interval timer to satisfy the requirements of <a href="#uptimerstart"><code>up_timer_start()</code></a> and <a href="#uptimercancel"><code>up_timer_cancel()</code></a>, and a (2) a counter to handle the requirement of <a href="#uptimergettime"><code>up_timer_gettime()</code></a>.  Ideally, both timers would run at the rate determined by <code>CONFIG_USEC_PER_TICK</code> (and certainly never slower than that rate).
</p>
<p>
  Since timers are a limited resource, the use of two timers could be an issue on some systems.
  The job could be done with a single timer if, for example, the single timer were kept in a free-running at all times. Some timer/counters have the capability to generate a compare interrupt when the timer matches a comparison value but also to continue counting without stopping. If your hardware supports such counters, one might used the <code>CONFIG_SCHED_TICKLESS_ALARM</code> option and be able to simply set the comparison count at the value of the free running timer <i>PLUS</i> the desired delay. Then you could have both with a single timer: An alarm and a free-running counter with the same timer!
</p>
<p>
  In addition to these imported interfaces, the RTOS will export the following interfaces for use by the platform-specific interval timer implementation:
</p>
<ul>
  <li>
    <a href="#schedalarmexpiration"><code>nxsched_alarm_expiration()</code></a>. Called by the platform-specific logic when the alarm expires.
  </li>
  <li>
    <a href="#schedtimerexpiration"><code>nxsched_timer_expiration()</code></a>. Called by the platform-specific logic when the interval time expires.
  </li>
</ul>

<h5><a name="uptimerinit">4.4.4.4.1 <i>&lt;arch&gt;</i><code>_timer_initialize()</code></a></h5>
<p><b>Function Prototype</b>:</p>
<ul><pre>
#include &quotup_internal.h&quot;
void <i>&lt;arch&gt;</i>_timer_initialize()(void);
</pre></ul>
<p><b>Description</b>:</p>
<ul>
  Initializes all platform-specific timer facilities. This function is called early in the initialization sequence by <code>up_initialize()</code>. On return, the current up-time should be available from <code>up_timer_gettime()</code> and the interval timer is ready for use (but not actively timing).
</ul>
<p><b>Input Parameters</b>:</p>
<ul>
  None
</ul>
<p><b>Returned Value</b>:</p>
<ul>
  Zero (<code>OK</code>) on success; a negated <code>errno</code> value on failure.
</ul>
<p><b>Assumptions</b>:</p>
<ul>
  Called early in the initialization sequence before any special concurrency protections are required.
</ul>

<h5><a name="uptimergettime">4.4.4.4.2 <code>up_timer_gettime()</code></a></h5>
<p><b>Function Prototype</b>:<p>
<ul><pre>
#include &lt;nuttx/arch.h&gt;
int up_timer_gettime(FAR struct timespec *ts);
</pre></ul>
<p><b>Description</b>:</p>
  Return the elapsed time since power-up (or, more correctly, since <i>&lt;arch&gt;</i><code>_timer_initialize()</code> was called). This function is functionally equivalent to <code>clock_gettime()</code> for the clock ID <code>CLOCK_MONOTONIC</code>. This function provides the basis for reporting the current time and also is used to eliminate error build-up from small errors in interval time calculations.
<ul>
</ul>
<p><b>Input Parameters</b>:</p>
<ul>
  <li><code>ts</code>: Provides the location in which to return the up-time..
</li>
</ul>
<p><b>Returned Value</b>:</p>
<ul>
  Zero (<code>OK</code>) on success; a negated <code>errno</code> value on failure.
</ul>
<p><b>Assumptions</b>:</p>
<ul>
  Called from the normal tasking context. The implementation must provide whatever mutual exclusion is necessary for correct operation. This can include disabling interrupts in order to assure atomic register operations.
</ul>

<h5><a name="upalarmcancel">4.4.4.4.3 <code>up_alarm_cancel()</code></a></h5>
<p><b>Function Prototype</b>:<p>
<ul><pre>
#include &lt;nuttx/arch.h&gt;
int up_alarm_cancel(FAR struct timespec *ts);
</pre></ul>
<p><b>Description</b>:</p>
  Cancel the alarm and return the time of cancellation of the alarm. These two steps need to be as nearly atomic as possible. <code>nxsched_timer_expiration()</code> will not be called unless the alarm is restarted with <code>up_alarm_start()</code>. If, as a race condition, the alarm has already expired when this function is called, then time returned is the current time.
<ul>
</ul>
<p><b>Input Parameters</b>:</p>
<ul>
  <li><code>ts</code>: Location to return the expiration time.  The current time should be returned if the timer is not active.    <code>ts</code> may be <code>NULL</code> in which case the time is not returned</li>
</ul>
<p><b>Returned Value</b>:</p>
<ul>
  Zero (<code>OK</code>) on success; a negated <code>errno</code> value on failure.
</ul>
<p><b>Assumptions</b>:</p>
<ul>
  May be called from interrupt level handling or from the normal tasking level. interrupts may need to be disabled internally to assure non-reentrancy.
</ul>

<h5><a name="upalarmstart">4.4.4.4.4 <code>up_alarm_start()</code></a></h5>
<p><b>Function Prototype</b>:<p>
<ul><pre>
#include &lt;nuttx/arch.h&gt;
int up_alarm_start(FAR const struct timespec *ts);
</pre></ul>
<p><b>Description</b>:</p>
  Start the alarm. <code>nxsched_timer_expiration()</code> will be called when the alarm occurs (unless <code>up_alarm_cancel</code> is called to stop it).
<ul>
</ul>
<p><b>Input Parameters</b>:</p>
<ul>
  <li><code>ts</code>: The time in the future at the alarm is expected to occur.  When the alarm occurs the timer logic will call <code>nxsched_timer_expiration()</code>.</li>
</ul>
<p><b>Returned Value</b>:</p>
<ul>
  Zero (<code>OK</code>) on success; a negated <code>errno</code> value on failure.
</ul>
<p><b>Assumptions</b>:</p>
<ul>
  May be called from interrupt level handling or from the normal tasking level. Interrupts may need to be disabled internally to assure non-reentrancy.
</ul>

<h5><a name="uptimercancel">4.4.4.4.5 <code>up_timer_cancel()</code></a></h5>
<p><b>Function Prototype</b>:<p>
<ul><pre>
#include &lt;nuttx/arch.h&gt;
int up_timer_cancel(FAR struct timespec *ts);
</pre></ul>
<p><b>Description</b>:</p>
  Cancel the interval timer and return the time remaining on the timer. These two steps need to be as nearly atomic as possible. <code>nxsched_timer_expiration()</code> will not be called unless the timer is restarted with <code>up_timer_start()</code>. If, as a race condition, the timer has already expired when this function is called, then that pending interrupt must be cleared so that <code>nxsched_timer_expiration()</code> is not called spuriously and the remaining time of zero should be returned.
<ul>
</ul>
<p><b>Input Parameters</b>:</p>
<ul>
  <li><code>ts</code>: Location to return the remaining time. Zero should be returned if the timer is not active.</li>
</ul>
<p><b>Returned Value</b>:</p>
<ul>
  Zero (<code>OK</code>) on success; a negated <code>errno</code> value on failure.
</ul>
<p><b>Assumptions</b>:</p>
<ul>
  May be called from interrupt level handling or from the normal tasking level. interrupts may need to be disabled internally to assure non-reentrancy.
</ul>

<h5><a name="uptimerstart">4.4.4.4.6 <code>up_timer_start()</code></a></h5>
<p><b>Function Prototype</b>:<p>
<ul><pre>
#include &lt;nuttx/arch.h&gt;
int up_timer_start(FAR const struct timespec *ts);
</pre></ul>
<p><b>Description</b>:</p>
  Start the interval timer. <code>nxsched_timer_expiration()</code> will be called at the completion of the timeout (unless <code>up_timer_cancel()</code> is called to stop the timing).
<ul>
</ul>
<p><b>Input Parameters</b>:</p>
<ul>
  <li><code>ts</code>: Provides the time interval until <code>nxsched_timer_expiration()</code> is called.</li>
</ul>
<p><b>Returned Value</b>:</p>
<ul>
  Zero (<code>OK</code>) on success; a negated <code>errno</code> value on failure.
</ul>
<p><b>Assumptions</b>:</p>
<ul>
  May be called from interrupt level handling or from the normal tasking level. Interrupts may need to be disabled internally to assure non-reentrancy.
</ul>

<h3><a name="Watchdogs">4.4.5 Watchdog Timer Interfaces</a></h3>
<p>
  NuttX provides a general watchdog timer facility.
  This facility allows the NuttX user to specify a watchdog timer function
  that will run after a specified delay.
  The watchdog timer function will run in the context of the timer interrupt handler.
  Because of this, a limited number of NuttX interfaces are available to he watchdog timer function.
  However, the watchdog timer function may use <code>mq_send()</code>, <code>sigqueue()</code>,
  or <code>kill()</code> to communicate with NuttX tasks.
</p>
<ul>
  <li><a href="#wdstart">4.4.5.1 wd_start</a></li>
  <li><a href="#wdcancel">4.4.5.2 wd_cancel</a></li>
  <li><a href="#wdgettime">4.4.5.3 wd_gettime</a></li>
  <li><a href="#wdcallback">4.4.5.4 Watchdog Timer Callback</a></li>

</ul>

<h4><a name="wdstart">4.4.5.1 wd_start</a></h4>

<p>
<b>Function Prototype:</b>
<pre>
    #include &lt;nuttx/wdog.h&gt;
    int wd_start(FAR struct wdog_s *wdog, int delay,
                 wdentry_t wdentry, wdparm_t arg);
</pre>

<p>
<b>Description:</b> This function adds a watchdog to the timer
queue. The specified watchdog function will be called from the
interrupt level after the specified number of ticks has elapsed.
Watchdog timers may be started from the interrupt level.
<p>
Watchdog times execute in the context of the timer interrupt handler.
<p>
Watchdog timers execute only once.
<p>
To replace either the timeout delay or the function to be executed,
call wd_start again with the same wdog; only the most recent
wd_start() on a given watchdog ID has any effect.
<p>
<b>Input Parameters:</b>
<ul>
<li><code>wdog</code>. Watchdog ID
<li><code>delay</code>. Delay count in clock ticks
<li><code>wdentry</code>. Function to call on timeout
<li><code>arg</code>. The parameter to pass to wdentry.

<p>
<b>NOTE</b>:  The parameter must be of type <code>wdparm_t</code>.
</p>
</ul>

<p>
<b>Returned Value:</b>
<ul>
<li>Zero (<code>OK</code>) is returned on success; a negated <code>errno</code> value is return to indicate the nature of any failure.
</ul>

<p>
<b>Assumptions/Limitations:</b> The watchdog routine runs in the
context of the timer interrupt handler and is subject to all ISR
restrictions.
<p>
<b>POSIX  Compatibility:</b> This is a NON-POSIX interface.
VxWorks provides the following comparable interface:
<pre>
    STATUS wdStart (WDOG_ID wdog, int delay, FUNCPTR wdentry, int parameter);
</pre>

<p>
Differences from the VxWorks interface include:
<ul>
<li>The present implementation supports multiple parameters passed
to wdentry; VxWorks supports only a single parameter.  The maximum
number of parameters is determined by
</ul>

<h4><a name="wdcancel">4.4.5.2 wd_cancel</a></h4>
<p>
<b>Function Prototype:</b>
<pre>
    #include &lt;nuttx/wdog.h&gt;
    int wd_cancel(FAR struct wdog_s *wdog);
</pre>

<p>
<b>Description:</b> This function cancels a currently running
watchdog timer. Watchdog timers may be canceled from the interrupt
level.
<p>
<b>Input Parameters:</b>
<ul>
<li><code>wdog</code>. ID of the watchdog to cancel.
</ul>

<p>
<b>Returned Value:</b>
<ul>
<li>OK or ERROR
</ul>

<p>
<b>Assumptions/Limitations:</b>
<p>
<b>POSIX  Compatibility:</b> This is a NON-POSIX interface.
VxWorks provides the following comparable interface:
<pre>
    STATUS wdCancel (WDOG_ID wdog);
</pre>

<h3><a name="wdgettime">4.4.5.3 wd_gettime</a></h3>
<p>
  <b>Function Prototype:</b>
</p>
<pre>
    #include &lt;nuttx/wdog.h&gt;
    int wd_gettime(FAR struct wdog_s *wdog);
</pre>
<p>
  <b>Description:</b>
   This function returns the time remaining before the specified watchdog expires.
</p>
<p>
  <b>Input Parameters:</b>
  <ul>
    <li><code>wdog</code>. Identifies the watchdog that the request is for.</li>
  </ul>
</p>
<p>
  <b>Returned Value:</b>
  The time in system ticks remaining until the watchdog time expires.  Zero
  means either that wdog is not valid or that the wdog has already expired.
</p>

<h4><a name="wdcallback">4.4.5.4 Watchdog Timer Callback</a></h4>
<p>
  When a watchdog expires, the callback function with this type is called:
</p>
<pre>
    typedef void (*wdentry_t)(wdparm_t arg);
</pre>
<p>
  The argument is passed as scalar <code>wdparm_t</code> values.  For systems where the <code>sizeof(pointer) &lt; sizeof(uint32_t)</code>, the following union defines the alignment of the pointer within the <code>uint32_t</code>.  For example, the SDCC MCS51 general pointer is 24-bits, but <code>uint32_t</code> is 32-bits (of course).
</p>
   We always have <code>sizeof(pointer) <= sizeof(uintptr_t)</code> by definition.
</p>
<ul><pre>
#if UINTPTR_MAX >= UINT32_MAX
typedef uintptr_t wdparm_t;
#else
typedef uint32_t  wdparm_t;
#endif
</pre></ul>

<h2><a name="workqueues">4.5 Work Queues</a></h2>
<p><b>Work Queues</b>.
  NuttX provides <i>work queues</i>.  Work queues are threads that service a queue of work items to be performed.  They are useful for off-loading work to a different threading context, for delayed processing, or for serializing activities.
</p>

<h3><a name="wqclasses">4.5.1 Classes of Work Queues</a></h3>

<p><b>Classes of Work Queues</b>.
  There are three different classes of work queues, each with different properties and intended usage.  These class of work queues along with the common work queue interface are described in the following paragraphs.
</p>

<h4><a name="hpwork">4.5.1.1 High Priority Kernel Work queue</a></h4>

<p><b>High Priority Kernel Work queue</b>.
  The dedicated high-priority work queue is intended to handle delayed processing from interrupt handlers.  This work queue is required for some drivers but, if there are no complaints, can be safely disabled.  The high priority worker thread also performs garbage collection -- completing any delayed memory deallocations from interrupt handlers.  If the high-priority worker thread is disabled, then that clean up will be performed either by (1) the low-priority worker thread, if enabled, and if not (2) the IDLE thread instead (which runs at the lowest of priority and may not be appropriate if memory reclamation is of high priority)
</p>
<p><b>Device Driver Bottom Half</b>.
  The high-priority worker thread is intended to serve as the <i>bottom half</i> for device drivers.  As a consequence it must run at a very high, fixed priority rivalling the priority of the interrupt handler itself.  Typically, the high priority work queue should be the highest priority thread in your system (the default priority is 224).
</p>
<p>
  <b>Thread Pool</b>.
  The work queues can be configured to support multiple, low-priority threads.  This is essentially a <i>thread pool</i> that provides multi-threaded servicing of the queue work.  This breaks the strict serialization of the &quot;queue&quot; (and hence, the work queue is no longer a queue at all).
</p>
<p>
  Multiple worker threads are required to support, for example, I/O operations that stall waiting for input.  If there is only a single thread, then the entire work queue processing would stall in such cases.
  Such behavior is necessary to support asynchronous I/O, AIO, for example.
</p>
<p><b>Compared to the Low Priority Kernel Work Queue</b>.
  For less critical, lower priority, application oriented worker thread support, consider enabling the lower priority work queue.  The lower priority work queue runs at a lower priority, of course, but has the added advantage that it supports <i>priority inheritance</i> (if <code>CONFIG_PRIORITY_INHERITANCE=y</code> is also selected):  The priority of the lower priority worker thread can then be adjusted to match the highest priority client.
</p>
<p>
  <b>Configuration Options</b>.
</p>
<ul>
  <li><code>CONFIG_SCHED_HPWORK</code>.
    Enables the hight priority work queue.
  </li>
  <li><code>CONFIG_SCHED_HPNTHREADS</code>.
    The number of threads in the high-priority queue's thread pool.  Default: 1
  </li>
  <li><code>CONFIG_SCHED_HPWORKPRIORITY</code>.
    The execution priority of the high-priority worker thread.  Default: 224
  </li>
  <li><code>CONFIG_SCHED_HPWORKSTACKSIZE</code>.
    The stack size allocated for the worker thread in bytes.  Default: 2048.
  </li>
</ul>
<p>
  <b>Common Configuration Options</b>.
  These options apply to all work queues:
</p>
<ul>
  <li><code>CONFIG_SIG_SIGWORK</code>
    The signal number that will be used to wake-up the worker thread.  This same signal is used with the   Default: 17
  </li>
</ul>

<h4><a name="lpwork">4.5.1.2 Low Priority Kernel Work Queue</a></h4>
<p>
  <b>Low Priority Kernel Work Queue</b>.
  This lower priority work queue is better suited for more extended, application oriented processing such as file system clean-up, memory garbage collection and asynchronous I/O operations.
</p>
<p>
  <b>Compared to the High Priority Work Queue</b>.
  The lower priority work queue runs at a lower priority than the high priority work queue, of course, and so is inappropriate to serve as a driver <i>bottom half</i>.
  It is, otherwise, very similar to the high priority work queue and most of the discussion above for the high priority work queue applies equally here.
  The lower priority work queue does have one important, however, that make it better suited for some tasks:
</p>
  <p><b>Priority Inheritance</b>.
  The lower priority worker thread(s) support <i>priority inheritance</i> (if &lt;config&gt; CONFIG_PRIORITY_INHERITANCE</code> is also selected):  The priority of the lower priority worker thread can then be adjusted to match the highest priority client.
</p>
<blockquote>
  <b>NOTE:</b> This priority inheritance feature is not automatic.  The lower priority worker thread will always a fixed priority unless additional logic implements that calls <code>lpwork_boostpriority()</code> to raise the priority of the lower priority worker thread (typically called before scheduling the work) and then calls the matching <code>lpwork_restorepriority()</code> when the work is completed (typically called within the work handler at the completion of the work). Currently, only the NuttX asynchronous I/O logic uses this dynamic prioritization feature.
</blockquote>
<p>
  The higher priority worker thread, on the other hand, is intended to serve as the <i>bottom half</i> for device drivers.  As a consequence must run at a very high, fixed priority.  Typically, it should be the highest priority thread in your system.
</p>
<p>
  <b>Configuration Options</b>.
</p>
<ul>
  <li><code>CONFIG_SCHED_LPWORK</code>.
    If CONFIG_SCHED_LPWORK is selected then a lower-priority work queue will be enabled.
  </li>
  <li><code>CONFIG_SCHED_LPNTHREADS</code>.
    The number of threads in the low-priority queue's thread pool.  Default: 1
  </li>
  <li><code>CONFIG_SCHED_LPWORKPRIORITY</code>.
    The minimum execution priority of the lower priority worker thread.  The priority of the all worker threads start at this priority.  If priority inheritance is in effect, the priority may be boosted from this level.  Default: 50.
  </li>
  <li><code>CONFIG_SCHED_LPWORKPRIOMAX</code>.
    The maximum execution priority of the lower priority worker thread.  Lower priority worker threads will be started at <code>CONFIG_SCHED_LPWORKPRIORITY</code> but their priority may be boosted due to priority inheritance.  The boosted priority of the low priority worker thread will not, however, ever exceed <code>CONFIG_SCHED_LPWORKPRIOMAX</code>.  This limit would be necessary, for example, if the higher priority worker thread were to defer work to the lower priority thread.  Clearly, in such a case, you would want to limit the maximum priority of the lower priority work thread.  Default: 176.
  </li>
  <li><code>CONFIG_SCHED_LPWORKSTACKSIZE</code>.
    The stack size allocated for the lower priority worker thread.  Default: 2048.
  </li>
</ul>

<h4><a name="usrwork">4.5.1.3 User-Mode Work Queue</a></h4>
<p>
  <b>Work Queue Accessibility</b>.
  The high- and low-priority worker threads are kernel-mode threads.  In the normal, <i>flat</i> NuttX build, these work queues are are useful to application code and may be shared.  However, in the NuttX protected and kernel build modes, kernel mode code is isolated and cannot be accessed from user-mode code.
</p>
<p>
  <b>User-Mode Work Queue</b>.
  if either <code>CONFIG_BUILD_PROTECTED</code> or <code>CONFIG_BUILD_KERNEL</code> are selected, then the option to enable a special user-mode work queue is enable.  The interface to the user-mode work queue is identical to the interface to the kernel-mode work queues and the user-mode work queue is functionally equivalent to the high priority work queue.  It differs in that its implementation does not depend on internal, kernel-space facilities.
</p>
<p>
  <b>Configuration Options</b>.
</p>
<ul>
  <li><code>CONFIG_LIB_USRWORK</code>.
    If CONFIG_LIB_USRWORK is also defined then the user-mode work queue will be enabled.
  <li><code>CONFIG_LIB_USRWORKPRIORITY</code>.
    The execution priority of the user-mode priority worker thread.  Default: 100
  <li><code>CONFIG_LIB_USRWORKSTACKSIZE</code>.
    The stack size allocated for the lower priority worker thread.  Default: 2048.
</ul>

<h3><a name="cmnwqifs">4.5.2 Common Work Queue Interfaces</a></h3>
<h4><a name="wqids">4.5.2.1 Work Queue IDs</a></h4>

<p>
  <b>Work queue IDs</b>.
  All work queues use the identical interface functions (at least identical in terms of the function <i>signature</i>).  The first parameter passed to the work queue interface function identifies the work queue:
</p>
<p>
  <b>Kernel-Mode Work Queue IDs:</b>
<p>
<ul>
  <li>
    <code>HPWORK</code>.
    This ID of the high priority work queue that should only be used for hi-priority, time-critical, driver bottom-half functions.
  </li>
  <li>
    <code>LPWORK</code>.
    This is the ID of the low priority work queue that can be used for any purpose.  if <code>CONFIG_SCHED_LPWORK</code> is not defined, then there is only one kernel work queue and <code>LPWORK</code> is equal to <code>HPWORK</code>.
  </li>
</ul>
<p>
  <b>User-Mode Work Queue IDs:</b>
<p>
<ul>
  <li>
    <code>USRWORK</code>.
    This is the ID of the user-mode work queue that can be used for any purpose by applications.  In a flat build, <code>LPWORK</code> is equal to <code>LPWORK</code> so that user applications will use the lower priority work queue (if there is one).
  </li>
</ul>

<h4><a name="wqiftypes">4.5.2.2 Work Queue Interface Types</a></h4>

<ul>
  <li>
    <code>typedef void (*worker_t)(FAR void *arg);</code>
    Defines the type of the work callback.
  </li>
  <li>
    <code>struct work_s</code>.
    Defines one entry in the work queue.  This is a client-allocated structure.  Work queue clients should not reference any field in this structure since they are subject to change.  The user only needs this structure in order to declare instances of the work structure.  Handling of all fields is performed by the work queue interfaces described below.
  </li>
</ul>

<h4><a name="wqintfs">4.5.2.3 Work Queue Interfaces</a></h4>
<h5><a name="workqueue">4.5.2.3.1 <code>work_queue()</code></a></h5>
<p>
  <b>Function Prototype</b>:
  <ul><pre>
#include &lt;nuttx/wqueue.h&gt;
int work_queue(int qid, FAR struct work_s *work, worker_t worker,
               FAR void *arg, uint32_t delay);
</pre></ul>
</p>
<p>
  <b>Description</b>.
  Queue work to be performed at a later time.  All queued work will be performed on the worker thread of execution (not the caller's).
</p>
<p>
  The work structure is allocated and must be initialized to all zero by the caller.
  Otherwise, the work structure is completely managed by the work queue logic.
  The caller should never modify the contents of the work queue structure directly.
  If <code>work_queue()</code> is called before the previous work as been performed and removed from the queue, then any pending work will be canceled and lost.
</p>
<p>
  <b>Input Parameters</b>:
</p>
<ul>
  <li>
    <p>
      <code>qid</code>:
      The work queue ID.
    </p>
  </li>
  <li>
    <p>
      <code>work</code>:
      The work structure to queue
    </p>
  </li>
  <li>
    <p>
      <code>worker</code>:
      The worker callback to be invoked.  The callback will invoked on the worker thread of execution.
    </p>
  </li>
  <li>
    <p>
      <code>arg</code>:
      The argument that will be passed to the worker callback function when it is invoked.
    </p>
  </li>
  <li>
    <p>
      <code>delay</code>:
      Delay (in system clock ticks) from the time queue until the worker is invoked. Zero means to perform the work immediately.
    </p>
  </li>
</ul>
<p>
  <b>Returned Value</b>:
</p>
<ul>
  <p>
     Zero is returned on success; a negated <code>errno</code> is returned on failure.
  </p>
</ul>

<h5><a name="workcancel">4.5.2.3.2 <code>work_cancel()</code></a></h5>
<p>
  <b>Function Prototype</b>:
#include &lt;nuttx/wqueue.h&gt;
int work_cancel(int qid, FAR struct work_s *work);
  <ul><pre>
</pre></ul>
</p>
<p>
  <b>Description</b>.
  Cancel previously queued work.  This removes work from the work queue.  After work has been cancelled, it may be re-queue by calling <code>work_queue()</code> again.
</p>
<p>
  <b>Input Parameters</b>:
</p>
<ul>
  <li>
    <p>
      <code>qid</code>:
      The work queue ID.
    </p>
  </li>
  <li>
    <p>
      <code>work</code>:
      The previously queue work structure to cancel.
    </p>
  </li>
</ul>
<p>
  <b>Returned Value</b>:
</p>
<ul>
  <p>
     Zero is returned on success; a negated <code>errno</code> is returned on failure.
  </p>
  <ul>
    <li><code>ENOENT</code>: There is no such work queued.</li>
    <li><code>EINVAL</code>: An invalid work queue was specified.</li>
  </ul>
</ul>

<h5><a name="worksignal">4.5.2.3.3 <code>work_signal()</code></a></h5>
<p>
  <b>Function Prototype</b>:
#include &lt;nuttx/wqueue.h&gt;
int work_signal(int qid);
  <ul><pre>
</pre></ul>
</p>
<p>
  <b>Description</b>.
  Signal the worker thread to process the work queue now.  This function is used internally by the work logic but could also be used by the user to force an immediate re-assessment of pending work.
</p>
<p>
  <b>Input Parameters</b>:
</p>
<ul>
  <li>
    <p>
      <code>qid</code>:
      The work queue ID.
    </p>
</ul>
<p>
  <b>Returned Value</b>:
</p>
<ul>
  <p>
     Zero is returned on success; a negated <code>errno</code> is returned on failure.
  </p>
</ul>

<h5><a name="workavailable">4.5.2.3.4 <code>work_available()</code></a></h5>
<p>
  <b>Function Prototype</b>:
  <ul><pre>
#include &lt;nuttx/wqueue.h&gt;
bool work_available(FAR struct work_s *work);
</pre></ul>
</p>
<p>
  <b>Description</b>.
</p>
<p>
  <b>Input Parameters</b>:
  Check if the work structure is available.
</p>
<ul>
  <li>
    <p>
      <code>work</code>:
      The work queue structure to check.
    </p>
</ul>
<p>
  <b>Returned Value</b>:
</p>
<ul>
  <p>
  <code>true</code> if available; false if <code>busy</code> (i.e., there is still pending work).
  </p>
</ul>

<h5><a name="workusrstart">4.5.2.3.5 <code>work_usrstart()</code></a></h5>
<p>
  <b>Function Prototype</b>:
  <ul><pre>
#include &lt;nuttx/config.h&gt;
#include &lt;nuttx/wqueue.h&gt;
#if defined(CONFIG_LIB_USRWORK) && !defined(__KERNEL__)
int work_usrstart(void);
#endif
</pre></ul>
</p>
<p>
  <b>Description</b>.
  The function is only available as a user interface in the kernel-mode build.  In the flat build, there is no user-mode work queue; in the protected mode, the user-mode work queue will automatically be started by the OS start-up code.  But in the kernel mode, each user process will be required to start is own, private instance of the user-mode work thread using this interface.
</p>
<p>
  <b>Input Parameters</b>: None
</p>
<p>
  <b>Returned Value</b>:
</p>
<ul>
  <p>
     The task ID of the worker thread is returned on success.  A negated <code>errno</code> value is returned on failure.
  </p>
</ul>

<h5><a name="lpworkboostpriority">4.5.2.3.6 <code>lpwork_boostpriority()</code></a></h5>
<p>
  <b>Function Prototype</b>:
  <ul><pre>
#include &lt;nuttx/config.h&gt;
#include &lt;nuttx/wqueue.h&gt;
#if defined(CONFIG_SCHED_LPWORK) && defined(CONFIG_PRIORITY_INHERITANCE)
void lpwork_boostpriority(uint8_t reqprio);
#endif
</pre></ul>
</p>
<p>
  <b>Description</b>.
  Called by the work queue client to assure that the priority of the low-priority worker thread is at least at the requested level, <code>reqprio</code>.  This function would normally be called just before calling <code>work_queue()</code>.
</p>
<p>
  <b>Input Parameters</b>:
</p>
<ul>
  <li>
    <p>
      <code>reqprio</code>:
      Requested minimum worker thread priority.
    </p>
  </li>
</ul>
<p>
  <b>Returned Value</b>: None
</p>

<h5><a name="lpworkrestorepriority">4.5.2.3.7 <code>lpwork_restorepriority()</code></a></h5>
<p>
  <b>Function Prototype</b>:
  <ul><pre>
#include &lt;nuttx/config.h&gt;
#include &lt;nuttx/wqueue.h&gt;
#if defined(CONFIG_SCHED_LPWORK) && defined(CONFIG_PRIORITY_INHERITANCE)
void lpwork_restorepriority(uint8_t reqprio);
#endif
</pre></ul>
</p>
<p>
  <b>Description</b>.
  This function is called to restore the priority after it was previously boosted.  This is often done by client logic on the worker thread when the scheduled work completes.  It will check if we need to drop the priority of the worker thread.
</p>
<p>
  <b>Input Parameters</b>:
</p>
<ul>
  <li>
    <p>
      <code>reqprio</code>:
      Previously requested minimum worker thread priority to be &quot;unboosted&quot;.
    </p>
  </li>
</ul>
<p>
  <b>Returned Value</b>: None
</p>

<h2><a name="addrenv">4.6 Address Environments</a></h2>
<p>
  CPUs that support memory management units (MMUs) may provide <i>address environments</i> within which tasks and their child threads execute.
  The configuration indicates the CPUs ability to support address environments by setting the configuration variable <code>CONFIG_ARCH_HAVE_ADDRENV=y</code>.
  That will enable the selection of the actual address environment support which is indicated by the selection of the configuration variable  <code>CONFIG_ARCH_ADDRENV=y</code>.
  These address environments are created only when tasks are created via <code>exec()</code> or <code>exec_module()</code> (see <code>include/nuttx/binfmt/binfmt.h</code>).
</p>
<p>
  When <code>CONFIG_ARCH_ADDRENV=y</code> is set in the board configuration, the CPU-specific logic must provide a set of interfaces as defined in the header file <code>include/nuttx/arch.h</code>.
  These interfaces are listed below and described in detail in the following paragraphs.
</p>
<p>
  The CPU-specific logic must provide two categories in interfaces:
</p>
<ol>
  <li>
    <p>
      <b>Binary Loader Support</b>.
      These are low-level interfaces used in <code>binfmt/</code> to instantiate tasks with address environments.
      These interfaces all operate on type <code>group_addrenv_t</code> which is an abstract representation of a task group's address environment and the type must be defined in<code>arch/arch.h</code> if <code>CONFIG_ARCH_ADDRENV</code> is defined. These low-level interfaces include:
    </p>
    <ul>
      <li>
        <a href="#up_addrenv_create">4.6.1 <code>up_addrenv_create()</code></a>:
        Create an address environment.
      </li>
      <li>
        <a href="#up_addrenv_destroy">4.6.2 <code>up_addrenv_destroy()</code></a>:
        Destroy an address environment.
      </li>
      <li>
        <a href="#up_addrenv_vtext">4.6.3 <code>up_addrenv_vtext()</code></a>:
        Returns the virtual base address of the <code>.text</code> address environment.
      </li>
      <li>
        <a href="#up_addrenv_vdata">4.6.4 <code>up_addrenv_vdata()</code></a>:
        Returns the virtual base address of the <code>.bss</code>/<code>.data</code> address environment.
      </li>
      <li>
        <a href="#up_addrenv_heapsize">4.6.5 <code>up_addrenv_heapsize()</code></a>:
       Return the initial heap size.
      </li>
      <li>
        <a href="#up_addrenv_select">4.6.6 <code>up_addrenv_select()</code></a>:
        Instantiate an address environment.
      </li>
      <li>
        <a href="#up_addrenv_restore">4.6.7 <code>up_addrenv_restore()</code></a>:
        Restore an address environment.
      </li>
      <li>
        <a href="#up_addrenv_clone">4.6.8 <code>up_addrenv_clone()</code></a>:
        Copy an address environment from one location to another.
      </li>
    </ul>
  </li>
  <li>
    <p>
      <b>Tasking Support</b>.
      Other interfaces must be provided to support higher-level interfaces used by the NuttX tasking logic.
      These interfaces are used by the functions in <code>sched/</code> and all operate on the task group which as been assigned an address environment by <code>up_addrenv_clone()</code>.
    </p>
    <ul>
      <li>
        <a href="#up_addrenv_attach">4.6.9 <code>up_addrenv_attach()</code></a>:
        Clone the group address environment assigned to a new thread.
        This operation is done when a pthread is created that share's the same address environment.
      </li>
      <li>
        <a href="#up_addrenv_detach">4.6.10 <code>up_addrenv_detach()</code></a>:
        Release the thread's reference to a group address environment when a task/thread exits.
      </li>
    </ul>
  </li>
  <li>
    <p>
      <b>Dynamic Stack Support</b>.
      <code>CONFIG_ARCH_STACK_DYNAMIC=y</code> indicates that the user process stack resides in its own address space.
      This option is also <i>required</i> if <code> CONFIG_BUILD_KERNEL</code> and <code>CONFIG_LIBC_EXECFUNCS</code> are selected.
      Why?
      Because the caller's stack must be preserved in its own address space when we instantiate the environment of the new process in order to initialize it.
    </p>
    <p>
      <b>NOTE:</b> The naming of the <code>CONFIG_ARCH_STACK_DYNAMIC</code> selection implies that dynamic stack allocation is supported.
      Certainly this option must be set if dynamic stack allocation is supported by a platform.
      But the more general meaning of this configuration environment is simply that the stack has its own address space.
    </p>
    <p>
      If <code>CONFIG_ARCH_STACK_DYNAMIC=y</code> is selected then the platform specific code must export these additional interfaces:
    </p>
    <ul>
      <li>
        <a href="#up_addrenv_ustackalloc">4.6.11 <code>up_addrenv_ustackalloc()</code></a>:
        Create a stack address environment
      </li>
      <li>
        <a href="#up_addrenv_ustackfree">4.6.12 <code>up_addrenv_ustackfree()</code></a>:
        Destroy a stack address environment.
      </li>
      <li>
        <a href="#up_addrenv_vustack">4.6.13 <code>up_addrenv_vustack()</code></a>:
        Returns the virtual base address of the stack
      </li>
      <li>
        <a href="#up_addrenv_ustackselect">4.6.14 <code>up_addrenv_ustackselect()</code></a>:
        Instantiate a stack address environment
      </li>
    </ul>
  </li>
  <li>
    <p>
      If <code>CONFIG_ARCH_KERNEL_STACK</code> is selected, then each user process will have two stacks:  (1) a large (and possibly dynamic) user stack and (2) a smaller kernel stack.  However, this option is <i>required</i> if both <code>CONFIG_BUILD_KERNEL</code> and <code>CONFIG_LIBC_EXECFUNCS</code> are selected.  Why?  Because when we instantiate and initialize the address environment of the new user process, we will temporarily lose the address environment of the old user process, including its stack contents.  The kernel C logic will crash immediately with no valid stack in place.
    </p>
    <p>
      If <code>CONFIG_ARCH_KERNEL_STACK=y</code> is selected then the platform specific code must export these additional interfaces:
    </p>
    <ul>
      <li>
        <a href="#up_addrenv_kstackalloc">4.6.15 <code>up_addrenv_kstackalloc()</code></a>:
        Allocate the process kernel stack.
      </li>
        <a href="#up_addrenv_kstackfree">4.6.16 <code>up_addrenv_kstackfree()</code></a>:
        Free the process kernel stack.
      </li>
    </ul>
  </li>
</ol>

<h3><a name="up_addrenv_create">4.6.1 <code>up_addrenv_create()</code></a></h3>
<p><b>Function Prototype</b>:</p>
<ul>
  <code>int up_addrenv_create(size_t textsize, size_t datasize, size_t heapsize, FAR group_addrenv_t *addrenv);</code>
</ul>
<p><b>Description</b>:</p>
<ul>
  This function is called when a new task is created in order to instantiate an address environment for the new task group.
  <code>up_addrenv_create()</code> is essentially the allocator of the physical memory for the new task.
</ul>
<p><b>Input Parameters</b>:</p>
<ul>
  <li><code>textsize</code>: The size (in bytes) of the <code>.text</code> address environment needed by the task.  This region may be read/execute only.</li>
  <li><code>datasize</code>: The size (in bytes) of the <code>.bss/.data</code> address environment needed by the task.   This region may be read/write only.</li>
  <li><code>heapsize</code>: The initial size (in bytes) of the heap address environment needed by the task.  This region may be read/write only.</li>
  <li><code>addrenv</code>: The location to return the representation of the task address environment.</li>
</ul>
<p><b>Returned Value</b>:</p>
<ul>
  Zero (<code>OK</code>) on success; a negated <code>errno</code> value on failure.
</ul>

<h3><a name="up_addrenv_destroy">4.6.2 <code>up_addrenv_destroy()</code></a></h3>
<p><b>Function Prototype</b>:<p>
<ul>
  <code>int up_addrenv_destroy(group_addrenv_t *addrenv);</code>
</ul>
<p><b>Description</b>:</p>
<ul>
  This function is called when a final thread leaves the task group and the task group is destroyed.  This function then destroys the defunct address environment, releasing the underlying physical memory allocated by <code>up_addrenv_create()</code>.
</ul>
<p><b>Input Parameters</b>:</p>
<ul>
  <li><code>addrenv</code>: The representation of the task address environment previously returned by <code>up_addrenv_create()</code>.</li>
</ul>
<p><b>Returned Value</b>:</p>
<ul>
  Zero (<code>OK</code>) on success; a negated <code>errno</code> value on failure.
</ul>

<h3><a name="up_addrenv_vtext">4.6.3 <code>up_addrenv_vtext()</code></a></h3>
<p><b>Function Prototype</b>:<p>
<ul>
  <code>int up_addrenv_vtext(FAR group_addrenv_t addrenv, FAR void **vtext);</code>
</ul>
<p><b>Description</b>:</p>
<ul>
  Return the virtual <code>.text</code> address associated with the newly create address environment.
  This function is used by the binary loaders in order get an address that can be used to initialize the new task.
</ul>
<p><b>Input Parameters</b>:</p>
<ul>
  <li><code>addrenv</code>: The representation of the task address environment previously returned by <code>up_addrenv_create()</code>.</li>
  <li><code>vtext</code>: The location to return the virtual address.</li>
</ul>
<p><b>Returned Value</b>:</p>
<ul>
  Zero (<code>OK</code>) on success; a negated <code>errno</code> value on failure.
</ul>

<h3><a name="up_addrenv_vdata">4.6.4 <code>up_addrenv_vdata()</code></a></h3>
<p><b>Function Prototype</b>:<p>
<ul>
  <code>int up_addrenv_vdata(FAR group_addrenv_t *addrenv, size_t textsize, FAR void **vdata);</code>
</ul>
<p><b>Description</b>:</p>
<ul>
  Return the virtual <code>.text</code> address associated with the newly create address environment.
  This function is used by the binary loaders in order get an address that can be used to initialize the new task.
</ul>
<p><b>Input Parameters</b>:</p>
<ul>
  <li><code>addrenv</code>: The representation of the task address environment previously returned by <code>up_addrenv_create()</code>.</li>
  <li><code>textsize</code>: For some implementations, the text and data will be saved in the same memory region (read/write/execute) and, in this case, the virtual address of the data just lies at this offset into the common region.</li>
  <li><code>vdata</code>: The location to return the virtual address.</li>
</ul>
<p><b>Returned Value</b>:</p>
<ul>
  Zero (<code>OK</code>) on success; a negated <code>errno</code> value on failure.
</ul>

<h3><a name="up_addrenv_heapsize">4.6.5 <code>up_addrenv_heapsize()</code></a></h3>
<p><b>Function Prototype</b>:<p>
<ul>
  <code>ssize_t up_addrenv_heapsize(FAR const group_addrenv_t *addrenv);</code>
</ul>
<p><b>Description</b>:</p>
<ul>
  Return the initial heap allocation size.
  That is the amount of memory allocated by <code>up_addrenv_create()</code> when the heap memory region was first created.
  This may or may not differ from the <code>heapsize</code> parameter that was passed to <code>up_addrenv_create()</code>.
</ul>
<p><b>Input Parameters</b>:</p>
<ul>
  <li><code>addrenv</code>: The representation of the task address environment previously returned by <code>up_addrenv_create()</code>.</li>
</ul>
<p><b>Returned Value</b>:</p>
<ul>
  The initial heap size allocated is returned on success; a negated <code>errno</code> value on failure.
</ul>

<h3><a name="up_addrenv_select">4.6.6 <code>up_addrenv_select()</code></a></h3>
<p><b>Function Prototype</b>:<p>
<ul>
  <code>int up_addrenv_select(group_addrenv_t *addrenv, save_addrenv_t *oldenv);</code>
</ul>
<p><b>Description</b>:</p>
<ul>
  After an address environment has been established for a task (via <code>up_addrenv_create())</code>, this function may be called to instantiate that address environment in the virtual address space.
  This might be necessary, for example, to load the code for the task from a file or to access address environment private data.
</ul>
<p><b>Input Parameters</b>:</p>
<ul>
  <li><code>addrenv</code>: The representation of the task address environment previously returned by <code>up_addrenv_create()</code>.</li>
  <li><code>oldenv</code>:
    The address environment that was in place before <code>up_addrenv_select()</code> was called.
    This may be used with <code>up_addrenv_restore()</code> to restore the original  address environment that was in place before <code>up_addrenv_select()</code> was called.
    Note that this may be a task agnostic, platform-specific representation that may or may not be different from <code>group_addrenv_t</code>.
  </li>
</ul>
<p><b>Returned Value</b>:</p>
<ul>
  Zero (<code>OK</code>) on success; a negated <code>errno</code> value on failure.
</ul>

<h3><a name="up_addrenv_restore">4.6.7 <code>up_addrenv_restore()</code></a></h3>
<p><b>Function Prototype</b>:<p>
<ul>
  <code>int up_addrenv_restore(save_addrenv_t oldenv);</code>
</ul>
<p><b>Description</b>:</p>
<ul>
  After an address environment has been temporarily instantiated by <code>up_addrenv_select</code>,
  this function may be called to restore the original address environment.
</ul>
<p><b>Input Parameters</b>:</p>
<ul>
  <li><code>oldenv</code>: The platform-specific representation of the address environment previously returned by <code>up_addrenv_select()</code>.</li>
</ul>
<p><b>Returned Value</b>:</p>
<ul>
  Zero (<code>OK</code>) on success; a negated <code>errno</code> value on failure.
</ul>

<h3><a name="up_addrenv_clone">4.6.8 <code>up_addrenv_clone()</code></a></h3>
<p><b>Function Prototype</b>:<p>
<ul>
  <code>int up_addrenv_clone(FAR const task_group_s *src, FAR struct task_group_s *dest);</code>
</ul>
<p><b>Description</b>:</p>
<ul>
  Duplicate an address environment.  This does not copy the underlying memory, only the representation that can be used to instantiate that memory as an address environment.
</ul>
<p><b>Input Parameters</b>:</p>
<ul>
  <li><code>src</code>: The address environment to be copied.</li>
  <li><code>dest</code>: The location to receive the copied address environment.</li>
</ul>
<p><b>Returned Value</b>:</p>
<ul>
  Zero (<code>OK</code>) on success; a negated <code>errno</code> value on failure.
</ul>

<h3><a name="up_addrenv_attach">4.6.9 <code>up_addrenv_attach()</code></a></h3>
<p><b>Function Prototype</b>:<p>
<ul>
  <code>int up_addrenv_attach(FAR struct task_group_s *group, FAR struct tcb_s *tcb);</code>
</ul>
<p><b>Description</b>:</p>
<ul>
  <p>
  This function is called from the core scheduler logic when a thread is created that needs to share the address environment of its task group.
  In this case, the group's address environment may need to be &quot;cloned&quot; for the child thread.
  </p>
  <p>
  NOTE: In most platforms, nothing will need to be done in this case.
  Simply being a member of the group that has the address environment may be sufficient.
  </p>
</ul>
<p><b>Input Parameters</b>:</p>
<ul>
  <li><code>group</code>: The task group to which the new thread belongs.</li>
  <li><code>ctcb</code>: The TCB of the thread needing the address environment.</li>
</ul>
<p><b>Returned Value</b>:</p>
<ul>
  Zero (<code>OK</code>) on success; a negated <code>errno</code> value on failure.
</ul>

<h3><a name="up_addrenv_detach">4.6.10 <code>up_addrenv_detach()</code></a></h3>
<p><b>Function Prototype</b>:<p>
<ul>
  <code>int up_addrenv_detach(FAR struct task_group_s *group, FAR struct task_group_s *tcb);</code>
</ul>
<p><b>Description</b>:</p>
<ul>
  This function is called when a task or thread exits in order to release its reference to an address environment.  The address environment, however, should persist until up_addrenv_destroy() is called when the task group is itself destroyed.  Any resources unique to this thread  may be destroyed now.
</ul>
<p><b>Input Parameters</b>:</p>
<ul>
  <li><code>group</code>: The group to which the thread belonged.</li>
  <li><code>tcb</code>: The TCB of the task or thread whose the address environment will be released.</li>
</ul>
<p><b>Returned Value</b>:</p>
<ul>
  Zero (<code>OK</code>) on success; a negated <code>errno</code> value on failure.
</ul>

<h3><a name="up_addrenv_ustackalloc">4.6.11 <code>up_addrenv_ustackalloc()</code></a></h3>
<p><b>Function Prototype</b>:<p>
<ul>
  <code>int up_addrenv_ustackalloc(FAR struct tcb_s *tcb, size_t stacksize);</code>
</ul>
<p><b>Description</b>:</p>
<ul>
<p>
  This function is called when a new thread is created in order to instantiate an address environment for the new thread's stack.
  <code>up_addrenv_ustackalloc()</code> is essentially the allocator of the physical memory for the new task's stack.
</p>
</ul>
<p><b>Input Parameters</b>:</p>
<ul>
  <li><code>tcb</code>: The TCB of the thread that requires the stack address environment.</li>
  <li><code>stacksize</code>: The size (in bytes) of the initial stack address environment needed by the task.  This region may be read/write only.</li>
</ul>
<p><b>Returned Value</b>:</p>
<ul>
  Zero (<code>OK</code>) on success; a negated <code>errno</code> value on failure.
</ul>

<h3><a name="up_addrenv_up_addrenv_ustackfreeattach">4.6.12 <code>up_addrenv_ustackfree()</code></a></h3>
<p><b>Function Prototype</b>:<p>
<ul>
  <code>int up_addrenv_ustackfree(FAR struct tcb_s *tcb);</code>
</ul>
<p><b>Description</b>:</p>
<ul>
  <p>
    This function is called when any thread exits.
    This function then destroys the defunct address environment for the thread's stack, releasing the underlying physical memory.
  </p>
</ul>
<p><b>Input Parameters</b>:</p>
<ul>
  <li><code>tcb</code>: The TCB of the thread that no longer requires the stack address environment.</li>
</ul>
<p><b>Returned Value</b>:</p>
<ul>
  Zero (<code>OK</code>) on success; a negated <code>errno</code> value on failure.
</ul>

<h3><a name="up_addrenv_vustack">4.6.13 <code>up_addrenv_vustack()</code></a></h3>
<p><b>Function Prototype</b>:<p>
<ul>
  <code>int up_addrenv_vustack(FAR const struct tcb_s *tcb, FAR void **vstack);</code>
</ul>
<p><b>Description</b>:</p>
<ul>
  <p>
    Return the virtual address associated with the newly create stack address environment.
  </p>
</ul>
<p><b>Input Parameters</b>:</p>
<ul>
  <li><code>tcb</code>:The TCB of the thread with the stack address environment of interest. </li>
  <li><code>vstack</code>: The location to return the stack virtual base address.</li>
</ul>
<p><b>Returned Value</b>:</p>
<ul>
  Zero (<code>OK</code>) on success; a negated <code>errno</code> value on failure.
</ul>

<h3><a name="up_addrenv_ustackselect">4.6.14 <code>up_addrenv_ustackselect()</code></a></h3>
<p><b>Function Prototype</b>:<p>
<ul>
  <code>int up_addrenv_ustackselect(FAR const struct tcb_s *tcb);</code>
</ul>
<p><b>Description</b>:</p>
<ul>
  <P>
    After an address environment has been established for a task's stack (via <code>up_addrenv_ustackalloc()</code>.
    This function may be called to instantiate that address environment in the virtual address space.
    This is a necessary step before each context switch to the newly created thread (including the initial thread startup).
  </p>
</ul>
<p><b>Input Parameters</b>:</p>
<ul>
  <li><code>tcb</code>: The TCB of the thread with the stack address environment to be instantiated.</li>
</ul>
<p><b>Returned Value</b>:</p>
<ul>
  Zero (<code>OK</code>) on success; a negated <code>errno</code> value on failure.
</ul>

<h3><a name="up_addrenv_kstackalloc">4.6.15 <code>up_addrenv_kstackalloc()</code></a></h3>
<p><b>Function Prototype</b>:<p>
<ul>
  <code>int up_addrenv_kstackalloc(FAR struct tcb_s *tcb);</code>
</ul>
<p><b>Description</b>:</p>
<ul>
  <p>
    This function is called when a new thread is created to allocate the new thread's kernel stack.
    This function may be called for certain terminating threads which have no kernel stack.
    It must be tolerant of that case.
  </p>
</ul>
<p><b>Input Parameters</b>:</p>
<ul>
  <li><code>tcb</code>: The TCB of the thread that requires the kernel stack.</li>
</ul>
<p><b>Returned Value</b>:</p>
<ul>
  Zero (<code>OK</code>) on success; a negated <code>errno</code> value on failure.
</ul>

<h3><a name="up_addrenv_kstackfree">4.6.16 <code>up_addrenv_kstackfree()</code></a></h3>
<p><b>Function Prototype</b>:<p>
<ul>
  <code>int up_addrenv_kstackfree(FAR struct tcb_s *tcb);</code>
</ul>
<p><b>Description</b>:</p>
<ul>
  <p>
    This function is called when any thread exits.  This function frees the kernel stack.
  </p>
</ul>
<p><b>Input Parameters</b>:</p>
<ul>
  <li>
    <code>tcb</code>: The TCB of the thread that no longer requires the kernel stack.
  </li>
</ul>
<p><b>Returned Value</b>:</p>
<ul>
  Zero (<code>OK</code>) on success; a negated <code>errno</code> value on failure.
</ul>

<h2><a name="exports">4.7 APIs Exported by NuttX to Architecture-Specific Logic</a></h2>
<p>
  These are standard interfaces that are exported by the OS
  for use by the architecture specific logic.
</p>

<h3><a name="osstart">4.7.1 <code>nx_start()</code></a></h3>
<p>
  <b><i>To be provided</i></b>
</p>

<h3><a name="listmgmt">4.7.2 OS List Management APIs</a></h3></h3>
<p>
  <b><i>To be provided</i></b>
</p>

<h3><a name="schedprocesstimer">4.7.3 <code>nxsched_process_timer()</code></a></h3>
<p><b>Function Prototype</b>:</p>
<ul><pre>
#include &lt;nuttx/arch.h&gt;
void nxsched_process_timer(void);
</pre></ul>

<p><b>Description</b>.
  This function handles system timer events.
  The timer interrupt logic itself is implemented in the
  architecture specific code, but must call the following OS
  function periodically -- the calling interval must be
  <code>CONFIG_USEC_PER_TICK</code>.
</p>

<h3><a name="schedtimerexpiration">4.7.4 <code>nxsched_timer_expiration()</code></a></h3>
<p><b>Function Prototype</b>:<p>
<ul><pre>
#include &lt;nuttx/arch.h&gt;
void nxsched_timer_expiration(void);
</pre></ul>
<p><b>Description</b>:</p>
  Description: if <code>CONFIG_SCHED_TICKLESS</code> is defined, then this function is provided by the RTOS base code and called from platform-specific code when the interval timer used to implemented the tick-less OS expires.
<ul>
</ul>
<p><b>Input Parameters</b>:</p>
<ul>
  None
</ul>
<p><b>Returned Value</b>:</p>
<ul>
  None
</ul>
<p><b>Assumptions</b>:</p>
<ul>
  Base code implementation assumes that this function is called from interrupt handling logic with interrupts disabled.
</ul>

<h3><a name="schedalarmexpiration">4.7.5 <code>nxsched_alarm_expiration()</code></a></h3>
<p><b>Function Prototype</b>:<p>
<ul><pre>
#include &lt;nuttx/arch.h&gt;
void nxsched_timer_expiration(void);
</ul>
<p><b>Description</b>:</p>
  Description: if <code>CONFIG_SCHED_TICKLESS</code> is defined, then this function is provided by the RTOS base code and called from platform-specific code when the interval timer used to implemented the tick-less OS expires.
<ul>
</ul>
<p><b>Input Parameters</b>:</p>
<ul>
  None
</ul>
<p><b>Returned Value</b>:</p>
<ul>
  None
</ul>
<p><b>Assumptions</b>:</p>
<ul>
  Base code implementation assumes that this function is called from interrupt handling logic with interrupts disabled.
</ul>

<h3><a name="irqdispatch">4.7.6 <code>irq_dispatch()</code></a></h3>
<p><b>Function Prototype</b>: <code>void irq_dispatch(int irq, FAR void *context);</code></p>

<p><b>Description</b>.
  This function must be called from the architecture-
  specific logic in order to display an interrupt to
  the appropriate, registered handling logic.
</p>

<h2><a name="internalOS">4.8 Application OS vs. Internal OS Interfaces</a></h2>

<p>
  NuttX provides a standard, portable OS interface for use by applications.
  This standard interface is controlled by the specifications proved at <a href="http://opengroup.org">OpenGroup.org</a>.
  These application interfaces, in general, should not be used directly by logic executing within the OS.  The reason for this is that there are certain properties of the standard application interfaces that make them unsuitable for use within the OS
  These properties include:
</p>
<ol>
  <li>
    <p>
      <b>Use of the <i>per-thread</i> <code>errno</code> variable</b>:
      Handling of return values, particularly, in the case of returned error indications.
      Most legacy POSIX OS interface return information via a <i>per-thread</i> <code>errno</code>.
      There must be no alteration of the <code>errno</code> value that must be stable from the point of view of the application.
      So, as a general rule, internal OS logic must never modify the <code>errno</code> and particularly not by the inappropriate use of application OS interfaces within OS itself.
    </p>
    <p>
      Within the OS, functions do not return error information via the <code>errno</code> variable.  Instead, the majority of internal OS function return error information as an integer value:  Returned values greater than or equal to zero are success values; returned values less than zero indicate failures.
      Failures are reported by returning a negated <code>errno</code> value from <code>include/errno.h</code>,
    </p>
  <li>
    <p><b>Cancellation Points</b>:
      Many of the application OS interfaces are <i>cancellation points</i>, i.e., when the task is operating in <i>deferred cancellation</i> state, it cannot be deleted or cancelled until it calls an application OS interface that is a cancellation point.
    </p>
    <p>
      The POSIX specification is very specific about this, specific both in identifying which application OS interfaces are cancellation points and specific in the fact that it is prohibited for any OS operation other than those listed in the specification to generate cancellation points.
      If internal OS logic were to re-use application OS interfaces directly then it could very easily violate this POSIX requirement by incorrectly generating cancellation points on inappropriate OS operations and could result in very difficult to analyze application failures.
    </p>
  </li>
  <li>
     <p><b>Use of <i>per-task</i> Resources</b>:
       Many resources are only valid in the task group context in which a thread operates.  Above we mentioned one:  <code>errno</code> is only valid for the thread that is currently executing.  So, for example, the <code>errno</code> at the time of a call is a completely different variable than, say, the <code>errno</code> while running in a work queue task.
     </p>
     <p>
       File descriptors are an even better example:  An open file on file descriptor 5 on task A is <i>not</i> the same open file as might be used on file descriptor 5 on task B.
     </p>
     <p>
       As a result, internal OS logic may not use application OS interfaces that use file descriptors or any other <i>per-task</i> resource.
     </p>
  </li>
</ol>
<p>
  Within NuttX, this is handled by supporting equivalent internal OS interfaces that do not break the above rules.
  These internal interfaces are intended for use <i>only</i> within the OS and should not be used by application logic.
  Some examples include:
</p>
<ul>
  <li>
    <p>
      <b><code>nxsem_wait()</code></b>:
      <code>nxsem_wait()</code> is functionally equivalent to the standard application interface <code>sem_wait()</code>.  However, <code>nxsem_wait()</code> will not modify the errno value and will not cause a cancellation point.
      (see <code>include/nuttx/semaphore.h</code> for other internal OS interfaces for semaphores).
    </p>
  </li>
  <li>
    <p>
      <b><code>nxsig_waitinfo()</code></b>:
      <code>nxsig_waitinfo()</code> is functionally equivalent to the standard application interface <code>sigwaitinfo()</code>.  However, <code>nxsig_waitinfo()</code> will not modify the errno value and will not cause a cancellation point (see <code>include/nuttx/signal.h</code> for other internal OS interfaces for signals).
    </p>
  </li>
  <li>
    <p>
      <b><code>nxmq_send()</code></b>:
      <code>nxmq_send()</code> is functionally equivalent to the standard application interface <code>mq_send()</code>.  However, <code>nxmq_send()</code> will not modify the errno value and will not cause a cancellation point (see <code>include/nuttx/mqueue.h</code> for other internal OS interfaces for POSIX message queues).
    </p>
  </li>
  <li>
    <p>
      <b><code>file_read()</code></b>:
      <code>file_read()</code> is functionally equivalent to the standard application interface <code>read()</code>.  However, <code>file_read()</code> will not modify the errno value, will not cause a cancellation point, and uses a special internal data structure in place of the file descriptor (see <code>include/nuttx/fs/fs.h</code> for other internal OS interfaces for VFS functions).
    </p>
  </li>
  <li>
    <p>
      <b><code>psock_recvfrom()</code></b>:
      <code>psock_recvfrom()</code> is functionally equivalent to the standard application interface <code>recvfrom()</code>.  However, <code>psock_recvfrom()</code> will not modify the errno value, will not cause a cancellation point, and uses a special internal data structure in place of the socket descriptor (see <code>include/nuttx/net/net.h</code> for other internal OS interfaces for sockets).
    </p>
  </li>
</ul>

<h2><a name="boardctl">4.9 <code>boardctl()</code> Application Interface</a></h2>

<p><b>Function Prototype</b>:<p>
<ul>
  <code>
  include &lt;sys/boardctl.h&gt;<br>
  int boardctl(unsigned int cmd, uintptr_t arg);
  </code>
</ul>
<p><b>Description</b>:</p>
<ul>
  <p>
    In a small embedded system, there will typically be a much greater interaction between application and low-level board features.
    The canonically correct to implement such interactions is by implementing a character driver and performing the interactions via low level <code>ioctl()</code> calls.
    This, however, may not be practical in many cases and will lead to &quot;correct&quot; but awkward implementations.
  </p>
  <p>
    <code>boardctl()</code> is <i>non-standard</i> OS interface to alleviate the problem.
    It basically circumvents the normal device driver <code>ioctl()</code> interlace and allows the application to perform direct IOCTL-like calls to the board-specific logic.
    It is especially useful for setting up board operational and test configurations.
  </p>
  <p>
    <b>NOTE:</b> The other interfaces described in this document are internal OS interface.
    <code>boardctl()</code> is an application interface to the OS.
    There is no point, in fact, of using <code>boardctl()</code> within the OS;
    the board interfaces prototyped in <code>include/nuttx/board.h</code> may be called directly from within the OS.
  </p>
  <p>
    Application interfaces are described in the <a href="NuttxUserGuide.html">NuttX User Guide</a>.
    This application interface interface is described here only because it is so non-standard and because it is so closely tied to board porting logic.
  </p>
</ul>
<p><b>Input Parameters</b>:</p>
<ul>
  <li>
    <code>cmd</code>: Identifies the board command to be executed.
    See <code>include/sys/boardctl.h</code> for the complete list of common board commands.
    Provisions are made to support non-common, board-specific commands as well.
  </li>
  <li>
    <code>arg</code>: The argument that accompanies the command.
    The nature of the argument is determined by the specific command.
  </li>
</ul>
<p><b>Returned Value</b>:</p>
<ul>
  On success zero (<code>OK</code>) is returned;
  -1 (<code>ERROR</code>) is returned on failure with the <code>errno</code> variable set to indicate the nature of the failure.
</ul>

<h4><a name="boardsmp">4.10 Symmetric Multiprocessing (SMP) Application Interface</a></h4>
<p>
According to Wikipedia: "Symmetric multiprocessing (SMP) involves a symmetric multiprocessor system hardware and software architecture where two or more identical processors connect to a single, shared main memory, have full access to all I/O devices, and are controlled by a single operating system instance that treats all processors equally, reserving none for special purposes. Most multiprocessor systems today use an SMP architecture. In the case of multi-core processors, the SMP architecture applies to the cores, treating them as separate processors.
</p>
<p>
"SMP systems are tightly coupled multiprocessor systems with a pool of homogeneous processors running independently, each processor executing different programs and working on different data and with capability of sharing common resources (memory, I/O device, interrupt system and so on) and connected using a system bus or a crossbar."
</p>
<p>
For a technical description of the NuttX implementation of SMP, see the NuttX <a href="http://www.nuttx.org/doku.php?id=wiki:nxinternal:smp">SMP Wiki Page</a>.
</p>

  None
</ul>

<h3><a name="uptestset">4.10.1 <code>up_testset()</code></a></h3>
<p><b>Function Prototype</b>:<p>
<ul><pre>
#include &lt;nuttx/spinlock.h&gt;
#ifdef CONFIG_SPINLOCK
spinlock_t up_testset(volatile FAR spinlock_t *lock);
#endif
</pre></ul>

<p><b>Description</b>:</p>
<ul>
  <p>
    Perform and atomic test and set operation on the provided spinlock.
  </p>
</ul>
<p><b>Input Parameters</b>:</p>
<ul>
  <li>
    <code>lock</code>: The address of spinlock object.
  </li>
</ul>
<p><b>Returned Value</b>:</p>
<ul>
  <p>
    The spinlock is always locked upon return.
    The value of previous value of the spinlock variable is returned, either <code>SP_LOCKED</code> if the spinlock was previously locked (meaning that the test-and-set operation failed to obtain the lock) or <code>SP_UNLOCKED</code> if the spinlock was previously unlocked (meaning that we successfully obtained the lock)
  </p>
</ul>

<h3><a name="upcpuindex">4.10.2 <code>up_cpu_index()</code></a></h3>
<p><b>Function Prototype</b>:<p>
<ul><pre>
#include &lt;nuttx/arch.h&gt;
#ifdef CONFIG_SMP
int up_cpu_index(void);
#else
#  define up_cpu_index() (0)
#endif
</pre></ul>

<p><b>Description</b>:</p>
<ul>
  <p>
    Return an index in the range of 0 through <code>(CONFIG_SMP_NCPUS-1)</code> that corresponds to the currently executing CPU.
  </p>
</ul>
<p><b>Input Parameters</b>:</p>
<ul>
  None
</ul>
<p><b>Returned Value</b>:</p>
<ul>
  <p>
    An integer index in the range of 0 through <code>(CONFIG_SMP_NCPUS-1)</code> that corresponds to the currently executing CPU.
  </p>
</ul>

<h3><a name="upcpustart">4.10.3 <code>up_cpu_start()</code></a></h3>
<p><b>Function Prototype</b>:<p>
<ul><pre>
#include &lt;nuttx/arch.h&gt;
#ifdef CONFIG_SMP
int up_cpu_start(int cpu);
#endif
</pre></ul>

<p><b>Description</b>:</p>
<ul>
  <p>
    In an SMP configuration, only one CPU is initially active (CPU 0).
    System initialization occurs on that single thread.
    At the completion of the initialization of the OS, just before beginning normal multitasking, the additional CPUs would be started by calling this function.
  </p>
  <p>
    Each CPU is provided the entry point to is IDLE task when started.
    A TCB for each CPU's IDLE task has been initialized and placed in the  CPU's <code>g_assignedtasks[cpu]</code> list.
    A stack has also been allocated and initialized.
  </p>
  <p>
    The OS initialization logic calls this function repeatedly until each CPU has been started, 1 through <code>(CONFIG_SMP_NCPUS-1)</code>.
  </p>
</ul>
<p><b>Input Parameters</b>:</p>
<ul>
  <li>
    <code>cpu</code>: The index of the CPU being started.
    This will be a numeric value in the range of from one to <code>(CONFIG_SMP_NCPUS-1)</code>).
    (CPU 0 is already active).
  </li>
</ul>
<p><b>Returned Value</b>:</p>
<ul>
  <p>
    Zero (<code>OK</code>) is returned on success; a negated <code>errno</code> value on failure.
  </p>
</ul>

<h3><a name="upcpupause">4.10.4 <code>up_cpu_pause()</code></a></h3>
<p><b>Function Prototype</b>:<p>
<ul><pre>
#include &lt;nuttx/arch.h&gt;
#ifdef CONFIG_SMP
int up_cpu_pause(int cpu);
#endif
</pre></ul>

<p><b>Description</b>:</p>
<ul>
  <p>
    Save the state of the current task at the head of the <code>g_assignedtasks[cpu]</code> task list and then pause task execution on the CPU.
  </p>
  <p>
    This function is called by the OS when the logic executing on one CPU needs to modify the state of the <code>g_assignedtasks[cpu]</code> list for another CPU.
  </p>
</ul>
<p><b>Input Parameters</b>:</p>
<ul>
  <li>
    <code>cpu</code>: The index of the CPU to be paused.
    This will not be the index of the currently executing CPU.
  </li>
</ul>
<p><b>Returned Value</b>:</p>
<ul>
  <p>
    Zero (<code>OK</code>) is returned on success; a negated <code>errno</code> value on failure.
  </p>
</ul>

<h3><a name="upcpuresume">4.10.5 <code>up_cpu_resume()</code></a></h3>
<p><b>Function Prototype</b>:<p>
<ul><pre>
#include &lt;nuttx/arch.h&gt;
#ifdef CONFIG_SMP
int up_cpu_resume(int cpu);
#endif
</pre></ul>

<p><b>Description</b>:</p>
<ul>
  <p>
    Restart the cpu after it was paused via <code>up_cpu_pause()</code>, restoring the state of the task at the head of the <code>g_assignedtasks[cpu]</code> list, and resume normal tasking.
  </p>
  <p>
    This function is called after <code>up_cpu_pause()</code> in order resume operation of the CPU after modifying its <code>g_assignedtasks[cpu]</code> list.
  </p>
</ul>
<p><b>Input Parameters</b>:</p>
<ul>
  <li>
    <code>cpu</code>: The index of the CPU being resumed.
    This will not be the index of the currently executing CPU.
  </li>
</ul>
<p><b>Returned Value</b>:</p>
<ul>
  <p>
    Zero (<code>OK</code>) is returned on success; a negated <code>errno</code> value on failure.
  </p>
</ul>

<h2><a name="shm">4.11 Shared Memory</a></h2>
<p>
  Shared memory interfaces are only available with the NuttX kernel build (<code>CONFIG_BUILD_KERNEL=y</code>).
  These interfaces support user memory regions that can be shared between multiple user processes.
  The user interfaces are provided in the standard header file <code>include/sys/shm.h></code>.
  All logic to support shared memory is implemented within the NuttX kernel with the exception of two low-level functions that are require to configure the platform-specific MMU resources.
  Those interfaces are described below:
</p>

<h3><a name="upshmat">4.11.1 <code>up_shmat()</code></a></h3>
<p><b>Function Prototype</b>:<p>
<ul><pre>
#include &lt;nuttx/arch.h&gt;
#ifdef CONFIG_MM_SHM
int up_shmat(FAR uintptr_t *pages, unsigned int npages, uintptr_t vaddr);
#endif
</ul>
<p><b>Description</b>:</p>
<ul>
  Attach, i.e, map, on shared memory region to a user virtual address.
</ul>
<p><b>Input Parameters</b>:</p>
<ul>
  <li>
    <code>pages</code>: A pointer to the first element in a array of physical address, each corresponding to one page of memory.
  </li>
  <li>
    <code>npages</code>: The number of pages in the list of physical pages to be mapped.
  </li>
  <li>
    <code>vaddr</code>: The virtual address corresponding to the beginning of the (contiguous) virtual address region.
  </li>
</ul>
<p><b>Returned Value</b>:</p>
<ul>
  Zero (<code>OK</code>) is returned on success; a negated <code>errno</code> value is returned on failure.
</ul>

<h3><a name="upshmdt">4.11.2 <code>up_shmdt()</code></a></h3>
<p><b>Function Prototype</b>:<p>
<ul><pre>
#include &lt;nuttx/arch.h&gt;
#ifdef CONFIG_MM_SHM
int up_shmdt(uintptr_t vaddr, unsigned int npages);
#endif
</ul>
<p><b>Description</b>:</p>
<ul>
  Detach, i.e, unmap, on shared memory region from a user virtual address.
</ul>
<p><b>Input Parameters</b>:</p>
<ul>
  <li>
    <code>vaddr</code>: The virtual address corresponding to the beginning of the (contiguous) virtual address region.
  </li>
  <li>
    <code>npages</code>: T The number of pages to be unmapped.
  </li>
</ul>
<p><b>Returned Value</b>:</p>
<ul>
  Zero (<code>OK</code>) is returned on success; a negated <code>errno</code> value is returned on failure.
</ul>

<h2><a name="demandpaging">4.12 On-Demand Paging</a></h2>
<p>
  The NuttX On-Demand Paging feature permits embedded MCUs with some limited RAM space to execute large programs from some non-random access media.
  If the platform meets certain requirements, then NuttX can provide on-demand paging:
  It can copy .text from the large program in non-volatile media into RAM as needed to execute a huge program from the small RAM.
  Design and porting issues for this feature are discussed in a separate document.
  Please see the <a href="NuttXDemandPaging.html">NuttX Demand Paging</a> design document for further information.
</p>

<h2><a name="ledsupport">4.13 LED Support</a></h2>

<p>
  A board architecture may or may not have LEDs.
  If the board does have LEDs, then most architectures provide similar LED support that is enabled when <code>CONFIG_ARCH_LEDS</code>
  is selected in the NuttX configuration file.
  This LED support is part of architecture-specific logic and is not managed by the core NuttX logic.
  However, the support provided by each architecture is sufficiently similar that it can be documented here.
</p>

<h3><a name="ledheaders">4.13.1 Header Files</a></h3>

<p>
  LED-related definitions are provided in two header files:
  <ul>
    <li>
       LED definitions are provided for each board in the <code>board.h</code> that resides
       in the <code><i>&lt;board-name&gt;</i>/include/board.h</code> file (which is also
       linked to <code>include/arch/board/board.h</code> when the RTOS is configured).
       Those definitions are discussed <a href="#leddefinitions">below</a>.
    </li>
    <li>
       The board-specific logic provides unique instances of the LED interfaces.
       This is because the implementation of LED support may be very different
       on different boards.
       Prototypes for these board-specific implementations are, however, provided
       in architecture-common header files.
       That header file is usually at <code><i>&lt;arch-name&gt;</i>/src/common/up_internal.h</code>,
       but could be at other locations in particular architectures.
       These prototypes are discussed <a href="#ledapis">below</a>.
    </li>
  </ul>
</p>

<h3><a name="leddefinitions">4.13.2 LED Definitions</a></h3>

<p>
   The implementation of LED support is very specific to a board architecture.
   Some boards have several LEDS, others have only one or two.
   Some have none.
   Others LED matrices and show alphanumeric data, etc.
   The NuttX logic does not refer to specific LEDS, rather, it refers to an event to be shown on the LEDS
   in whatever manner is appropriate for the board;
   the way that this event is presented depends upon the hardware available on the board.
</p>
<p>
   The model used by NuttX is that the board can show 8 events defined as follows in <code><i>&lt;board-name&gt;</i>/include/board.h</code>:
</p>
<ul><pre>
#define LED_STARTED       ??
#define LED_HEAPALLOCATE  ??
#define LED_IRQSENABLED   ??
#define LED_STACKCREATED  ??
#define LED_INIRQ         ??
#define LED_SIGNAL        ??
#define LED_ASSERTION     ??
#define LED_PANIC         ??
</pre></ul>
<p>
  The specific value assigned to each pre-processor variable can be whatever makes the implementation easiest for the board logic.
  The <i>meaning</i> associated with each definition is as follows:
</p>
<ul>
  <li>
    <code>LED_STARTED</code> is the value that describes the setting of the LEDs when the LED logic is first initialized.
    This LED value is set but never cleared.
  </li>
  <li>
    <code>LED_HEAPALLOCATE</code> indicates that the NuttX heap has been configured.
    This is an important place in the boot sequence because if the memory is configured wrong, it will probably crash leaving this LED setting.
    This LED value is set but never cleared.
  </li>
  <li>
    <code>LED_IRQSENABLED</code> indicates that interrupts have been enabled.
    Again, during bring-up (or if there are hardware problems), it is very likely that the system may crash just when interrupts are enabled, leaving this setting on the LEDs.
    This LED value is set but never cleared.
  </li>
  <li>
    <code>LED_STACKCREATED</code> is set each time a new stack is created.
    If set, it means that the system attempted to start at least one new thread.
    This LED value is set but never cleared.
  </li>
  <li>
    <code>LED_INIRQ</code> is set and cleared on entry and exit from each interrupt.
    If interrupts are working okay, this LED will have a dull glow.
  </li>
  <li>
    <code>LED_SIGNAL</code> is set and cleared on entry and exit from a signal handler.
    Signal handlers are tricky so this is especially useful during bring-up or a new architecture.
  </li>
  <li>
    <code>LED_ASSERTION</code> is set if an assertion occurs.
  </li>
  <li>
    <code>LED_PANIC</code> will blink at around 1Hz if the system panics and hangs.
  </li>
</ul>

<h3><a name="ledapis">4.13.3 Common LED interfaces</a></h3>

<p>
  The <code>include/nuttx/board.h</code> has declarations like:
</p>
<ul><pre>
#ifdef CONFIG_ARCH_LEDS
void board_autoled_initialize(void);
void board_autoled_on(int led);
void board_autoled_off(int led);
#else
# define board_autoled_initialize()
# define board_autoled_on(led)
# define board_autoled_off(led)
#endif
</pre></ul>
<p>
   Where:
<p>
<ul>
  <li>
  <p>
    <code>void board_autoled_initialize(void)</code> is called early in power-up initialization to initialize the LED hardware.
  </p>
  <small><blockquote>
    <b>NOTE:</b> In most architectures, <code>board_autoled_initialize()</code> is called from board-specific initialization logic.
    But there are a few architectures where this initialization function is still called from common chip architecture logic.
    This interface is not, however, a common board interface in any event.
  </blockquote>
  <blockquote>
    <b>WARNING:</b> This interface name will eventually be removed; do not use it in new board ports.
    New implementations should not use the naming convention for common board interfaces, but should instead use the naming conventions for microprocessor-specific interfaces or the board-specific interfaces (such as <code>stm32_led_initialize()</code>).
  </blockquote></small>
  </li>
  <li>
  <p>
    <code>board_autoled_on(int led)</code> is called to instantiate the LED presentation of the event.
    The <code>led</code> argument is one of the definitions provided in <code><i>&lt;board-name&gt;</i>/include/board.h</code>.
  </p>
  </li>
  <p>
  <li>
    <code>board_autoled_off(int led</code>is called to terminate the LED presentation of the event.
    The <code>led</code> argument is one of the definitions provided in <code><i>&lt;board-name&gt;</i>/include/board.h</code>.
    Note that only <code>LED_INIRQ</code>, <code>LED_SIGNAL</code>, <code>LED_ASSERTION</code>, and <code>LED_PANIC</code>
    indications are terminated.
  </p>
  </li>
</ul>

<h2><a name="iobs">4.14 I/O Buffer Management</a></h2>

NuttX supports generic I/O buffer management (IOB) logic.
This logic was originally added to support network I/O buffering, but has been generalized to meet buffering requirements by all device drivers.
At the time of this writing, IOBs are currently used not only be networking but also by logic in <code>drivers/syslog</code> and <code>drivers/wireless</code>.
NOTE that some of the wording in this section still reflects those legacy roots as a part of the networking subsystem.
This objectives of this feature are:

<ol>
  <li>
    Provide common I/O buffer management logic for all drivers,
  </li>
  <li>
    Support I/O buffer allocation from both the tasking and interrupt level contexts.
  </li>
  <li>
    Use a fixed amount of pre-allocated memory.
  </li>
  <li>
    No costly, non-deterministic dynamic memory allocation.
  </li>
  <li>
    When the fixed number of pre-allocated I/O buffers is exhausted, further attempts to allocate memory from tasking logic will cause the task to block and wait until a an I/O buffer to be freed.
  </li>
  <li>
    Each I/O buffer should be small, but can be chained together to support buffering of larger thinks such as full size network packets.
  </li>
  <li>
    Support <i>throttling</i> logic to prevent lower priority tasks from hogging all available I/O buffering.
  </li>
</ol>

<h3><a name="iobconfig">4.14.1 Configuration Options</a></h3>

<dl>
  <dt><code>CONFIG_MM_IOB</code>
  <dd>Enables generic I/O buffer support.  This setting will build the common I/O buffer (IOB) support library.

  <dt><code>CONFIG_IOB_NBUFFERS</code>
  <dd>Number of pre-allocated I/O buffers.  Each packet is represented by a series of small I/O buffers in a chain.  This setting determines the number of preallocated I/O buffers available for packet data.

  The default value is setup for network support.  The default is 8 buffers if neither TCP/UDP or write buffering is enabled (neither <code>CONFIG_NET_TCP_WRITE_BUFFERS</code> nor <code>CONFIG_NET_TCP</code>), 24 if only TCP/UDP is enabled, and 36 if both TCP/UDP and write buffering are enabled.

  <dt><code>CONFIG_IOB_BUFSIZE</code>
  <dd>Payload size of one I/O buffer.  Each packet is represented by a series of small I/O buffers in a chain.  This setting determines the data payload each preallocated I/O buffer.  The default value is 196 bytes.

  <dt><code>CONFIG_IOB_NCHAINS</code>
  <dd>Number of pre-allocated I/O buffer chain heads.  These tiny nodes are used as <i>containers</i> to support queueing of I/O buffer chains.  This will limit the number of I/O transactions that can be <i>in-flight</i> at any give time.  The default value of zero disables this features.

  <dd>These generic I/O buffer chain containers are not currently used by any logic in NuttX.  That is because their other other specialized I/O buffer chain containers that also carry a payload of usage specific information.

  The default value is zero if nether TCP nor UDP is enabled (i.e., neither <code>CONFIG_NET_TCP</code> && !<code>CONFIG_NET_UDP</code> or eight if either is enabled.

  <dt><code>CONFIG_IOB_THROTTLE</code>
  <dd>I/O buffer throttle value.  TCP write buffering and read-ahead buffer use the same pool of free I/O buffers.  In order to prevent uncontrolled incoming TCP packets from hogging all of the available, pre-allocated I/O buffers, a throttling value is required.  This throttle value assures that I/O buffers will be denied to the read-ahead logic before TCP writes are halted.

  The default 0 if neither TCP write buffering nor TCP read-ahead buffering is enabled.  Otherwise, the default is 8.

  <dt><code>CONFIG_IOB_DEBUG</code>
  <dd>Force I/O buffer debug. This option will force debug output from I/O buffer logic.  This is not normally something that would want to do but is convenient if you are debugging the I/O buffer logic and do not want to get overloaded with other un-related debug output.

  NOTE that this selection is not available if DEBUG features are not enabled (<code>CONFIG_DEBUG_FEATURES</code>) with IOBs are being used to syslog buffering logic (<code>CONFIG_SYSLOG_BUFFER</code>).
</dl>

<h3><a name="iobthrottle">4.14.2 Throttling</a></h3>

<b></b>
An allocation throttle was added.  I/O buffer allocation logic supports a throttle value originally for read-ahead buffering to prevent the read-ahead logic from consuming all available I/O buffers and blocking the write buffering logic.  This throttle logic is only needed for networking only if both write buffering and read-ahead buffering are used.  Of use of I/O buffering might have other motivations for throttling.

<h3><a name="iobtypes">4.14.3 Public Types</a></h3>

<p>
  This structure represents one I/O buffer.  A packet is contained by one or more I/O buffers in a chain.  The <code>io_pktlen</code> is only valid for the I/O buffer at the head of the chain.
</p>

<pre>
struct iob_s
{
  /* Singly-link list support */

  FAR struct iob_s *io_flink;

  /* Payload */

#if CONFIG_IOB_BUFSIZE < 256
  uint8_t  io_len;      /* Length of the data in the entry */
  uint8_t  io_offset;   /* Data begins at this offset */
#else
  uint16_t io_len;      /* Length of the data in the entry */
  uint16_t io_offset;   /* Data begins at this offset */
#endif
  uint16_t io_pktlen;   /* Total length of the packet */

  uint8_t  io_data[CONFIG_IOB_BUFSIZE];
};
</pre>

<p>
  This container structure supports queuing of I/O buffer chains.  This structure is intended only for internal use by the IOB module.
</p>

<pre>
#if CONFIG_IOB_NCHAINS > 0
struct iob_qentry_s
{
  /* Singly-link list support */

  FAR struct iob_qentry_s *qe_flink;

  /* Payload -- Head of the I/O buffer chain */

  FAR struct iob_s *qe_head;
};
#endif /* CONFIG_IOB_NCHAINS > 0 */
</pre>

<p>
  The I/O buffer queue head structure.
</p>

<pre>
#if CONFIG_IOB_NCHAINS > 0
struct iob_queue_s
{
  /* Head of the I/O buffer chain list */

  FAR struct iob_qentry_s *qh_head;
  FAR struct iob_qentry_s *qh_tail;
};
#endif /* CONFIG_IOB_NCHAINS > 0 */
</pre>

<h3><a name="iobprotos">4.14.4 Public Function Prototypes</a></h3>

<ul>
  <li><a href="#iob_initialize">4.14.4.1 <code>iob_initialize()</code></a></li>
  <li><a href="#iob_alloc">4.14.4.2 <code>iob_alloc()</code></a></li>
  <li><a href="#iob_tryalloc">4.14.4.3 <code>iob_tryalloc()</code></a></li>
  <li><a href="#iob_free">4.14.4.4 <code>iob_free()</code></a></li>
  <li><a href="#iob_free_chain">4.14.4.5 <code>iob_free_chain()</code></a></li>
  <li><a href="#iob_add_queue">4.14.4.6 <code>iob_add_queue()</code></a></li>
  <li><a href="#iob_tryadd_queue">4.14.4.7 <code>iob_tryadd_queue()</code></a></li>
  <li><a href="#iob_remove_queue">4.14.4.8 <code>iob_remove_queue()</code></a></li>
  <li><a href="#iob_peek_queue">4.14.4.9 <code>iob_peek_queue()</code></a></li>
  <li><a href="#iob_free_queue">4.14.4.10 <code>iob_free_queue()</code></a></li>
  <li><a href="#iob_copyin">4.14.4.11 <code>iob_copyin()</code></a></li>
  <li><a href="#iob_trycopyin">4.14.4.12 <code>iob_trycopyin()</code></a></li>
  <li><a href="#iob_copyout">4.14.4.13 <code>iob_copyout()</code></a></li>
  <li><a href="#iob_clone">4.14.4.14 <code>iob_clone()</code></a></li>
  <li><a href="#iob_concat">4.14.4.15 <code>iob_concat()</code></a></li>
  <li><a href="#iob_trimhead">4.14.4.16 <code>iob_trimhead()</code></a></li>
  <li><a href="#iob_trimhead_queue">4.14.4.17 <code>iob_trimhead_queue()</code></a></li>
  <li><a href="#iob_trimtail">4.14.4.18 <code>iob_trimtail()</code></a></li>
  <li><a href="#iob_pack">4.14.4.19 <code>iob_pack()</code></a></li>
  <li><a href="#iob_contig">4.14.4.20 <code>iob_contig()</code></a></li>
  <li><a href="#iob_dump">4.14.4.21 <code>iob_dump()</code></a></li>
</ul>

<h4><a name="iob_initialize">4.14.4.1 <code>iob_initialize()</code></a></h4>
<p><b>Function Prototype</b>:
<pre>
#include &lt;nuttx/mm/iob.h&gt;
void iob_initialize(void);
</pre>

<p><b>Description</b>.
  Set up the I/O buffers for normal operations.
</p>

<h4><a name="iob_alloc">4.14.4.2 <code>iob_alloc()</code></a></h4>
<p><b>Function Prototype</b>:
<pre>
#include &lt;nuttx/mm/iob.h&gt;
FAR struct iob_s *iob_alloc(bool throttled);
</pre>

<p><b>Description</b>.
  Allocate an I/O buffer by taking the buffer at the head of the free list.
</p>

<h4><a name="iob_tryalloc">4.14.4.3 <code>iob_tryalloc()</code></a></h4>
<p><b>Function Prototype</b>:
<pre>
#include &lt;nuttx/mm/iob.h&gt;
FAR struct iob_s *iob_tryalloc(bool throttled);
</pre>

<p><b>Description</b>.
  Try to allocate an I/O buffer by taking the buffer at the head of the free list without waiting for a buffer to become free.
</p>

<h4><a name="iob_free">4.14.4.4 <code>iob_free()</code></a></h4>
<p><b>Function Prototype</b>:
<pre>
#include &lt;nuttx/mm/iob.h&gt;
FAR struct iob_s *iob_free(FAR struct iob_s *iob);
</pre>

<p><b>Description</b>.
   Free the I/O buffer at the head of a buffer chain returning it to the free list.  The link to  the next I/O buffer in the chain is return.
</p>

<h4><a name="iob_free_chain">4.14.4.5 <code>iob_free_chain()</code></a></h4>
<p><b>Function Prototype</b>:
<pre>
#include &lt;nuttx/mm/iob.h&gt;
void iob_free_chain(FAR struct iob_s *iob);
</pre>

<p><b>Description</b>.
  Free an entire buffer chain, starting at the beginning of the I/O buffer chain
</p>

<h4><a name="iob_add_queue">4.14.4.6 <code>iob_add_queue()</code></a></h4>
<p><b>Function Prototype</b>:
<pre>
#include &lt;nuttx/mm/iob.h&gt;
#if CONFIG_IOB_NCHAINS > 0
int iob_add_queue(FAR struct iob_s *iob, FAR struct iob_queue_s *iobq);
#endif /* CONFIG_IOB_NCHAINS > 0 */
</pre>

<p><b>Description</b>.
  Add one I/O buffer chain to the end of a queue.  May fail due to lack of resources.
</p>

<h4><a name="iob_tryadd_queue">4.14.4.7 <code>iob_tryadd_queue()</code></a></h4>
<p><b>Function Prototype</b>:
<pre>
#include &lt;nuttx/mm/iob.h&gt;
#if CONFIG_IOB_NCHAINS > 0
int iob_tryadd_queue(FAR struct iob_s *iob, FAR struct iob_queue_s *iobq);
#endif /* CONFIG_IOB_NCHAINS > 0 */
</pre>

<p><b>Description</b>.
  Add one I/O buffer chain to the end of a queue without waiting for resources to become free.
</p>

<h4><a name="iob_remove_queue">4.14.4.8 <code>iob_remove_queue()</code></a></h4>
<p><b>Function Prototype</b>:
<pre>
#include &lt;nuttx/mm/iob.h&gt;
#if CONFIG_IOB_NCHAINS > 0
FAR struct iob_s *iob_remove_queue(FAR struct iob_queue_s *iobq);
#endif /* CONFIG_IOB_NCHAINS > 0 */
</pre>

<p><b>Description</b>.
  Remove and return one I/O buffer chain from the head of a queue.
</p>

<p><b>Returned Value</b>.
  Returns a reference to the I/O buffer chain at the head of the queue.
</p>

<h4><a name="iob_peek_queue">4.14.4.9 <code>iob_peek_queue()</code></a></h4>
<p><b>Function Prototype</b>:
<pre>
#include &lt;nuttx/mm/iob.h&gt;
#if CONFIG_IOB_NCHAINS > 0
FAR struct iob_s *iob_peek_queue(FAR struct iob_queue_s *iobq);
#endif
</pre>

<p><b>Description</b>.
  Return a reference to the I/O buffer chain at the head of a queue. This is similar to iob_remove_queue except that the I/O buffer chain is in place at the head of the queue.  The I/O buffer chain may safely be modified by the caller but must be removed from the queue before it can be freed.
</p>

<p><b>Returned Value</b>.
  Returns a reference to the I/O buffer chain at the head of the queue.
</p>

<h4><a name="iob_free_queue">4.14.4.10 <code>iob_free_queue()</code></a></h4>
<p><b>Function Prototype</b>:
<pre>
#include &lt;nuttx/mm/iob.h&gt;
#if CONFIG_IOB_NCHAINS > 0
void iob_free_queue(FAR struct iob_queue_s *qhead);
#endif /* CONFIG_IOB_NCHAINS > 0 */
</pre>

<p><b>Description</b>.
  Free an entire queue of I/O buffer chains.
</p>

<h4><a name="iob_copyin">4.14.4.11 <code>iob_copyin()</code></a></h4>
<p><b>Function Prototype</b>:
<pre>
#include &lt;nuttx/mm/iob.h&gt;
int iob_copyin(FAR struct iob_s *iob, FAR const uint8_t *src,
               unsigned int len, unsigned int offset, bool throttled);
</pre>

<p><b>Description</b>.
  Copy data <code>len</code> bytes from a user buffer into the I/O buffer chain, starting at <code>offset</code>, extending the chain as necessary.
</p>

<h4><a name="iob_trycopyin">4.14.4.12 <code>iob_trycopyin()</code></a></h4>
<p><b>Function Prototype</b>:
<pre>
#include &lt;nuttx/mm/iob.h&gt;
int iob_trycopyin(FAR struct iob_s *iob, FAR const uint8_t *src,
                  unsigned int len, unsigned int offset, bool throttled);
</pre>

<p><b>Description</b>.
 Copy data <code>len</code> bytes from a user buffer into the I/O buffer chain, starting at <code>offset</code>, extending the chain as necessary BUT without waiting if buffers are not available.
</p>

<h4><a name="iob_copyout">4.14.4.13 <code>iob_copyout()</code></a></h4>
<p><b>Function Prototype</b>:
<pre>
#include &lt;nuttx/mm/iob.h&gt;
int iob_copyout(FAR uint8_t *dest, FAR const struct iob_s *iob,
                unsigned int len, unsigned int offset);
</pre>

<p><b>Description</b>.
 Copy data <code>len</code> bytes of data into the user buffer starting at <code>offset</code> in the I/O buffer, returning that actual number of bytes copied out.
</p>

<h4><a name="iob_clone">4.14.4.14 <code>iob_clone()</code></a></h4>
<p><b>Function Prototype</b>:
<pre>
#include &lt;nuttx/mm/iob.h&gt;
int iob_clone(FAR struct iob_s *iob1, FAR struct iob_s *iob2, bool throttled);
</pre>

<p><b>Description</b>.
  Duplicate (and pack) the data in <code>iob1</code> in <code>iob2</code>.  <code>iob2</code> must be empty.
</p>

<h4><a name="iob_concat">4.14.4.15 <code>iob_concat()</code></a></h4>
<p><b>Function Prototype</b>:
<pre>
#include &lt;nuttx/mm/iob.h&gt;
void iob_concat(FAR struct iob_s *iob1, FAR struct iob_s *iob2);
</pre>

<p><b>Description</b>.
  Concatenate iob_s chain iob2 to iob1.
</p>

<h4><a name="iob_trimhead">4.14.4.16 <code>iob_trimhead()</code></a></h4>
<p><b>Function Prototype</b>:
<pre>
#include &lt;nuttx/mm/iob.h&gt;
FAR struct iob_s *iob_trimhead(FAR struct iob_s *iob, unsigned int trimlen);
</pre>

<p><b>Description</b>.
  Remove bytes from the beginning of an I/O chain.  Emptied I/O buffers are freed and, hence, the beginning of the chain may change.
</p>

<h4><a name="iob_trimhead_queue">4.14.4.17 <code>iob_trimhead_queue()</code></a></h4>
<p><b>Function Prototype</b>:
<pre>
#include &lt;nuttx/mm/iob.h&gt;
#if CONFIG_IOB_NCHAINS > 0
FAR struct iob_s *iob_trimhead_queue(FAR struct iob_queue_s *qhead,
                                     unsigned int trimlen);
#endif
</pre>

<p><b>Description</b>.
  Remove bytes from the beginning of an I/O chain at the head of the queue.  Emptied I/O buffers are freed and, hence, the head of the queue may change.
</p>
<p>
  This function is just a wrapper around iob_trimhead() that assures that the iob at the head of queue is modified with the trimming operations.
</p>

<p><b>Returned Value</b>.
  The new iob at the head of the queue is returned.
</p>

<h4><a name="iob_trimtail">4.14.4.18 <code>iob_trimtail()</code></a></h4>
<p><b>Function Prototype</b>:
<pre>
#include &lt;nuttx/mm/iob.h&gt;
FAR struct iob_s *iob_trimtail(FAR struct iob_s *iob, unsigned int trimlen);
</pre>

<p><b>Description</b>.
  Remove bytes from the end of an I/O chain.  Emptied I/O buffers are freed NULL will be returned in the special case where the entry I/O buffer chain is freed.
</p>

<h4><a name="iob_pack">4.14.4.19 <code>iob_pack()</code></a></h4>
<p><b>Function Prototype</b>:
<pre>
#include &lt;nuttx/mm/iob.h&gt;
FAR struct iob_s *iob_pack(FAR struct iob_s *iob);
</pre>

<p><b>Description</b>.
  Pack all data in the I/O buffer chain so that the data offset is zero and all but the final buffer in the chain are filled.  Any emptied buffers at the end of the chain are freed.
</p>

<h4><a name="iob_contig">4.14.4.20 <code>iob_contig()</code></a></h4>
<p><b>Function Prototype</b>:
<pre>
#include &lt;nuttx/mm/iob.h&gt;
int iob_contig(FAR struct iob_s *iob, unsigned int len);
</pre>

<p><b>Description</b>.
  Ensure that there is <code>len</code> bytes of contiguous space at the beginning of the I/O buffer chain starting at <code>iob</code>.
</p>

<h4><a name="iob_dump">4.14.4.21 <code>iob_dump()</code></a></h4>
<p><b>Function Prototype</b>:
<pre>
#include &lt;nuttx/mm/iob.h&gt;
#ifdef CONFIG_DEBUG_FEATURES
void iob_dump(FAR const char *msg, FAR struct iob_s *iob, unsigned int len,
              unsigned int offset);
#endif
</pre>

<p><b>Description</b>.
  Dump the contents of a I/O buffer chain
</p>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
    <td>
      <h1><a name="NxFileSystem">5.0 NuttX File System</a></h1>
    </td>
  </tr>
</table>

<p><b>Overview</b>.
  NuttX includes an optional, scalable file system.
  This file-system may be omitted altogether; NuttX does not depend on the presence
  of any file system.
</p>

<p><b>Pseudo Root File System</b>.
  A simple <i>in-memory</i>, <i>pseudo</i> file system can be enabled by default.
  This is an <i>in-memory</i> file system because it does not require any
  storage medium or block driver support.
  Rather, file system contents are generated on-the-fly as referenced via
  standard file system operations (open, close, read, write, etc.).
  In this sense, the file system is <i>pseudo</i> file system (in the
  same sense that the Linux <code>/proc</code> file system is also
  referred to as a pseudo file system).
</p>

<p>
  Any user supplied data or logic can be accessed via the pseudo-file system.
  Built in support is provided for character and block <a href="#DeviceDrivers">drivers</a> in the
  <code>/dev</code> pseudo file system directory.
</p>

<p><b>Mounted File Systems</b>
  The simple in-memory file system can be extended my mounting block
  devices that provide access to true file systems backed up via some
  mass storage device.
  NuttX supports the standard <code>mount()</code> command that allows
  a block driver to be bound to a mountpoint within the pseudo file system
  and to a file system.
  At present, NuttX supports the standard VFAT and ROMFS file systems,
  a special, wear-leveling NuttX FLASH File System (NXFFS),
  as well as a Network File System client (NFS version 3, UDP).
</p>

<p><b>Comparison to Linux</b>
  From a programming perspective, the NuttX file system appears very similar
  to a Linux file system.
  However, there is a fundamental difference:
  The NuttX root file system is a pseudo file system and true file systems may be
  mounted in the pseudo file system.
  In the typical Linux installation by comparison, the Linux root file system
  is a true file system and pseudo file systems may be mounted in the true,
  root file system.
  The approach selected by NuttX is intended to support greater scalability
  from the very tiny platform to the moderate platform.
</p>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
    <td>
      <h1><a name="DeviceDrivers">6.0 NuttX Device Drivers</a></h1>
    </td>
  </tr>
</table>

<p>
  NuttX supports a variety of device drivers including:
  <ul>
    <li><i>Character</i> Device Drivers,</li>
    <li><i>Block</i> Device Drivers, and</li>
    <li>Other <i>Specialized</i> Drivers.</li>
  </ul>
  These different device driver types are discussed in the following paragraphs.
  Note: device driver support depends on the <i>in-memory</i>, <i>pseudo</i> file system
  that is enabled by default.
</p>

<h2><a name="chardrivers">6.1 Character Device Drivers</a></h2>

<p>
  Character device drivers have these properties:
</p>
<ul>
  <li>
    <p>
    <b><code>include/nuttx/fs/fs.h</code></b>.
    All structures and APIs needed to work with character drivers are provided in this header file.
    </p>
  </li>
  <li>
    <p>
    <b><code>struct file_operations</code></b>.
    Each character device driver must implement an instance of <code>struct file_operations</code>.
    That structure defines a call table with the following methods:
    <ul>
     <p><code>int open(FAR struct file *filep);</code><br>
     <code>int close(FAR struct file *filep);</code><br>
     <code>ssize_t read(FAR struct file *filep, FAR char *buffer, size_t buflen);</code><br>
     <code>ssize_t write(FAR struct file *filep, FAR const char *buffer, size_t buflen);</code><br>
     <code>off_t seek(FAR struct file *filep, off_t offset, int whence);</code><br>
     <code>int ioctl(FAR struct file *filep, int cmd, unsigned long arg);</code><br>
     <code>int poll(FAR struct file *filep, struct pollfd *fds, bool setup);</code></p>
    </ul>
    </p>
  </li>
  <li>
    <p>
    <b><code>int register_driver(const char *path, const struct file_operations *fops, mode_t mode, void *priv);</code></b>.
    Each character driver registers itself by calling <code>register_driver()</code>, passing it the
    <code>path</code> where it will appear in the <a href="#NxFileSystem">pseudo-file-system</a> and it's
    initialized instance of <code>struct file_operations</code>.
    </p>
  </li>
  <li>
    <p>
    <b>User Access</b>.
    After it has been registered, the character driver can be accessed by user code using the standard
    <a href="NuttxUserGuide.html#driveroperations">driver operations</a> including
    <code>open()</code>, <code>close()</code>, <code>read()</code>, <code>write()</code>, etc.
    </p>
  </li>
  <li>
    <p>
    <b>Specialized Character Drivers</b>.
    Within the common character driver framework, there are different specific varieties of <i>specialized</i> character drivers.
    The unique requirements of the underlying device hardware often mandates some customization of the character driver.
    These customizations tend to take the form of:
    </p>
    <ul>
      <li>
        Device-specific <code>ioctl()</code> commands used to performed specialized operations on the device.
        These <code>ioctl()</code> will be documented in header files under <code>include/nuttx</code> that detail the specific device interface.
      </li>
      <li>
        Specialized I/O formats.
        Some devices will require that <code>read()</code> and/or <code>write()</code> operations use data conforming to a specific format, rather than a plain stream of bytes.
        These specialized I/O formats will be documented in header files under <code>include/nuttx</code> that detail the specific device interface.
        The typical representation of the I/O format will be a C structure definition.
      </li>
    </ul>
    <p>
    The specialized character drivers support by NuttX are documented in the following paragraphs.
    </p>
  </li>
  <li>
    <p>
    <b>Examples</b>:
    <code>drivers/dev_null.c</code>, <code>drivers/fifo.c</code>, <code>drivers/serial.c</code>, etc.
    </p>
 </li>
</ul>

<h3><a name="serialdrivers">6.1.1 Serial Device Drivers</a></h3>

<ul>
  <li>
    <p>
    <b><code>include/nuttx/serial/serial.h</code></b>.
    All structures and APIs needed to work with serial drivers are provided in this header file.
    </p>
  </li>
  <li>
    <p>
    <b><code>struct uart_ops_s</code></b>.
    Each serial device driver must implement an instance of <code>struct uart_ops_s</code>.
    That structure defines a call table with the following methods:
    <ul>
     <p><code>int setup(FAR struct uart_dev_s *dev);</code><br>
     <code>void shutdown(FAR struct uart_dev_s *dev);</code><br>
     <code>int attach(FAR struct uart_dev_s *dev);</code><br>
     <code>void detach(FAR struct uart_dev_s *dev);</code><br>
     <code>int ioctl(FAR struct file *filep, int cmd, unsigned long arg);</code><br>
     <code>int receive(FAR struct uart_dev_s *dev, unsigned int *status);</code><br>
     <code>void rxint(FAR struct uart_dev_s *dev, bool enable);</code><br>
     <code>bool rxavailable(FAR struct uart_dev_s *dev);</code><br>
     <code>#ifdef CONFIG_SERIAL_IFLOWCONTROL</code><br>
     <code>bool rxflowcontrol(FAR struct uart_dev_s *dev, unsigned int nbuffered, bool upper);</code><br>
     <code>#endif</code><br>
     <code>void send(FAR struct uart_dev_s *dev, int ch);</code><br>
     <code>void txint(FAR struct uart_dev_s *dev, bool enable);</code><br>
     <code>bool txready(FAR struct uart_dev_s *dev);</code><br>
     <code>bool txempty(FAR struct uart_dev_s *dev);</code></p>
    </ul>
    </p>
  </li>
  <li>
    <p>
    <b><code>int uart_register(FAR const char *path, FAR uart_dev_t *dev);</code></b>.
    A serial driver may register itself by calling <code>uart_register()</code>, passing it the
    <code>path</code> where it will appear in the <a href="#NxFileSystem">pseudo-file-system</a> and it's
    initialized instance of <code>struct uart_ops_s</code>.
    By convention, serial device drivers are registered at paths like <code>/dev/ttyS0</code>, <code>/dev/ttyS1</code>, etc.
    See the <code>uart_register()</code> implementation in <code>drivers/serial.c</code>.
    </p>
  </li>
  <li>
    <p>
    <b>User Access</b>.
    Serial drivers are, ultimately, normal <a href="#chardrivers">character drivers</a> and are accessed as other character drivers.
    </p>
  </li>
  <li>
    <p>
    <b>Examples</b>:
    <code>arch/arm/src/stm32/stm32_serial.c</code>, <code>arch/arm/src/lpc214x/lpc214x_serial.c</code>, <code>arch/z16/src/z16f/z16f_serial.c</code>, etc.
    </p>
  </li>
</ul>

<h3><a name="tscdrivers">6.1.1 Touchscreen Device Drivers</a></h3>

<p>
  NuttX supports a two-part touchscreen driver architecture.
</p>
<ol>
  <li>
    An &quot;upper half&quot;, generic driver that provides the common touchscreen interface to application level code, and
  </li>
  <li>
    A &quot;lower half&quot;, platform-specific driver that implements the low-level touchscreen controls to implement the touchscreen functionality.
  </li>
</ol>
<p>
  Files supporting the touchscreen controller (TSC) driver can be found in the following locations:
</p>
<ul>
  <li><b>Interface Definition</b>.
    The header files for NuttX touchscreen drivers reside in the <code>include/nuttx/include/input</code> directory.
    The interface between the touchscreen controller &quot;upper half&quot; and &quot;lower half&quot; drivers are <i>not</i> common, but vary from controller-to-controller.
    Because of this, each touchscreen driver has its own unique header file that describes the &quot;upper half&quot;/&quot;lower half&quot; interface in that directory.
    The application level interface to each touchscreen driver, on the other hand, <i>is</i> the same for each touchscreen driver and is described <code>include/nuttx/include/input/touchscreen.h</code>.
    The touchscreen driver uses a standard character driver framework but read operations return specially formatted data.
  </li>
  <li><b>&quot;Upper Half&quot; Driver</b>.
    The controller-specific, &quot;upper half&quot; touchscreen drivers reside in the directory <code>drivers/input</code>.
  </li>
  <li><b>&quot;Lower Half&quot; Drivers</b>.
    Platform-specific touchscreen drivers reside in either: (1) The <code>arch/</code><i>&lt;architecture&gt;</i><code>/src/</code><i>&lt;hardware&gt;</i> directory for the processor architectures that have build in touchscreen controllers or (2) the <code>boards/</code><i>&lt;arch&gt;</i><code>/</code><i>&lt;chip&gt;</i><code>/</code><i>&lt;board&gt;</i><code>/src/</code> directory for boards that use an external touchscreen controller chip.
  </li>
</ul>

<h3><a name="analogdrivers">6.1.2 Analog (ADC/DAC) Drivers</a></h3>
<p>
  The NuttX analog drivers are split into two parts:
</p>
<ol>
  <li>
    An &quot;upper half&quot;, generic driver that provides the common analog interface to application level code, and
  </li>
  <li>
    A &quot;lower half&quot;, platform-specific driver that implements the low-level controls to implement the analog functionality.
  </li>
</ol>
<ul>
  <li>
    General header files for the NuttX analog drivers reside in <code>include/nuttx/analog/</code>.
    These header files includes both the application level interface to the analog driver as well as the interface between the &quot;upper half&quot; and &quot;lower half&quot; drivers.
  </li>
  <li>
    Common analog logic and share-able analog drivers reside in the <code>drivers/analog/</code>.
  </li>
  <li>
    Platform-specific drivers reside in <code>arch/</code><i>&lt;architecture&gt;</i><code>/src/</code><i>&lt;hardware&gt;</i> directory for the specific processor <i>&lt;architecture&gt;</i> and for the specific <i>&lt;chip&gt;</i> analog peripheral devices.
  </li>
</ul>

<h4><a name="adcdrivers">6.1.3.1 ADC Drivers</a></h4>
<ul>
  <li>
    <code>include/nuttx/analog/adc.h</code>.
    All structures and APIs needed to work with ADC drivers are provided in this header file.
    This header file includes:
    <ol>
      <li>
        Structures and interface descriptions needed to develop a low-level,
        architecture-specific, ADC driver.
      </li>
      <li>
        To register the ADC driver with a common ADC character driver.
      </li>
      <li>
        Interfaces needed for interfacing user programs with the common ADC character driver.
      </li>
    </ol>
  </li>
  <li>
    <code>drivers/analog/adc.c</code>.
    The implementation of the common ADC character driver.
  </li>
</ul>

<h4><a name="dacdrivers">6.1.3.2 DAC Drivers</a></h4>
<ul>
  <li>
    <code>include/nuttx/analog/dac.h</code>.
    All structures and APIs needed to work with DAC drivers are provided in this header file.
    This header file includes:
    <ol>
      <li>
        Structures and interface descriptions needed to develop a low-level,
        architecture-specific, DAC driver.
      </li>
      <li>
        To register the DAC driver with a common DAC character driver.
      </li>
      <li>
        Interfaces needed for interfacing user programs with the common DAC character driver.
      </li>
    </ol>
  </li>
  <li>
    <code>drivers/analog/dac.c</code>.
    The implementation of the common DAC character driver.
  </li>
</ul>

<h3><a name="pwmdrivers">6.1.4 PWM Drivers</a></h3>
<p>
  For the purposes of this driver, a PWM device is any device that generates periodic output pulses of controlled frequency and pulse width.
  Such a device might be used, for example, to perform pulse-width modulated output or frequency/pulse-count modulated output
  (such as might be needed to control a stepper motor).
</p>
<p>
  The NuttX PWM driver is split into two parts:
</p>
<ol>
  <li>
    An &quot;upper half&quot;, generic driver that provides the common PWM interface to application level code, and
  </li>
  <li>
    A &quot;lower half&quot;, platform-specific driver that implements the low-level timer controls to implement the PWM functionality.
  </li>
</ol>
<p>
  Files supporting PWM can be found in the following locations:
</p>
<ul>
  <li><b>Interface Definition</b>.
    The header file for the NuttX PWM driver reside at <code>include/nuttx/timers/pwm.h</code>.
    This header file includes both the application level interface to the PWM driver as well as the interface between the &quot;upper half&quot; and &quot;lower half&quot; drivers.
    The PWM module uses a standard character driver framework.
    However, since the PWM driver is a devices control interface and not a data transfer interface,
    the majority of the functionality available to the application is implemented in driver ioctl calls.
  </li>
  <li><b>&quot;Upper Half&quot; Driver</b>.
    The generic, &quot;upper half&quot; PWM driver resides at <code>drivers/pwm.c</code>.
  </li>
  <li><b>&quot;Lower Half&quot; Drivers</b>.
    Platform-specific PWM drivers reside in <code>arch/</code><i>&lt;architecture&gt;</i><code>/src/</code><i>&lt;hardware&gt;</i> directory for the specific processor <i>&lt;architecture&gt;</i> and for the specific <i>&lt;chip&gt;</i> PWM peripheral devices.
  </li>
</ul>

<h3><a name="candrivers">6.1.5 CAN Drivers</a></h3>
<p>
  NuttX supports only a very low-level CAN driver.
  This driver supports only the data exchange and does not include any high-level CAN protocol.
  The NuttX CAN driver is split into two parts:
</p>
<ol>
  <li>
    An &quot;upper half&quot;, generic driver that provides the common CAN interface to application level code, and
  </li>
  <li>
    A &quot;lower half&quot;, platform-specific driver that implements the low-level timer controls to implement the CAN functionality.
  </li>
</ol>
<p>
  Files supporting CAN can be found in the following locations:
</p>
<ul>
  <li><b>Interface Definition</b>.
    The header file for the NuttX CAN driver resides at <code>include/nuttx/can/can.h</code>.
    This header file includes both the application level interface to the CAN driver as well as the interface between the &quot;upper half&quot; and &quot;lower half&quot; drivers.
    The CAN module uses a standard character driver framework.
  </li>
  <li><b>&quot;Upper Half&quot; Driver</b>.
    The generic, &quot;upper half&quot; CAN driver resides at <code>drivers/can.c</code>.
  </li>
  <li><b>&quot;Lower Half&quot; Drivers</b>.
    Platform-specific CAN drivers reside in <code>arch/</code><i>&lt;architecture&gt;</i><code>/src/</code><i>&lt;hardware&gt;</i> directory for the specific processor <i>&lt;architecture&gt;</i> and for the specific <i>&lt;chip&gt;</i> CAN peripheral devices.
  </li>
</ul>
<p>
  <b>Usage Note</b>:
  When reading from the CAN driver multiple messages may be returned, depending on (1) the size the returned can messages, and (2) the size of the buffer provided to receive CAN messages.
  <i>Never assume that a single message will be returned</i>... if you do this, <i>you will lose CAN data</i> under conditions where your read buffer can hold more than one small message.
  Below is an example about how you should think of the CAN read operation:
</p>
<ul><pre>
#define BUFLEN 128  /* Arbitrary size of the CAN RX buffer */

FAR struct can_msg_s *msg;
char rxbuffer[BUFLEN];
ssize_t nread;
int nbytes;
int msglen
int i;

/* Read messages into the RX buffer */

nread = read(fd, rxbuffer, BUFLEN);

/* Check for read errors */
...

/* Process each message in the RX buffer */

for (i = 0; i &lt;= nread - CAN_MSGLEN(0); i += msglen)
{
  /* Get the next message from the RX buffer */

  msg    = (FAR struct can_msg_s *)&amp;rxbuffer[i];
  nbytes = can_dlc2bytes(msg->cm_hdr.ch_dlc);
  msglen = CAN_MSGLEN(nbytes);

  DEBUGASSERT(i + msglen &lt; BUFLEN);

  /* Process the next CAN message */
  ...
}
</pre></ul>

<h3><a name="quadencoder">6.1.6 Quadrature Encoder Drivers</a></h3>
<p>
  NuttX supports a low-level, two-part Quadrature Encoder driver.
</p>
<ol>
  <li>
    An &quot;upper half&quot;, generic driver that provides the common Quadrature Encoder interface to application level code, and
  </li>
  <li>
    A &quot;lower half&quot;, platform-specific driver that implements the low-level timer controls to implement the Quadrature Encoder functionality.
  </li>
</ol>
<p>
  Files supporting the Quadrature Encoder can be found in the following locations:
</p>
<ul>
  <li><b>Interface Definition</b>.
    The header file for the NuttX Quadrature Encoder driver reside at <code>include/nuttx/sensors/qencoder.h</code>.
    This header file includes both the application level interface to the Quadrature Encoder driver as well as the interface between the &quot;upper half&quot; and &quot;lower half&quot; drivers.
    The Quadrature Encoder module uses a standard character driver framework.
  </li>
  <li><b>&quot;Upper Half&quot; Driver</b>.
    The generic, &quot;upper half&quot; Quadrature Encoder driver resides at <code>drivers/sensors/qencoder.c</code>.
  </li>
  <li><b>&quot;Lower Half&quot; Drivers</b>.
    Platform-specific Quadrature Encoder drivers reside in <code>arch/</code><i>&lt;architecture&gt;</i><code>/src/</code><i>&lt;hardware&gt;</i> directory for the specific processor <i>&lt;architecture&gt;</i> and for the specific <i>&lt;chip&gt;</i> Quadrature Encoder peripheral devices.
  </li>
</ul>

<h3><a name="timerdriver">6.1.7 Timer Drivers</a></h3>
<p>
  NuttX supports a low-level, two-part timer driver.
</p>
<ol>
  <li>
    An &quot;upper half&quot;, generic driver that provides the common timer interface to application level code, and
  </li>
  <li>
    A &quot;lower half&quot;, platform-specific driver that implements the low-level timer controls to implement the timer functionality.
  </li>
</ol>
<p>
  Files supporting the timer driver can be found in the following locations:
</p>
<ul>
  <li><b>Interface Definition</b>.
    The header file for the NuttX timer driver reside at <code>include/nuttx/timers/timer.h</code>.
    This header file includes both the application level interface to the timer driver as well as the interface between the &quot;upper half&quot; and &quot;lower half&quot; drivers.
    The timer driver uses a standard character driver framework.
  </li>
  <li><b>&quot;Upper Half&quot; Driver</b>.
    The generic, &quot;upper half&quot; timer driver resides at <code>drivers/timers/timer.c</code>.
  </li>
  <li><b>&quot;Lower Half&quot; Drivers</b>.
    Platform-specific timer drivers reside in <code>arch/</code><i>&lt;architecture&gt;</i><code>/src/</code><i>&lt;hardware&gt;</i> directory for the specific processor <i>&lt;architecture&gt;</i> and for the specific <i>&lt;chip&gt;</i> timer peripheral devices.
  </li>
</ul>

<h3><a name="rtcriver">6.1.8 RTC Drivers</a></h3>
<p>
  NuttX supports a low-level, two-part RealTime Clock (RTC) driver.
</p>
<ol>
  <li>
    An &quot;upper half&quot;, generic driver that provides the common RTC interface to application level code, and
  </li>
  <li>
    A &quot;lower half&quot;, platform-specific driver that implements the low-level timer controls to implement the RTC functionality.
  </li>
</ol>
<p>
  Files supporting the RTC driver can be found in the following locations:
</p>
<ul>
  <li><b>Interface Definition</b>.
    The header file for the NuttX RTC driver reside at <code>include/nuttx/timers/rtc.h</code>.
    This header file includes both the application level interface to the RTC driver as well as the interface between the &quot;upper half&quot; and &quot;lower half&quot; drivers.
    The RTC driver uses a standard character driver framework.
  </li>
  <li><b>&quot;Upper Half&quot; Driver</b>.
    The generic, &quot;upper half&quot; RTC driver resides at <code>drivers/timers/rtc.c</code>.
  </li>
  <li><b>&quot;Lower Half&quot; Drivers</b>.
    Platform-specific RTC drivers reside in <code>arch/</code><i>&lt;architecture&gt;</i><code>/src/</code><i>&lt;hardware&gt;</i> directory for the specific processor <i>&lt;architecture&gt;</i> and for the specific <i>&lt;chip&gt;</i> RTC peripheral devices.
  </li>
</ul>

<h3><a name="wdogdriver">6.1.9 Watchdog Timer Drivers</a></h3>
<p>
  NuttX supports a low-level, two-part watchdog timer driver.
</p>
<ol>
  <li>
    An &quot;upper half&quot;, generic driver that provides the common watchdog timer interface to application level code, and
  </li>
  <li>
    A &quot;lower half&quot;, platform-specific driver that implements the low-level timer controls to implement the watchdog timer functionality.
  </li>
</ol>
<p>
  Files supporting the watchdog timer driver can be found in the following locations:
</p>
<ul>
  <li><b>Interface Definition</b>.
    The header file for the NuttX watchdog timer driver reside at <code>include/nuttx/timers/watchdog.h</code>.
    This header file includes both the application level interface to the watchdog timer driver as well as the interface between the &quot;upper half&quot; and &quot;lower half&quot; drivers.
    The watchdog timer driver uses a standard character driver framework.
  </li>
  <li><b>&quot;Upper Half&quot; Driver</b>.
    The generic, &quot;upper half&quot; watchdog timer driver resides at <code>drivers/timers/watchdog.c</code>.
  </li>
  <li><b>&quot;Lower Half&quot; Drivers</b>.
    Platform-specific watchdog timer drivers reside in <code>arch/</code><i>&lt;architecture&gt;</i><code>/src/</code><i>&lt;hardware&gt;</i> directory for the specific processor <i>&lt;architecture&gt;</i> and for the specific <i>&lt;chip&gt;</i> watchdog timer peripheral devices.
  </li>
</ul>

<h3><a name="kbddriver">6.1.10 Keyboard/Keypad Drivers</a></h3>
<p>
  <b>Keypads vs. Keyboards</b>
  Keyboards and keypads are really the same devices for NuttX.
  A keypad is thought of as simply a keyboard with fewer keys.
</p>
<p>
  <b>Special Commands</b>.
  In NuttX, a keyboard/keypad driver is simply a character driver that may have an (optional) encoding/decoding layer on the data returned by the character driver.
  A keyboard may return simple text data (alphabetic, numeric, and punctuation) or control characters (enter,  control-C, etc.) when a key is pressed.
  We can think about this the &quot;normal&quot; keyboard data stream.
  However, in addition, most keyboards support actions that cannot be represented as text or control data.
  Such actions include things like cursor controls (home, up arrow, page down, etc.), editing functions (insert, delete, etc.), volume controls, (mute, volume up, etc.) and other special functions.
  In this case, some special encoding may be required to multiplex the normal text data and special command key press data streams.
</p>
<p>
  <b>Key Press and Release Events</b>
  Sometimes the time that a key is released is needed by applications as well.
  Thus, in addition to normal and special key press events, it may also be necessary to encode normal and special key release events.
</p>
<p>
  <b>Encoding/Decoding</b> Layer</b>.
  An optional encoding/decoding layer can be used with the basic character driver to encode the keyboard events into the text data stream.
  The function interfaces that comprise that encoding/decoding layer are defined in the header file <code>include/nuttx/input/kbd_code.h</code>.
  These functions provide an matched set of (a) driver encoding interfaces, and (b) application decoding interfaces.
</p>
<ol>
  <li>
    <p>
      <b>Driver Encoding Interfaces</b>.
      These are interfaces used by the keyboard/keypad driver to encode keyboard events and data.
    </p>
    <ul>
      <li>
        <p>
          <b><code>kbd_press()</code></b>
        </p>
        <p><b>Function Prototype:</b></p>
          <ul><pre>
#include &lt;nuttx/streams.h&gt;
#include &lt;nuttx/input/kbd_codec.h&gt;
void kbd_press(int ch, FAR struct lib_outstream_s *stream);
</pre></ul>
        <p><b>Description:</b></p>
        <ul>
          Indicates a normal key press event.
          Put one byte of normal keyboard  data into the output stream.
        </ul>
        <p><b>Input Parameters:</b></p>
        <ul>
          <li>
            <code>ch</code>:  The character to be added to the output stream.
          </li>
          <li>
            <code>stream</code>:  An instance of <code>lib_outstream_s</code> to perform the actual low-level put operation.
          </li>
        </ul>
        <p><b>Returned Value:</b></p>
        <ul>
          None.
        </ul>
      </li>
      <li>
        <p>
          <b><code>kbd_release()</code></b>
        </p>
        <p><b>Function Prototype:</b></p>
          <ul><pre>
#include &lt;nuttx/streams.h&gt;
#include &lt;nuttx/input/kbd_codec.h&gt;
void kbd_release(uint8_t ch, FAR struct lib_outstream_s *stream);
</pre></ul>
        <p><b>Description:</b></p>
        <ul>
          Encode the release of a normal key.
        </ul>
        <p><b>Input Parameters:</b></p>
        <ul>
          <li>
            <code>ch</code>:  The character associated with the key that was released.
          </li>
          <li>
            <code>stream</code>:  An instance of <code>lib_outstream_s</code> to perform the actual low-level put operation.
          </li>
        </ul>
        <p><b>Returned Value:</b></p>
        <ul>
          None.
        </ul>
      </li>
      <li>
        <p>
          <b><code>kbd_specpress()</code></b>
        </p>
        <p><b>Function Prototype:</b></p>
          <ul><pre>
#include &lt;nuttx/streams.h&gt;
#include &lt;nuttx/input/kbd_codec.h&gt;
void kbd_specpress(enum kbd_keycode_e keycode, FAR struct lib_outstream_s *stream);
</pre></ul>
        <p><b>Description:</b></p>
        <ul>
           Denotes a special key press event.
           Put one special keyboard command into the output stream.
         </ul>
        <p><b>Input Parameters:</b></p>
        <ul>
          <li>
            <code>keycode</code>:  The command to be added to the output stream.
            The enumeration <code>enum kbd_keycode_e keycode</code> identifies all commands known to the system.
          </li>
          <li>
            <code>stream</code>:  An instance of <code>lib_outstream_s</code> to perform the actual low-level put operation.
          </li>
        </ul>
        <p><b>Returned Value:</b></p>
        <ul>
          None.
        </ul>
      </li>
      <li>
        <p>
          <b><code>kbd_specrel()</code></b>
        </p>
        <p><b>Function Prototype:</b></p>
          <ul><pre>
#include &lt;nuttx/streams.h&gt;
#include &lt;nuttx/input/kbd_codec.h&gt;
void kbd_specrel(enum kbd_keycode_e keycode, FAR struct lib_outstream_s *stream);
</pre></ul>
        <p><b>Description:</b></p>
        <ul>
           Denotes a special key release event.
           Put one special keyboard command into the output stream.
         </ul>
        <p><b>Input Parameters:</b></p>
        <ul>
          <li>
            <code>keycode</code>:  The command to be added to the output stream.
            The enumeration <code>enum kbd_keycode_e keycode</code> identifies all commands known to the system.
          </li>
          <li>
            <code>stream</code>:  An instance of <code>lib_outstream_s</code> to perform the actual low-level put operation.
          </li>
        </ul>
        <p><b>Returned Value:</b></p>
        <ul>
          None.
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>
      <b>Application Decoding Interfaces</b>.
      These are user interfaces to decode the values returned by the keyboard/keypad driver.
    </p>
    <ul>
      <li>
        <p>
          <b><code>kbd_decode()</code></b>
        </p>
        <p><b>Function Prototype:</b></p>
          <ul><pre>
#include &lt;nuttx/streams.h&gt;
#include &lt;nuttx/input/kbd_codec.h&gt;
int kbd_decode(FAR struct lib_instream_s *stream, FAR struct kbd_getstate_s *state, FAR uint8_t *pch);
</pre></ul>
        <p><b>Description:</b></p>
        <ul>
           Get one byte of data or special command from the driver provided input buffer.
        </ul>
        <p><b>Input Parameters:</b></p>
        <ul>
          <li>
            <code>stream</code>:  An instance of <code>lib_instream_s</code> to perform the actual low-level get operation.
          </li>
          <li>
            <code>pch</code>:  The location to save the returned value.
            This may be either a normal, character code or a special command (i.e., a value from <code>enum kbd_getstate_s</code>.
          </li>
          <li>
            <code>state</code>:  A user provided buffer to support parsing.
            This structure should be cleared the first time that <code>kbd_decode()</code> is called.
          </li>
        </ul>
        <p><b>Returned Value:</b></p>
        <ul>
          <li>
            <b><code>KBD_PRESS</code> (0)</b>:
            Indicates the successful receipt of normal, keyboard data.
            This corresponds to a keypress event.
            The returned value in <code>pch</code> is a simple byte of text or control data.
          </li>
          <li>
            <b><code>KBD_RELEASE</code> (1)</b>:
            Indicates a key release event.
            The returned value in <code>pch</code> is the byte of text or control data corresponding to the released key.
          </li>
          <li>
            <b><code>KBD_SPECPRESS</code> (2)</b>:
             Indicates the successful receipt of a special keyboard command.
             The returned value in <code>pch</code> is a value from <code>enum kbd_getstate_s</code>.
          </li>
          <li>
            <b><code>KBD_SPECREL</code> (3)</b>:
            Indicates a special command key release event.
             The returned value in <code>pch</code> is a value from <code>enum kbd_getstate_s</code>.
          </li>
          <li>
            <b><code>KBD_ERROR</code> (<code>EOF</code>)</b>:
            An error has getting the next character (reported by the <code>stream</code>).
            Normally indicates the end of file.
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ol>
<p>
  <b>I/O Streams</b>.
  Notice the use of the abstract I/O streams in these interfaces.
  These stream interfaces are defined in <code>include/nuttx/streams.h</code>.
</p>

<h2><a name="blockdrivers">6.2 Block Device Drivers</a></h2>

<p>
  Block device drivers have these properties:
</p>
<ul>
  <li>
    <p>
    <b><code>include/nuttx/fs/fs.h</code></b>.
    All structures and APIs needed to work with block drivers are provided in this header file.
    </p>
  </li>
  <li>
    <p>
    <b><code>struct block_operations</code></b>.
    Each block device driver must implement an instance of <code>struct block_operations</code>.
    That structure defines a call table with the following methods:
    <ul>
     <p><code>int open(FAR struct inode *inode);</code><br>
     <code>int close(FAR struct inode *inode);</code><br>
     <code>ssize_t read(FAR struct inode *inode, FAR unsigned char *buffer, size_t start_sector, unsigned int nsectors);</code><br>
     <code>ssize_t write(FAR struct inode *inode, FAR const unsigned char *buffer, size_t start_sector, unsigned int nsectors);</code><br>
     <code>int geometry(FAR struct inode *inode, FAR struct geometry *geometry);</code><br>
     <code>int ioctl(FAR struct inode *inode, int cmd, unsigned long arg);</code></p>
    </ul>
    </p>
  </li>
  <li>
    <p>
    <b><code>int register_blockdriver(const char *path, const struct block_operations *bops, mode_t mode, void *priv);</code></b>.
    Each block driver registers itself by calling <code>register_blockdriver()</code>, passing it the
    <code>path</code> where it will appear in the <a href="#NxFileSystem">pseudo-file-system</a> and it's
    initialized instance of <code>struct block_operations</code>.
    </p>
  </li>
  <li>
    <p>
    <b>User Access</b>.
    Users do not normally access block drivers directly, rather, they access block drivers
    indirectly through the <code>mount()</code> API.
    The <code>mount()</code> API binds a block driver instance with a file system and with a mountpoint.
    Then the user may use the block driver to access the file system on the underlying media.
    <i>Example</i>: See the <code>cmd_mount()</code> implementation in <code>apps/nshlib/nsh_fscmds.c</code>.
    </p>
  </li>
  <li>
    <p>
    <b>Accessing a Character Driver as a Block Device</b>.
    See the loop device at <code>drivers/loop.c</code>.
    <i>Example</i>: See the <code>cmd_losetup()</code> implementation in <code>apps/nshlib/nsh_fscmds.c</code>.
    </p>
  </li>
  <li>
    <p>
    <b>Accessing a Block Driver as Character Device</b>.
    See the Block-to-Character (BCH) conversion logic in <code>drivers/bch/</code>.
    <i>Example</i>: See the <code>cmd_dd()</code> implementation in <code>apps/nshlib/nsh_ddcmd.c</code>.
    </p>
  </li>
  <li>
    <p>
    <b>Examples</b>.
    <code>drivers/loop.c</code>, <code>drivers/mmcsd/mmcsd_spi.c</code>, <code>drivers/ramdisk.c</code>, etc.
    </p>
  </li>
</ul>

<h2><a name="specdrivers">6.3 Specialized Device Drivers</a></h2>

<p>
  All device drivers that are accessible to application logic are either:  (1) Character device drivers that can be accessed via the standard driver operations (<code>open()</code>, <code>close()</code>, <code>read()</code>, <code>write()</code>, etc.), or (2) block drivers that can be accessing only as part of mounting a file system or other special use cases as described in the preceding paragraph.
</p>
<p>
  In addition to this, there are also specialized &quot;drivers&quot; that can be used only within the OS logic itself and are not accessible to application logic.  These specialized drivers are discussed in the following paragraphs.
</p>

<h3><a name="ethdrivers">6.3.1 Ethernet Device Drivers</a></h3>

<ul>
  <li>
    <p>
    <b><code>include/nuttx/net/netdev.h</code></b>.
    All structures and APIs needed to work with Ethernet drivers are provided in this header file.
    The structure <code>struct net_driver_s</code> defines the interface and is passed to the network via <code>netdev_register()</code>.
    </p>
  </li>
  <li>
    <p>
    <b><code>int netdev_register(FAR struct net_driver_s *dev, enum net_lltype_e lltype);</code></b>.
    Each Ethernet driver registers itself by calling <code>netdev_register()</code>.
    </p>
  </li>
  <li>
    <p>
    <b>Examples</b>:
    <code>drivers/net/dm90x0.c</code>, <code>arch/drivers/arm/src/c5471/c5471_ethernet.c</code>, <code>arch/z80/src/ez80/ez80_emac.c</code>, etc.
    </p>
  </li>
</ul>

<h3><a name="spidrivers">6.3.2 SPI Device Drivers</a></h3>

<ul>
  <li>
    <p>
    <b><code>include/nuttx/spi/spi.h</code></b>.
    All structures and APIs needed to work with SPI drivers are provided in this header file.
    </p>
  </li>
  <li>
    <p>
    <b><code>struct spi_ops_s</code></b>.
    Each SPI device driver must implement an instance of <code>struct spi_ops_s</code>.
    That structure defines a call table with the following methods:
    <ul>
     <p><code>void lock(FAR struct spi_dev_s *dev);</code></p>
     <p><code>void select(FAR struct spi_dev_s *dev, uint32_t devid, bool selected);</code><br>
     <code>uint32_t setfrequency(FAR struct spi_dev_s *dev, uint32_t frequency);</code><br>
     <code>void setmode(FAR struct spi_dev_s *dev, enum spi_mode_e mode);</code><br>
     <code>void setbits(FAR struct spi_dev_s *dev, int nbits);</code><br>
     <code>uint8_t status(FAR struct spi_dev_s *dev, uint32_t devid);</code><br>
     <code>uint32_t send(FAR struct spi_dev_s *dev, uint32_t wd);</code><br>
     <code>void exchange(FAR struct spi_dev_s *dev, FAR const void *txbuffer, FAR void *rxbuffer, size_t nwords);</code><br>
     <p><code>int registercallback(FAR struct spi_dev_s *dev, mediachange_t callback, void *arg);</code></p>
    </ul>
    </p>
  <li>
    <p>
      <b>Binding SPI Drivers</b>.
      SPI drivers are not normally directly accessed by user code, but are usually bound to another,
      higher level device driver.
      See for example, <code>int mmcsd_spislotinitialize(int minor, int slotno, FAR struct spi_dev_s *spi)</code> in <code>drivers/mmcsd/mmcsd_spi.c</code>.
      In general, the binding sequence is:
    </p>
    <p>
      <ol>
        <li>Get an instance of <code>struct spi_dev_s</code> from the hardware-specific SPI device driver, and </li>
        <li>Provide that instance to the initialization method of the higher level device driver.</li>
      </ol>
    </p>
  </li>
  <li>
    <p>
      <b>Examples</b>:
      <code>drivers/loop.c</code>, <code>drivers/mmcsd/mmcsd_spi.c</code>, <code>drivers/ramdisk.c</code>, etc.
    </p>
  </li>
</ul>

<h3><a name="i2cdrivers">6.3.3 I2C Device Drivers</a></h3>

<ul>
  <li>
    <p>
    <b><code>include/nuttx/i2c/i2c.h</code></b>.
    All structures and APIs needed to work with I2C drivers are provided in this header file.
    </p>
  </li>
  <li>
    <p>
    <b><code>struct i2c_ops_s</code></b>.
    Each I2C device driver must implement an instance of <code>struct i2c_ops_s</code>.
    That structure defines a call table with the following methods:
    <ul>
     <code>int transfer(FAR struct i2c_master_s *dev, FAR struct i2c_msg_s *msgs, int count);</code></p>
    </p>
  </ul>
  <li>
    <p>
      <b>Binding I2C Drivers</b>.
      I2C drivers are not normally directly accessed by user code, but are usually bound to another,
      higher level device driver.
      In general, the binding sequence is:
    </p>
    <p>
      <ol>
        <li>Get an instance of <code>struct i2c_master_s</code> from the hardware-specific I2C device driver, and </li>
        <li>Provide that instance to the initialization method of the higher level device driver.</li>
      </ol>
    </p>
  </li>
  <li>
    <p>
      <b>Examples</b>:
      <code>arch/z80/src/ez80/ez80_i2c.c</code>, <code>arch/z80/src/z8/z8_i2c.c</code>, etc.
    </p>
  </li>
</ul>

<h3><a name="fbdrivers">6.3.4 Frame Buffer Drivers</a></h3>

<ul>
  <li>
    <p>
      <b><code>include/nuttx/video/fb.h</code></b>.
      All structures and APIs needed to work with frame buffer drivers are provided in this header file.
    </p>
  </li>
  <li>
    <p>
      <b><code>struct fb_vtable_s</code></b>.
      Each frame buffer device driver must implement an instance of <code>struct fb_vtable_s</code>.
      That structure defines a call table with the following methods:
    </p>
    <p>
      Get information about the video controller configuration and the configuration of each color plane.
    </p>
    <ul>
     <p><code>int (*getvideoinfo)(FAR struct fb_vtable_s *vtable, FAR struct fb_videoinfo_s *vinfo);</code><br>
     <code>int (*getplaneinfo)(FAR struct fb_vtable_s *vtable, int planeno, FAR struct fb_planeinfo_s *pinfo);</code></p>
    </ul>
    <p>
      The following are provided only if the video hardware supports RGB color mapping:
    </p>
    <ul>
     <p><code>int (*getcmap)(FAR struct fb_vtable_s *vtable, FAR struct fb_cmap_s *cmap);</code><br>
     <code>int (*putcmap)(FAR struct fb_vtable_s *vtable, FAR const struct fb_cmap_s *cmap);</code></p>
    </ul>
    <p>
      The following are provided only if the video hardware supports a hardware cursor:
    </p>
    <ul>
     <p><code>int (*getcursor)(FAR struct fb_vtable_s *vtable, FAR struct fb_cursorattrib_s *attrib);</code><br>
     <code>int (*setcursor)(FAR struct fb_vtable_s *vtable, FAR struct fb_setcursor_s *settings);</code></p>
    </ul>
  </li>
  <li>
    <p>
      <b>Binding Frame Buffer Drivers</b>.
      Frame buffer drivers are not normally directly accessed by user code, but are usually bound to another,
      higher level device driver.
      In general, the binding sequence is:
    </p>
    <p>
      <ol>
        <li>Get an instance of <code>struct fb_vtable_s</code> from the hardware-specific frame buffer device driver, and </li>
        <li>Provide that instance to the initialization method of the higher level device driver.</li>
      </ol>
    </p>
  </li>
  <li>
    <p>
      <b>Examples</b>:
      <code>arch/sim/src/up_framebuffer.c</code>.
      See also the usage of the frame buffer driver in the <code>graphics/</code> directory.
    </p>
  </li>
</ul>

<h3><a name="lcddrivers">6.3.5 LCD Drivers</a></h3>

<ul>
  <li>
    <p>
      <b><code>include/nuttx/lcd/lcd.h</code></b>.
      Structures and APIs needed to work with LCD drivers are provided in this header file.
      This header file also depends on some of the same definitions used for the frame buffer driver as provided in <code>include/nuttx/video/fb.h</code>.
    </p>
  </li>
  <li>
    <p>
      <b><code>struct lcd_dev_s</code></b>.
      Each LCD device driver must implement an instance of <code>struct lcd_dev_s</code>.
      That structure defines a call table with the following methods:
    </p>
    <p>
      Get information about the LCD video controller configuration and the configuration of each LCD color plane.
    </p>
    <ul>
    <p>
       <code>int (*getvideoinfo)(FAR struct lcd_dev_s *dev, FAR struct fb_videoinfo_s *vinfo);</code><br>
       <code>int (*getplaneinfo)(FAR struct lcd_dev_s *dev, unsigned int planeno, FAR struct lcd_planeinfo_s *pinfo);</code>
     </p>
    </ul>
    <p>
      The following are provided only if the video hardware supports RGB color mapping:
    </p>
    <ul>
     <p>
       <code>int (*getcmap)(FAR struct lcd_dev_s *dev, FAR struct fb_cmap_s *cmap);</code><br>
       <code>int (*putcmap)(FAR struct lcd_dev_s *dev, FAR const struct fb_cmap_s *cmap);</code>
     </p>
    </ul>
    <p>
      The following are provided only if the video hardware supports a hardware cursor:
    </p>
    <ul>
     <p>
       <code>int (*getcursor)(FAR struct lcd_dev_s *dev, FAR struct fb_cursorattrib_s *attrib);</code><br>
       <code>int (*setcursor)(FAR struct lcd_dev_s *dev, FAR struct fb_setcursor_s *settings)</code>
     </p>
    </ul>
    <p>
      Get the LCD panel power status (0: full off - <code>CONFIG_LCD_MAXPOWER</code>: full on).
      On backlit LCDs, this setting may correspond to the backlight setting.
    </p>
    <ul>
     <p>
       <code>int (*getpower)(struct lcd_dev_s *dev);</code>
     </p>
    </ul>
    <p>
      Enable/disable LCD panel power (0: full off - <code>CONFIG_LCD_MAXPOWER</code>: full on).
      On backlit LCDs, this setting may correspond to the backlight setting.
    </p>
    <ul>
     <p>
       <code>int (*setpower)(struct lcd_dev_s *dev, int power);</code>
     </p>
    </ul>
    <p>
      Get the current contrast setting (0-CONFIG_LCD_MAXCONTRAST) */
    </p>
    <ul>
     <p>
       <code>int (*getcontrast)(struct lcd_dev_s *dev);</code>
     </p>
    </ul>
    <p>
      Set LCD panel contrast (0-CONFIG_LCD_MAXCONTRAST)
    </p>
    <ul>
     <p>
       <code>int (*setcontrast)(struct lcd_dev_s *dev, unsigned int contrast);</code>
     </p>
    </ul>
  </p>
  <li>
    <p>
      <b>Binding LCD Drivers</b>.
      LCD drivers are not normally directly accessed by user code, but are usually bound to another,
      higher level device driver.
      In general, the binding sequence is:
    </p>
    <p>
      <ol>
        <li>Get an instance of <code>struct lcd_dev_s</code> from the hardware-specific LCD device driver, and </li>
        <li>Provide that instance to the initialization method of the higher level device driver.</li>
      </ol>
    </p>
  </li>
  <li>
    <p>
      <b>Examples</b>:
      <code>drivers/lcd/p14201.c</code>, <code>boards/arm/sam34/sam3u-ek/src/up_lcd.c.</code>
      See also the usage of the LCD driver in the <code>graphics/</code> directory.
    </p>
  </li>
</ul>

<h3><a name="mtddrivers">6.3.6 Memory Technology Device Drivers</a></h3>

<ul>
  <li>
    <p>
      <b><code>include/nuttx/mtd/mtd.h</code></b>.
      All structures and APIs needed to work with MTD drivers are provided in this header file.
    </p>
  </li>
  <li>
    <p>
      <b><code>struct mtd_dev_s</code></b>.
      Each MTD device driver must implement an instance of <code>struct mtd_dev_s</code>.
      That structure defines a call table with the following methods:
    </p>
    <p>
      Erase the specified erase blocks (units are erase blocks):
    </p>
    <ul>
     <p><code>int (*erase)(FAR struct mtd_dev_s *dev, off_t startblock, size_t nblocks);</code></p>
    </ul>
    <p>
      Read/write from the specified read/write blocks:
    </p>
    <ul>
     <p><code>ssize_t (*bread)(FAR struct mtd_dev_s *dev, off_t startblock, size_t nblocks, FAR uint8_t *buffer);</code><br>
     <code>ssize_t (*bwrite)(FAR struct mtd_dev_s *dev, off_t startblock, size_t nblocks, FAR const uint8_t *buffer);</code></p>
    </ul>
    <p>
      Some devices may support byte oriented reads (optional).
      Most MTD devices are inherently block oriented so byte-oriented accesses are not supported.
      It is recommended that low-level drivers not support read() if it requires buffering.
    </p>
    <ul>
     <p><code>ssize_t (*read)(FAR struct mtd_dev_s *dev, off_t offset, size_t nbytes, FAR uint8_t *buffer);</code></p>
    </ul>
    <p>
      Some devices may also support byte oriented writes (optional).
      Most MTD devices are inherently block oriented so byte-oriented accesses are not supported.
      It is recommended that low-level drivers not support read() if it requires buffering.
      This interface is only available if <code>CONFIG_MTD_BYTE_WRITE</code> is defined.
    </p>
    <ul>
     <p><code>ssize_t (*write)(FAR struct mtd_dev_s *dev, off_t offset, size_t nbytes, FAR const uint8_t *buffer);</code></p>
    </ul>
    <p>
      Support other, less frequently used commands:
    </p>
    <ul>
      <li><code>MTDIOC_GEOMETRY</code>:  Get MTD geometry</li>
      <li><code>MTDIOC_XIPBASE:</code>: Convert block to physical address for eXecute-In-Place</li>
      <li><code>MTDIOC_BULKERASE</code>: Erase the entire device</li>
    </ul>
    <p>
      is provided via a single <code>ioctl</code> method (see <code>include/nuttx/fs/ioctl.h</code>):
    </p>
    <ul>
     <p><code>int (*ioctl)(FAR struct mtd_dev_s *dev, int cmd, unsigned long arg);</code></p>
    </ul>
  </li>
  <li>
    <p>
      <b>Binding MTD Drivers</b>.
      MTD drivers are not normally directly accessed by user code, but are usually bound to another,
      higher level device driver.
      In general, the binding sequence is:
    </p>
    <p>
      <ol>
        <li>Get an instance of <code>struct mtd_dev_s</code> from the hardware-specific MTD device driver, and </li>
        <li>Provide that instance to the initialization method of the higher level device driver.</li>
      </ol>
    </p>
  </li>
  <li>
    <p>
      <b>Examples</b>:
      <code>drivers/mtd/m25px.c</code> and <code>drivers/mtd/ftl.c</code>
    </p>
  </li>
</ul>

<h3><a name="sdiodrivers">6.3.7 SDIO Device Drivers</a></h3>

<ul>
  <li>
    <p>
      <b><code>include/nuttx/sdio.h</code></b>.
      All structures and APIs needed to work with SDIO drivers are provided in this header file.
    </p>
  </li>
  <li>
    <p>
      <b><code>struct sdio_dev_s</code></b>.
      Each SDIO device driver must implement an instance of <code>struct sdio_dev_s</code>.
      That structure defines a call table with the following methods:
    </p>
    <p>
      Mutual exclusion:
    </p>
    <ul>
      <p>
        <code>#ifdef CONFIG_SDIO_MUXBUS</code><br>
        <code>  int (*lock)(FAR struct sdio_dev_s *dev, bool lock);</code><br>
        <code>#endif</code>
      </p>
    </ul>
    <p>
      Initialization/setup:
    </p>
    <ul>
     <p><code>void (*reset)(FAR struct sdio_dev_s *dev);</code><br>
     <code>sdio_capset_t (*capabilities)(FAR struct sdio_dev_s *dev);</code><br>
     <code>sdio_statset_t (*status)(FAR struct sdio_dev_s *dev);</code><br>
     <code>void (*widebus)(FAR struct sdio_dev_s *dev, bool enable);</code><br>
     <code>void (*clock)(FAR struct sdio_dev_s *dev, enum sdio_clock_e rate);</code><br>
     <code>int (*attach)(FAR struct sdio_dev_s *dev);</code><br>
    </ul>
    <p>
      Command/Status/Data Transfer:
    </p>
    <ul>
     <p><code>int (*sendcmd)(FAR struct sdio_dev_s *dev, uint32_t cmd, uint32_t arg);</code><br>
     <code>int (*recvsetup)(FAR struct sdio_dev_s *dev, FAR uint8_t *buffer, size_t nbytes);</code><br>
     <code>int (*sendsetup)(FAR struct sdio_dev_s *dev, FAR const uint8_t *buffer, size_t nbytes);</code><br>
     <code>int (*cancel)(FAR struct sdio_dev_s *dev);</code><br>
     <code>int (*waitresponse)(FAR struct sdio_dev_s *dev, uint32_t cmd);</code><br>
     <code>int (*recv_r1)(FAR struct sdio_dev_s *dev, uint32_t cmd, uint32_t *R1);</code><br>
     <code>int (*recv_r2)(FAR struct sdio_dev_s *dev, uint32_t cmd, uint32_t R2[4]);</code><br>
     <code>int (*recv_r3)(FAR struct sdio_dev_s *dev, uint32_t cmd, uint32_t *R3);</code><br>
     <code>int (*recv_r4)(FAR struct sdio_dev_s *dev, uint32_t cmd, uint32_t *R4);</code><br>
     <code>int (*recv_r5)(FAR struct sdio_dev_s *dev, uint32_t cmd, uint32_t *R5);</code><br>
     <code>int (*recv_r6)(FAR struct sdio_dev_s *dev, uint32_t cmd, uint32_t *R6);</code><br>
     <code>int (*recv_r7)(FAR struct sdio_dev_s *dev, uint32_t cmd, uint32_t *R7);</code></p>
    </ul>
    <p>
      Event/Callback support:
    </p>
    <ul>
     <p><code>void (*waitenable)(FAR struct sdio_dev_s *dev, sdio_eventset_t eventset);</code><br>
     <code>sdio_eventset_t (*eventwait)(FAR struct sdio_dev_s *dev, uint32_t timeout);</code><br>
     <code>void (*callbackenable)(FAR struct sdio_dev_s *dev, sdio_eventset_t eventset);</code><br>
     <code>int (*registercallback)(FAR struct sdio_dev_s *dev, worker_t callback, void *arg);</code></p>
    </ul>
    <p>
      DMA support:
    </p>
    <ul>
     <code>int (*dmarecvsetup)(FAR struct sdio_dev_s *dev, FAR uint8_t *buffer, size_t buflen);</code><br>
     <code>int (*dmasendsetup)(FAR struct sdio_dev_s *dev, FAR const uint8_t *buffer,  size_t buflen);</code></p>
    </ul>
  </li>
  <li>
    <p>
      <b>Binding SDIO Drivers</b>.
      SDIO drivers are not normally directly accessed by user code, but are usually bound to another,
      higher level device driver.
      In general, the binding sequence is:
    </p>
    <p>
      <ol>
        <li>Get an instance of <code>struct sdio_dev_s</code> from the hardware-specific SDIO device driver, and </li>
        <li>Provide that instance to the initialization method of the higher level device driver.</li>
      </ol>
    </p>
  </li>
  <li>
    <p>
      <b>Examples</b>:
      <code>arch/arm/src/stm32/stm32_sdio.c</code> and <code>drivers/mmcsd/mmcsd_sdio.c</code>
    </p>
  </li>
</ul>

<h3><a name="usbhostdrivers">6.3.8 USB Host-Side Drivers</a></h3>

<ul>
  <li>
    <p>
      <b><code>include/nuttx/usb/usbhost.h</code></b>.
      All structures and APIs needed to work with USB host-side drivers are provided in this header file.
    </p>
  </li>
  <li>
    <p>
      <b><code>struct usbhost_driver_s</code> and <code>struct usbhost_connection_s</code></b>.
      Each USB host controller driver must implement an instance of <code>struct usbhost_driver_s</code> and <code>struct usbhost_connection_s</code>:
      <code>struct usbhost_driver_s</code> provides the interface between the USB host driver and the USB class driver;
      <code>struct usbhost_connection_s</code> provides the interface between the USB host driver and platform-specific connection management and device enumeration logic.
      These structures are defined in <code>include/nuttx/usb/usbhost.h</code>.
    </p>
    <p>
      <b>Examples</b>:
      <code>arch/arm/src/lpc17xx_40xx/lpc17_40_usbhost.c</code>,
      <code>arch/arm/src/stm32/stm32_otgfshost.c</code>,
      <code>arch/arm/src/sama5/sam_ohci.c</code>, and
      <code>arch/arm/src/sama5/sam_ehci.c</code>.
    </p>
  </li>
  <li>
    <p>
      <b><code>struct usbhost_class_s</code></b>.
      Each USB host class driver must implement an instance of <code>struct usbhost_class_s</code>.
      This structure is also defined in <code>include/nuttx/usb/usbhost.h</code>.
    </p>
    <p>
      <b>Examples</b>:
      <code>drivers/usbhost/usbhost_storage.c</code>
    </p>
  </li>
  <li>
    <p>
      <b>USB Host Class Driver Registry</b>.
      The NuttX USB host infrastructure includes a <i>registry</i>.
      During its initialization, each USB host class driver must call the interface, <code>usbhost_registerclass()</code>
      in order add its interface to the registry.
      Later, when a USB device is connected, the USB host controller will look up the USB host class driver that is needed to support the connected device in this registry.
    </p>
    <p>
      <b>Examples</b>:
      <code>drivers/usbhost/usbhost_registry.c</code>, <code>drivers/usbhost/usbhost_registerclass.c</code>, and <code>drivers/usbhost/usbhost_findclass.c</code>,
    </p>
  </li>
  <li>
    <p>
      <b>Detection and Enumeration of Connected Devices</b>.
      Each USB host device controller supports two methods that are used to detect and enumeration newly connected devices
      (and also detect disconnected devices):
    </p>
    <p>
      <ul>
        <li>
          <p>
            <code>int (*wait)(FAR struct usbhost_connection_s *drvr, FAR const bool *connected);</code>
          </p>
          <p>
            Wait for a device to be connected or disconnected.
          </p>
        </li>
        <li>
          <p>
            <code>int (*enumerate)(FAR struct usbhost_connection_s *drvr, int rhpndx);</code>
          </p>
          <p>
            Enumerate the device connected to a root hub port.
            As part of this enumeration process, the driver will
            (1) get the device's configuration descriptor,
            (2) extract the class ID info from the configuration descriptor,
            (3) call <code>usbhost_findclass(</code>) to find the class that supports this device,
            (4) call the <code>create()</code> method on the <code>struct usbhost_registry_s interface</code> to get a class instance, and
            finally (5) call the <code>connect()</code> method of the <code>struct usbhost_class_s</code> interface.
            After that, the class is in charge of the sequence of operations.
          </p>
      </ul>
    </p>
  </li>
  <li>
    <p>
      <b>Binding USB Host-Side Drivers</b>.
      USB host-side controller drivers are not normally directly accessed by user code,
      but are usually bound to another, higher level USB host class driver.
      The class driver exports the standard NuttX device interface so that the connected USB device can be accessed just as with other, similar, on-board devices.
      For example, the USB host mass storage class driver (<code>drivers/usbhost/usbhost_storage.c</code>) will register a standard, NuttX block driver interface (like <code>/dev/sda</code>)
      that can be used to mount a file system just as with any other other block driver instance.
      In general, the binding sequence is:
    </p>
    <p>
      <ol>
        <li>
          <p>
            Each USB host class driver includes an initialization entry point that is called from the
            application at initialization time.
            This driver calls <code>usbhost_registerclass()</code> during this initialization in order to makes itself available in the event the device that it supports is connected.
          </p>
          <p>
            <b>Examples</b>:
            The function <code>usbhost_msc_initialize()</code> in the file <code>drivers/usbhost/usbhost_storage.c</code>
          </p>
        </li>
        <li>
          <p>
            Each application must include a <i>waiter</i> thread thread that (1) calls the USB host controller driver's <code>wait()</code> to detect the connection of a device, and then
            (2) call the USB host controller driver's <code>enumerate</code> method to bind the registered USB host class driver to the USB host controller driver.
          </p>
          <p>
            <b>Examples</b>:
            The function <code>nsh_waiter()</code> in the file <code>boards/arm/lpc17xx_40xx/olimex-lpc1766stk/src/lpc17_40_appinit.c</code>.
          </p>
        </li>
        <li>
          <p>
            As part of its operation during the binding operation, the USB host class driver will register an instances of a standard NuttX driver under the <code>/dev</code> directory.
            To repeat the above example, the USB host mass storage class driver (<code>drivers/usbhost/usbhost_storage.c</code>) will register a standard, NuttX block driver interface (like <code>/dev/sda</code>)
            that can be used to mount a file system just as with any other other block driver instance.
          </p>
          <p>
            <b>Examples</b>:
            See the call to <code>register_blockdriver()</code> in the function <code>usbhost_initvolume()</code> in the file <code>drivers/usbhost/usbhost_storage.c</code>.
          </p>
        </li>
      </ol>
    </p>
  </li>
</ul>

<h3><a name="usbdevdrivers">6.3.9 USB Device-Side Drivers</a></h3>

<ul>
  <li>
    <p>
      <b><code>include/nuttx/usb/usbdev.h</code></b>.
      All structures and APIs needed to work with USB device-side drivers are provided in this header file.
    </p>
  </li>
  <li>
    <p>
      <b><code>include/nuttx/usb/usbdev_trace.h</code></b>.
      Declarations needed to work with the NuttX USB device driver trace capability.
      That USB trace capability is detailed in <a href="UsbTrace.html">separate document</a>.
    </p>
  </li>
  <li>
    <p>
      <b><code>struct usbdev_s</code></b>.
      Each USB device controller driver must implement an instance of <code>struct usbdev_s</code>.
      This structure is defined in <code>include/nuttx/usb/usbdev.h</code>.
    </p>
    <p>
      <b>Examples</b>:
      <code>arch/arm/src/dm320/dm320_usbdev.c</code>, <code>arch/arm/src/lpc17xx_40xx/lpc17_40_usbdev.c</code>,
      <code>arch/arm/src/lpc214x/lpc214x_usbdev.c</code>, <code>arch/arm/src/lpc313x/lpc313x_usbdev.c</code>, and
       <code>arch/arm/src/stm32/stm32_usbdev.c</code>.
    </p>
  </li>
  <li>
    <p>
      <b><code>struct usbdevclass_driver_s</code></b>.
      Each USB device class driver must implement an instance of <code>struct usbdevclass_driver_s</code>.
      This structure is also defined in <code>include/nuttx/usb/usbdev.h</code>.
    </p>
    <p>
      <b>Examples</b>:
      <code>drivers/usbdev/pl2303.c</code> and <code>drivers/usbdev/usbmsc.c</code>
    </p>
  </li>
  <li>
    <p>
      <b>Binding USB Device-Side Drivers</b>.
      USB device-side controller drivers are not normally directly accessed by user code,
      but are usually bound to another, higher level USB device class driver.
      The class driver is then configured to export the USB device functionality.
      In general, the binding sequence is:
    </p>
    <p>
      <ol>
        <li>
          <p>
            Each USB device class driver includes an initialization entry point that is called from the
            application at initialization time.
          </p>
          <p>
            <b>Examples</b>:
            The function <code>usbdev_serialinitialize()</code> in the file <code>drivers/usbdev/pl2303.c</code> and
            the function <code></code> in the file <code>drivers/usbdev/usbmsc.c</code>
          </p>
        </li>
        <li>
          <p>
            These initialization functions called the driver API, <code>usbdev_register()</code>.
            This driver function will <i>bind</i> the USB class driver to the USB device controller driver,
            completing the initialization.
          </p>
        </li>
      </ol>
    </p>
  </li>
</ul>

<h3><a name="usbdevdrivers">6.3.10 SocketCAN Device Drivers</a></h3>

<ul>
  <li>
    <p>
      <b><code>include/nuttx/net/netdev.h</code></b>.
      All structures and APIs needed to work with drivers are provided in this header file. The structure struct net_driver_s defines the interface and is passed to the network via netdev_register().
    </p>
  </li>
  <li>
    <p>
      <b><code>include/nuttx/can.h</code></b>.
      CAN & CAN FD frame data structures.
    </p>
  </li>
  <li>
    <p>
      <b><code>int netdev_register(FAR struct net_driver_s *dev, enum net_lltype_e lltype)'</code></b>.
      Each driver registers itself by calling netdev_register().
    </p>
  </li>
    <li>
    <p>
      <b><code>Include/nuttx/net/can.h</code></b>.
      contains lookup tables for CAN dlc to CAN FD len sizes named
    </p>
    <code>
	extern const uint8_t can_dlc_to_len[16];
    </code></br>
    <code>
	extern const uint8_t len_to_can_dlc[65];
    </code>
  </li>
  <li>
    <p>
      <b>Initialization sequence is as follows</b>.
      <ol>
        <li>up_netinitialize(void) is called on startup of NuttX in this function you call your own init function to initialize your CAN driver</li>
        <li>In your own init function you create the net_driver_s structure set required init values and register the required callbacks for SocketCAN</li>
        <li>Then you ensure that the CAN interface is in down mode (usually done by calling the d_ifdown function)</li>
        <li>Register the net_driver_s using netdev_register</li>
      </ol>
    </p>
  </li>
  <li>
    <p>
      <b>Receive sequence is as follows</b>.
      <ol>
        <li>Device generates interrupt</li>
        <li>Process this interrupt in your interrupt handler</li>
        <li>When a new CAN frame has been received you process this frame</li>
        <li>When the CAN frame is a normal CAN frame you allocate the can_frame struct, when it's a CAN FD frame you allocate a canfd_frame struct (note you can of course preallocate and just use the pointer).</li>
        <li>Copy the frame from the driver to the struct you've allocated in the previous step.</li>
        <li>Point the net_driver_s d_buf pointer to the allocated can_frame</li>
        <li>Call the <code>can_input(FAR struct net_driver_s *dev)</code> function <code>include/nuttx/net/can.h</code></li>
      </ol>
    </p>
  </li>
  <li>
    <p>
      <b>Transmit sequence is as follows</b>.
      <ol>
        <li>Socket layer executes d_txavail callback</li>
        <li>An example of the txavail function can be found in <code>arch/arm/src/s32k1xx/s32k1xx_flexcan.c</code></li>
        <li>An example of the txpoll function can be found in <code>arch/arm/src/s32k1xx/s32k1xx_flexcan.c</code></li>
        <li>In your <code>transmit(struct driver_s *priv)</code> function you check the length of <code>net_driver_s.d_len</code> whether it matches the size of a <code>struct can_frame</code> or <code>struct canfd_frame</code> then you cast the content of the <code>net_driver_s.d_buf</code> pointer to the correct CAN frame struct</li>
      </ol>
    </p>
  </li>
</ul>

<h2><a name="syslog">6.4 SYSLOG</a></h2>

<h3><a name="syslogif">6.4.1 SYSLOG Interfaces</a></h3>
<h4><a name="syslogstdif">6.4.1.1 Standard SYSLOG Interfaces</a></h4>

  The NuttX SYSLOG is an architecture for getting debug and status
  information from the system.  The syslogging interfaces are defined in the
  header file <code>include/syslog.h</code>.  The primary interface to SYSLOG sub-system
  is the function <code>syslog()</code> and, to a lesser extent, its companion <code>vsyslog()</code>:

<h4><a name="vsyslog">6.4.1.2 <code>syslog()</code> and <code>vsyslog()</code></a></h4>
<p><b>Function Prototypes:</b></p>
<ul><pre>
#include &lt;syslog.h&gt;
int syslog(int priority, FAR const IPTR char *format, ...);
void vsyslog(int priority, FAR const IPTR char *src, va_list ap);
</pre></ul>
<p><b>Description:</b>
  <code>syslog()</code> generates a log message. The priority argument is formed by  ORing the facility and the level values (see <code>include/syslog.h</code>). The remaining arguments are a format, as in <code>printf()</code> and any arguments to the format.
</p>
<p>
  The NuttX implementation does not support any special formatting characters beyond those supported by <code>printf()</code>.
</p>
<p>
  The function <code>vsyslog()</code> performs the same task as <code>syslog()</code> with the difference that it takes a set of arguments which have been obtained using the <code>stdarg</code> variable argument list macros.
</p>

<h4><a name="setlogmask">6.4.1.3 <code>setlogmask()</code></a></h4>
<p>
  The additional <code>setlogmask()</code> interface can use use to filter SYSLOG output:
</p>
<p><b>Function Prototype:</b></p>
<ul><pre>
#include &lt;syslog.h&gt;
int setlogmask(int mask);
</pre></ul>
<p><b>Description:</b>
  The <code>setlogmask()</code> function sets the logmask and returns the previous mask. If the mask argument is zerio, the current logmask is not modified.
</p>
<p>
  The SYSLOG priorities are: <code>LOG_EMERG</code>, <code>LOG_ALERT</code>, <code>LOG_CRIT</code>, <code>LOG_ERR</code>, <code>LOG_WARNING</code>, <code>LOG_NOTICE</code>, <code>LOG_INFO</code>, and <code>LOG_DEBUG</code>.  The bit corresponding to a priority <code>p</code> is <code>LOG_MASK(p)</code>; <code>LOG_UPTO(p)</code> provides the mask of all priorities in the above list up to and including <code>p</code>.
</p>
<p>
  Per <i>OpenGroup.org</i> &quot;If the maskpri argument is 0, the current log mask is not modified.&quot;  In this implementation, the value zero is permitted in order to disable all SYSLOG levels.
</p>
<p>
  REVISIT: Per POSIX the SYSLOG mask should be a per-process value but in NuttX, the scope of the mask is dependent on the nature of the build:
</p>
<ul>
  </li>
  <li>
    <p>
      <i>Flat Build</i>:  There is one, global SYSLOG mask that controls all output.
  </li>
  <li>
    <p>
      <i>Protected Build</i>:  There are two SYSLOG masks.  One within the kernel that controls only kernel output.  And one in user-space that controls only user SYSLOG output.
  </li>
  <li>
    <p>
      <i>Kernel Build</i>:  The kernel build is compliant with the POSIX requirement: There will be one mask for for each user process, controlling the SYSLOG output only form that process.  There will be a separate mask accessible only in the kernel code to control kernel SYSLOG output.
</ul>
<p>
  The above are all standard interfaces as defined at <a href="http://pubs.opengroup.org/onlinepubs/009695399/functions/closelog.html">OpenGroup.org</a>.  Those interfaces are available for use by application software.  The remaining interfaces discussed in this section are non-standard, OS-internal interfaces.
</p>

<h4><a name="debugifs">6.4.1.4 Debug Interfaces</a></h4>
<p>
  In NuttX, syslog output is really synonymous to debug output and, therefore, the debugging interface macros defined in the header file
  <code>include/debug.h</code> are also syslogging interfaces.  Those macros are simply wrappers around <code>syslog()</code>.  The debugging interfaces differ from the syslog interfaces in that:
</p>
<ul>
  </li>
  <li>
    <p>
      They do not take a priority parameter; the priority is inherent in the
      debug macro name.
  </li>
  <li>
    <p>
      They decorate the output stream with information such as the file name
  </li>
  <li>
    <p>
      They can each be disabled via configuration options.
  </li>
</ul>
<p>
  Each debug macro has a base name that represents the priority and a prefix that represents the sub-system.  Each macro is individually initialized by both priority and sub-system.  For example, <code>uerr()</code> is the macro used for error level messages from the USB subsystem and is enabled with <code>CONFIG_DEBUG_USB_ERROR</code>.
</p>
<p>
  The base debug macro names, their priority, and configuration variable are summarized below:
</p>
<ul>
  </li>
  <li>
    <p>
      <code>info()</code>.  The <code>info()</code> macro is the lowest priority (<code>LOG_INFO</code>) and is intended to provide general information about the flow of program execution so that you can get an overview of the behavior of the program.  <code>info()</code> is often very chatty and voluminous and usually more  information than you may want to see.  The <code>info()</code> macro is controlled via CONFIG_DEBUG_subsystem_INFO
  </li>
  <li>
    <p>
      <code>warn()</code>.  The <code>warn()</code> macro has medium priority (<code>LOG_WARN</code>) and is controlled by <code>CONFIG_DEBUG_<i>subsystem</i>_WARN</code>.  The <code>warn()</code> is intended to
      note exceptional or unexpected conditions that might be potential
      errors or, perhaps, minor errors that easily recovered.
  </li>
  <li>
    <p>
      <code>err()</code>.  This is a high priority debug macro (<code>LOG_ERROR</code>) and controlled by <code>CONFIG_DEBUG_<i>subsystem</i>_ERROR</code>.  The <code>err()</code> is reserved to indicate important error conditions.
  </li>
  <li>
    <p>
      <code>alert()</code>. The highest priority debug macro (<code>LOG_EMERG</code>) and is controlled by <code>CONFIG_DEBUG_ALERT</code>.  The <code>alert()</code> macro is reserved for use solely by assertion and crash handling logic.  It also differs from the other macros in that it cannot be enabled or disabled per subsystem.
  </li>
</ul>

<h3><a name="syslogchannels">6.4.2 SYSLOG Channels</a></h3>
<h4><a name="debugifs">6.4.2.1 SYSLOG Channel Interfaces</a></h4>
<p>
  In the NuttX SYSLOG implementation, the underlying device logic the supports the SYSLOG output is referred to as a SYSLOG <i>channel</i>.  Each SYSLOG channel is represented by an interface defined in <code>include/nuttx/syslog/syslog.h</code>:
</p>
<ul><pre>
    /* This structure provides the interface to a SYSLOG device */

    typedef CODE int (*syslog_putc_t)(int ch);
    typedef CODE int (*syslog_flush_t)(void);

    struct syslog_channel_s
    {
      /* I/O redirection methods */

      syslog_putc_t sc_putc;    /* Normal buffered output */
      syslog_putc_t sc_force;   /* Low-level output for interrupt handlers */
      syslog_flush_t sc_flush;  /* Flush buffered output (on crash) */

      /* Implementation specific logic may follow */
    };
</pre></ul>
<p>
  The channel interface is instantiated by calling <code>syslog_channel()</code>:
</p>

<h4><a name="syslogchannel">6.4.2.1 <code>syslog_channel()</code></a></h4>
<p><b>Function Prototype:</b></p>
<ul><pre>
#include &lt;nuttx/syslog/syslog.h&gt;
int syslog_channel(FAR const struct syslog_channel_s *channel);
</pre></ul>
<p><b>Description:</b>
  Configure the SYSLOG function to use the provided channel to generate SYSLOG output.
</p>
<p>
  <code>syslog_channel()</code> is a non-standard, internal OS interface and is not available to applications.  It may be called numerous times as necessary to change channel interfaces.
  By default, all system log output goes to console (<code>/dev/console</code>).
</p>
<p><b>Input Parameters:</b>
<ul>
  <li>
    <p>
       <code>channel</code>: Describes the interface to the channel to be used.
  </li>
</ul>
<p><b>Returned Value:</b>
<ul>
  <p>
    Zero (<code>OK</code>)is returned on success.  A negated <code>errno</code> value is returned on any failure.
  </p>
</ul>

<h4><a name="sysloginit">6.4.2.2 SYSLOG Channel Initialization</a></h4>
<p>
  The initial, default SYSLOG channel is established with statically initialized global variables so that some level of SYSLOG output may be available immediately upon reset.  This initialized data is in the file <code>drivers/syslog/syslog_channel.c</code>.  The initial SYSLOG capability is determined by the selected SYSLOG channel:
</p>
<ul>
  <li>
    <p>
      <i>In-Memory Buffer (RAMLOG)</i>.  Full SYSLOG capability as available at reset.
  </li>
  <li>
    <p>
      <i>Serial Console</i>.  If the serial implementation provides the low-level character output function <code>up_putc()</code>, then that low level serial output is available as soon as the serial device has been configured.
  </li>
  <li>
    <p>
      For all other SYSLOG channels, all SYSLOG output goes to the bit-
      bucket until the SYSLOG channel device has been initialized.
  </li>
</ul>
<p>
  The syslog channel device is initialized when the bring-up logic calls <code>syslog_initialize()</code>:
</p>

<h4><a name="sysloginit">6.4.2.3 <code>syslog_initialize()</code></a></h4>
<p><b>Function Prototype:</b></p>
<ul><pre>
#include &lt;nuttx/syslog/syslog.h&gt;
#ifndef CONFIG_ARCH_SYSLOG
int syslog_initialize(void);
#else
#  define syslog_initialize()
#endif
</ul></pre>
<p><b>Description:</b>
  One power up, the SYSLOG facility is non-existent or limited to very low-level output.  This function is called later in the initialization sequence after full driver support has been initialized.  It installs the configured SYSLOG drivers and enables full SYSLOG capability.
</p>
<p>
  This function performs these basic operations:
</p>
<ul>
  <li>
    <p>
      Initialize the SYSLOG device
  </li>
  <li>
    <p>
      Call <code>syslog_channel()</code> to begin using that device.
  </li>
  <li>
    <p>
      If <code>CONFIG_ARCH_SYSLOG</code> is selected, then the architecture-specific logic will provide its own SYSLOG device initialize which must include as a minimum a call to <code>syslog_channel()</code> to use the device.
  </li>
</ul>
<p><b>Returned Value:</b>
  Zero (<code>OK</code>) is returned on success; a negated <code>errno</code> value is returned on any failure.
</p>
<p>
  Different types of SYSLOG devices have different OS initialization
  requirements.  Some are available immediately at reset, some are available
  after some basic OS initialization, and some only after OS is fully
  initialized.
</p>
<p>
  There are other types of SYSLOG channel devices that may require even further initialization.  For example, the file SYSLOG channel (described below) cannot be initialized until the necessary file systems have been mounted.
</p>

<h4><a name="sysloginterrupt">6.4.2.3 Interrupt Level SYSLOG Output</a></h4>
<p>
  As a general statement, SYSLOG output only supports //normal// output from NuttX tasks.  However, for debugging purposes, it is also useful to get SYSLOG output from interrupt level logic.  In an embedded system, that is often where the most critical operations are performed.
</p>
<p>
  There are three conditions under which SYSLOG output generated from interrupt level processing can a included the SYSLOG output stream:
</p>
<ol>
  <li>
    <p><b>Low-Level Serial Output</b>.
      If you are using a SYSLOG console channel (<code>CONFIG_SYSLOG_CONSOLE</code>) and if the underlying architecture supports the low-level <code>up_putc()</code> interface(<code>CONFIG_ARCH_LOWPUTC</code>), then the SYSLOG logic will direct the output to <code>up_putc()</code> which is capable of generating the serial output within the context of an interrupt handler.
    </p>
    <p>
      There are a few issues in doing this however:
    </p>
    <ul>
      <li>
        <p>
          <code>up_putc()</code> is able to generate debug output in any context because it disables serial interrupts and polls the hardware directly.  These polls may take many milliseconds and during that time, all interrupts are disable within the interrupt handler.  This, of course, interferes with the real-time behavior of the RTOS.
        </p>
      </li>
      <li>
        <p>
          The output generated by <code>up_putc()</code> is immediate and in real-time.  The normal SYSLOG output, on the other hand, is buffered in the serial driver and may be delayed with respect to the immediate output by many lines.  Therefore, the interrupt level SYSLOG output provided through <code>up_putc()</code> is grossly out of synchronization with other debug output
        </p>
      </li>
    </ul>
  </ul>
</li>
<li>
  <p><b>In-Memory Buffering</b>.
    If the RAMLOG SYSLOG channel is supported, then all SYSLOG output is buffered in memory.  Interrupt level SYSLOG output is no different than normal SYSLOG output in this case.
  </p>
</li>
<li>
  <p><b>Serialization Buffer</b>.
    A final option is the use of an <i>interrupt buffer</i> to buffer the interrupt level SYSLOG output.  In this case:
  </p>
  <ul>
    <li>
      <p>
        SYSLOG output generated from interrupt level process in not sent to the SYSLOG channel immediately.  Rather, it is buffered in the interrupt serialization buffer.
      </p>
    </li>
    <li>
      <p>
        Later, when the next normal syslog output is generated, it will first empty the content of the interrupt buffer to the SYSLOG device in the proper context.  It will then be followed by the normal syslog output.  In this case, the interrupt level SYSLOG output will interrupt the normal output stream and the interrupt level SYSLOG output will be inserted into the correct position in the SYSLOG output when the next normal SYSLOG output is generated.
      </p>
    </li>
  </ul>
  <p>
    The SYSLOG interrupt buffer is enabled with <code>CONFIG_SYSLOG_INTBUFFER</code>.  When the interrupt buffer is enabled, you must also provide the size of the interrupt buffer with <code>CONFIG_SYSLOG_INTBUFSIZE</code>.
  </p>
</li>
</ol>

<h3><a name="syslogoptions">6.4.3 SYSLOG Channel Options</a></h3>
<h4><a name="syslogconsole">6.4.3.1 SYSLOG Console Device</a></h4>
<p>
  The typical SYSLOG device is the system console.  If you are using a serial console, for example, then the SYSLOG output will appear on that serial port.
</p>
<p>
  This SYSLOG channel is automatically selected by <code>syslog_initialize()</code> in the LATE initialization phase based on configuration options.  The configuration options that affect this channel selection include:
</p>
<ul>
  <li>
    <p>
      <code>CONFIG_DEV_CONSOLE</code>.  This setting indicates that the system supports a console device, i.e., that the character device <code>/dev/console</code> exists.
  </li>
  <li>
    <p>
      <code>CONFIG_SERIAL_CONSOLE</code>.  This configuration option is automatically selected when a UART or USART is configured as the system console.  There is no user selection.
  </li>
  <li>
    <p>
      <code>CONFIG_SYSLOG_CONSOLE</code>.  This configuration option is manually selected from the SYSLOG menu.  This is the option that actually enables the SYSLOG console device.  It depends on <code>CONFIG_DEV_CONSOLE</code>.
  </li>
  <li>
    <p>
      <code>CONFIG_ARCH_LOWPUTC</code>.  This is an indication from the architecture configuration that the platform supports the <code>up_putc()</code> interface.  <code>up_putc()</code> is a very low level UART interface that can even be used from interrupt handling.
  </li>
</ul>
<p>
  Interrupt level SYSLOG output will be lost unless:  (1) the interrupt buffer
  is enabled to support serialization, or (2) a serial console is used and
  <code>up_putc()</code> is supported.
</p>
<p>
  NOTE: The console channel uses the fixed character device at <code>/dev/console</code>.  The console channel is not synonymous with <code>stdout</code> (or file descriptor 1).  <code>stdout</code> is the current output from a task when, say, <code>printf()</code> if used.  Initially, <code>stdout</code> does, indeed, use the <code>/dev/console</code> device.  However, <code>stdout</code> may subsequently be redirected to some other device or file.  This is always the case, for example, when a transient device is used for a console -- such as a USB console or a Telnet console.  The SYSLOG channel is not redirected as <code>stdout</code> is; the SYSLOG channel will stayed fixed (unless it is explicitly changed via <code>syslog_channel()</code>).
</p>
<p>
  References: <code>drivers/syslog/syslog_consolechannel.c</code> and
  <code>drivers/syslog/syslog_device.c</code>
</p>

<h4><a name="syslogchardev">6.4.3.2 SYSLOG Character Device</a></h4>
<p>
  The system console device, <code>/dev/console</code>, is a character driver with some special properties.  However, any character driver may be used as the SYSLOG output channel.  For example, suppose you have a serial console on <code>/dev/ttyS0</code> and you want SYSLOG output on <code>/dev/ttyS1</code>.  Or suppose you support only a Telnet console but want to capture debug output <code>/dev/ttyS0</code>.
</p>
<p>
  This SYSLOG device channel is selected with <code>CONFIG_SYSLOG_CHAR</code> and has no other dependencies.  Differences from the SYSLOG console channel include:
</p>
<ul>
  <li>
    <p>
      <code>CONFIG_SYSLOG_DEVPATH</code>.  This configuration option string must be set provide the full path to the character device to be used.
  </li>
  <li>
    <p>
      The forced SYSLOG output always goes to the bit-bucket.  This means that interrupt level SYSLOG output will be lost unless the interrupt buffer is enabled to support serialization.
  </li>
  <li>
    <p>
      <code>CONFIG_SYSLOG_CHAR_CRLF</code>.  If <code>CONFIG_SYSLOG_CHAR_CRLF</code> is selected, then linefeeds in the SYSLOG output will be expanded to Carriage Return plus Linefeed.  Since the character device is not a console device, the addition of carriage returns to line feeds would not be performed otherwise.  You would probably want this expansion if you use a serial terminal program with the character device output.
  </li>
</ul>
<p>
  References: <code>drivers/syslog/syslog_devchannel.c</code> and <code>drivers/syslog/syslog_device.c</code>
</p>

<h4><a name="syslogfiledev">6.4.3.3 SYSLOG File Device</a></h4>
<p>
  Files can also be used as the sink for SYSLOG output.  There is, however, a very fundamental difference in using a file as opposed the system console, a RAM buffer, or character device:  You must first mount the file system that supports the SYSLOG file.  That difference means that the file SYSLOG channel cannot be supported during the boot-up phase but can be instantiated later when board level logic configures the application environment, including mounting of the file systems.
</p>
<p>
  The interface <code>syslog_file_channel()</code> is used to configure the SYSLOG file channel:
</p>

<h4><a name="syslogfiledev">6.4.3.4 <code>syslog_file_channel()</code></a></h4>
<p><b>Function Prototype:</b></p>
<ul><pre>
#include &lt;nuttx/syslog/syslog.h&gt;
#ifdef CONFIG_SYSLOG_FILE
int syslog_file_channel(FAR const char *devpath);
#endif
</pre></ul>
<p><b>Description:</b>
  Configure to use a file in a mounted file system at <code>devpath</code> as the SYSLOG channel.
</p>
<p>
  This tiny function is simply a wrapper around <code>syslog_dev_initialize()</code> and <code>syslog_channel()</code>.  It calls <code>syslog_dev_initialize()</code> to configure the character file at <code>devpath</code> then calls <code>syslog_channel()</code> to use that device as the SYSLOG output channel.
</p>
<p>
  File SYSLOG channels differ from other SYSLOG channels in that they cannot be established until after fully booting and mounting the target file system.  This function would need to be called from board-specific bring-up logic AFTER mounting the file system containing <code>devpath</code>.
</p>
<p>
  SYSLOG data generated prior to calling <code>syslog_file_channel()</code> will, of course, not be included in the file.
</p>
<p>
  NOTE interrupt level SYSLOG output will be lost in this case unless the interrupt buffer is used.
</p>

<p><b>Input Parameters:</b>
<ul>
  <li>
    <p>
      <code>devpath</code>: The full path to the file to be used for SYSLOG output.  This may be an existing file or not.  If the file exists,
      <code>syslog_file_channel()</code> will append new SYSLOG data to the end of the file.  If it does not, then <code>syslog_file_channel()</code> will create the file.
  </li>
</ul>
<p><b>Returned Value:</b>
  Zero (<code>OK</code>) is returned on success; a negated <code>errno</code> value is returned on any failure.
</p>
<p>
  References: <code>drivers/syslog/syslog_filechannel.c</code>, <code>drivers/syslog/syslog_device.c</code>, and <code>include/nuttx/syslog/syslog.h</code>.
</p>

<h4><a name="syslogramlog">6.4.3.5 SYSLOG RAMLOG Device</a></h4>
<p>
  The RAMLOG is a standalone feature that can be used to buffer any
  character data in memory.  There are, however, special configurations
  that can be used to configure the RAMLOG as a SYSLOG channel.  The RAMLOG
  functionality is described in a more general way in the following
  paragraphs.
</p>

<h3><a name="ramlog">6.4.4 RAM Logging Device</a></h3>
</p>
  The RAM logging driver is a driver that was intended to support debugging output (SYSLOG) when the normal serial output is not available.  For example, if you are using a Telnet or USB serial console, the debug output will get lost -- or worse.  For example, what if you want to debug the network over Telnet?
</p>
<p>
  The RAM logging driver can also accept debug output data from interrupt handler with no special serialization buffering.  As an added benefit, the RAM logging driver is much less invasive.  Since no actual I/O is performed with the debug output is generated, the RAM logger tends to be much faster and will interfere much less when used with time critical drivers.
</p>
<p>
  The RAM logging driver is similar to a pipe in that it saves the debugging output in a circular buffer in RAM.  It differs from a pipe in numerous details as needed to support logging.
</p>
<p>
  This driver is built when <code>CONFIG_RAMLOG</code> is defined in the Nuttx configuration.
</p>

<h4><a name="ramlogdmesg">6.4.4.1 <code>dmesg</code></a></h4>
<p>
  When the RAMLOG (with SYSLOG) is enabled, a new NuttShell (NSH) command will appear:  <code>dmesg</code>.  The <code>dmesg</code> command will dump the contents of the circular buffer to the console (and also clear the circular buffer).
</p>

<h4><a name="ramlogconfig">6.4.4.2 RAMLOG Configuration options</a></h4>
<ul>
  <li>
    <p>
      <code>CONFIG_RAMLOG</code>: Enables the RAM logging feature
  </li>
  <li>
    <p>
      <code>CONFIG_RAMLOG_SYSLOG</code>: Use the RAM logging device for the SYSLOG interface.  If this feature is enabled, then all debug output will be re-directed to the circular  buffer in RAM.  This RAM log can be viewed from NSH using the <code>dmesg</code>  command.  NOTE:  Unlike the limited, generic character driver SYSLOG device, the RAMLOG <i>can</i> be used to capture debug output from
      interrupt level handlers.
  </li>
  <li>
    <p>
      <code>CONFIG_RAMLOG_NPOLLWAITERS</code>: The number of threads than can be waiting for this driver on <code>poll()</code>.  Default: 4
  </li>
</ul>
<ul>
  <li>
    <p>
      <code>CONFIG_RAMLOG_BUFSIZE</code>: The size of the circular buffer to use. Default: 1024 bytes.
  </li>
</ul>
<p>
  Other miscellaneous settings
</p>
<ul>
  <li>
    <p>
      <code>CONFIG_RAMLOG_CRLF</code>: Pre-pend a carriage return before every linefeed that goes into the RAM log.
  </li>
  <li>
    <p>
      <code>CONFIG_RAMLOG_NONBLOCKING</code>: Reading from the RAMLOG will never block if the RAMLOG is empty.  If the RAMLOG is empty, then zero is returned (usually interpreted as end-of-file).  If you do not define this, the NSH <code>dmesg</code> command will lock up when called!  So you probably do want this!
  </li>
  <li>
    <p>
      <code>CONFIG_RAMLOG_NPOLLWAITERS</code>: The maximum number of threads that may be waiting on the poll method.
  </li>
</ul>

<h2><a name="pwrmgmt">6.5 Power Management</a></h2>

<h3><a name="pmoverview">6.5.1 Overview</a></h3>
<p>
  <b>Power Management (PM) Sub-System</b>.
  NuttX supports a simple power management (PM) sub-system.  This sub-system:
</p>
<ul>
  <li>
    <p>
      Monitors activity from drivers (and from other parts of the system), and
    </p>
  </li>
  <li>
    <p>
      Provides hooks to place drivers (and the whole system) into reduce power
      modes of operation.
    </p>
  </li>
</ul>
<p>
  <center><img src="pm.png"></center>
</p>
<p>
  The PM sub-system integrates the MCU idle loop with a collection of device drivers to support:
</p>
<ul>
  <li>
    <p>
      Reports of relevant driver or other system activity.
    </p>
  </li>
  <li>
    <p>
      Registration and callback mechanism to interface with individual device drivers.
    </p>
  </li>
  <li>
    <p>
      IDLE time polling of overall driver activity.
    </p>
  </li>
  <li>
    <p>
      Coordinated, global, system-wide transitions to lower power usage states.
    </p>
  </li>
</ul>
<p>
  <b>Low Power Consumption States</b>.
  Various &quot;sleep&quot; and low power consumption states have various names and are sometimes used in conflicting ways.
  In the NuttX PM logic, we will use the following terminology:
</p>
<dl>
  <dt><code>NORMAL</code>
  <dd>The normal, full power operating mode.
  <dt><code>IDLE</code>
  <dd>This is still basically normal operational mode, the system is,
      however, <code>IDLE</code> and some simple simple steps to reduce power
      consumption provided that they do not interfere with normal
      Operation.  Simply dimming the a backlight might be an example
      some that that would be done when the system is idle.
  <dt><code>STANDBY</code>
  <dd>Standby is a lower power consumption mode that may involve more
      extensive power management steps such has disabling clocking or
      setting the processor into reduced power consumption modes. In
      this state, the system should still be able to resume normal
      activity almost immediately.
  <dt><code>SLEEP</code>
  <dd>The lowest power consumption mode.  The most drastic power
      reduction measures possible should be taken in this state. It
      may require some time to get back to normal operation from
      <code>SLEEP</code> (some MCUs may even require going through reset).
</dl>
<p>
  These various states are represented with type <code>enum pm_state_e</code> in <code>include/nuttx/power/pm.h</code>.
</p>

<p>
  <b>Power Management Domains</b>.
  Each PM interfaces includes a integer <i>domain</i> number.
  By default, only a single power domain is supported (<code>CONFIG_PM_NDOMAINS=1</code>).
  But that is configurable; any number of PM domains can be supported.
  Multiple PM domains might be useful, for example, if you would want to control power states associated with a network separately from power states associated with a user interface.
</p>

<h3><a name="pminterfaces">6.5.2 Interfaces</a></h3>
<p>
  All PM interfaces are declared in the file <code>include/nuttx/power/pm.h</code>.
</p>

<h4><a name="pminitialize">6.5.2.1 <code>pm_initialize()</code></a></h4>
<p><b>Function Prototype:</b></p>
<ul><pre>
#include &lt;nuttx/power/pm.h&gt;
void pm_initialize(void);
</pre></ul>
<p><b>Description:</b>
This function is called by MCU-specific one-time at power on reset in order to initialize the power management capabilities.
This function must be called <i>very</i> early in the initialization sequence <i>before</i> any other device drivers are initialized (since they may attempt to register with the power management subsystem).
</p>
<p><b>Input Parameters:</b>
None
</p>
<p><b>Returned Value:</b>
None
</p>

<h4><a name="pmregister">6.5.2.2 <code>pm_register()</code></a></h4>
<p><b>Function Prototype:</b></p>
<ul><pre>
#include &lt;nuttx/power/pm.h&gt;
int pm_register(FAR struct pm_callback_s *callbacks);
</pre></ul>
<p><b>Description:</b>
  This function is called by a device driver in order to register to receive power management event callbacks.
  Refer to the <a href="#pmcallbacks">PM Callback</a> section for more details.
</p>
<p><b>Input Parameters:</b>
 <dl>
   <dt><code>callbacks</code>
   <dd>An instance of <code>struct pm_callback_s</code> providing the driver callback functions.
 </dl>
</p>
<p><b>Returned Value:</b>
Zero (<code>OK</code>) on success; otherwise a negated <code>errno</code> value is returned.
</p>

<h4><a name="pmunregister">6.5.2.3 <code>pm_unregister()</code></a></h4>
<p><b>Function Prototype:</b></p>
<ul><pre>
#include &lt;nuttx/power/pm.h&gt;
int pm_unregister(FAR struct pm_callback_s *callbacks);
</pre></ul>
<p><b>Description:</b>
  This function is called by a device driver in order to unregister previously registered power management event callbacks.
  Refer to the <a href="#pmcallbacks">PM Callback</a> section for more details.
</p>
<p><b>Input Parameters:</b>
 <dl>
   <dt><code>callbacks</code>
   <dd>An instance of <code>struct pm_callback_s</code> providing the driver callback functions.
 </dl>
</p>
<p><b>Returned Value:</b>
Zero (<code>OK</code>) on success; otherwise a negated <code>errno</code> value is returned.
</p>

<h4><a name="pmactivity">6.5.2.4 <code>pm_activity()</code></a></h4>
<p><b>Function Prototype:</b></p>
<ul><pre>
#include &lt;nuttx/power/pm.h&gt;
void pm_activity(int domain, int priority);
</pre></ul>
<p><b>Description:</b>
 This function is called by a device driver to indicate that it is performing meaningful activities (non-idle).
 This increment an activity count and/or will restart a idle timer and prevent entering reduced power states.
</p>
<p><b>Input Parameters:</b>
 <dl>
   <dt><code>domain</code>
   <dd>Identifies the domain of the new PM activity
   <dt><code>priority</code>
   <dd>
     Activity priority, range 0-9.
     Larger values correspond to higher priorities.
     Higher priority activity can prevent the system from entering reduced power states for a longer period of time.
     As an example, a button press might be higher priority activity because it means that the user is actively interacting with the device.
 </dl>
</p>
<p><b>Returned Value:</b>
  None
</p>
<p><b>Assumptions:</b>
  This function may be called from an interrupt handler (this is the ONLY PM function that may be called from an interrupt handler!).
</p>

<h4><a name="pmcheckstate">6.5.2.5 <code>pm_checkstate()</code></a></h4>
<p><b>Function Prototype:</b></p>
<ul><pre>
#include &lt;nuttx/power/pm.h&gt;
enum pm_state_e pm_checkstate(int domain);
</pre></ul>
<p><b>Description:</b>
  This function is called from the MCU-specific IDLE loop to monitor the power management conditions.
  This function returns the &quot;recommended&quot; power management state based on the PM configuration and activity reported in the last sampling periods.
  The power management state is not automatically changed, however.
  The IDLE loop must call <code>pm_changestate()</code> in order to make the state change.
</p>
<p>
  These two steps are separated because the platform-specific IDLE loop may have additional situational information that is not available to the PM sub-system.
  For example, the IDLE loop may know that the battery charge level is very low and may force lower power states even if there is activity.
</p>
<p>
  NOTE: That these two steps are separated in time and, hence, the IDLE loop could be suspended for a long period of time between calling <code>pm_checkstate()</code> and <code>pm_changestate()</code>.
  The IDLE loop may need to make these calls atomic by either disabling interrupts until the state change is completed.
</p>
<p><b>Input Parameters:</b>
 <dl>
   <dt><code>domain</code>
   <dd>Identifies the PM domain to check
 </dl>
</p>
<p><b>Returned Value:</b>
  The recommended power management state.
</p>

<h4><a name="pmchangestate">6.5.2.6 <code>pm_changestate()</code></a></h4>
<p><b>Function Prototype:</b></p>
<ul><pre>
#include &lt;nuttx/power/pm.h&gt;
 int pm_changestate(int domain, enum pm_state_e newstate);
</pre></ul>
<p><b>Description:</b>
  This function is used by platform-specific power management logic.
  It will announce the power management power management state change to all drivers that have registered for power management event callbacks.
</p>
<p><b>Input Parameters:</b>
 <dl>
   <dt><code>domain</code>
   <dd>Identifies the domain of the new PM state
   <dt><code>newstate</code>
   <dd>Identifies the new PM state
 </dl>
</p>
<p><b>Returned Value:</b>
  0 (<code>OK</code>) means that the callback function for all registered drivers returned <code>OK</code> (meaning that they accept the state change).
  Non-zero means that one of the drivers refused the state change.
  In this case, the system will revert to the preceding state.
</p>
<p><b>Assumptions:</b>
   It is assumed that interrupts are disabled when this function is called.
   This function is probably called from the IDLE loop... the lowest priority task in the system.
   Changing driver power management states may result in renewed system activity and, as a result, can
   suspend the IDLE thread before it completes the entire state change unless interrupts are disabled throughout the state change.
</p>

<h3><a name="pmcallbacks">6.5.3 Callbacks</a></h3>
<p>
  The <code>struct pm_callback_s</code> includes the pointers to the driver callback functions.
  This structure is defined <code>include/nuttx/power/pm.h</code>.
  These callback functions can be used to provide power management information to the driver.
</p>

<h4><a name="pmprepare">6.5.3.1 <code>prepare()</code></a></h4>
<p><b>Function Prototype:</b></p>
<ul><pre>
int (*prepare)(FAR struct pm_callback_s *cb, int domain, enum pm_state_e pmstate);
</pre></ul>
<p><b>Description:</b>
   Request the driver to prepare for a new power state.
   This is a warning that the system is about to enter into a new power state.
   The driver should begin whatever operations that may be required to enter power state.
   The driver may abort the state change mode by returning a non-zero value from the callback function.
</p>
<p><b>Input Parameters:</b>
 <dl>
   <dt><code>cb</code>
   <dd>Returned to the driver.
   The driver version of the callback structure may include additional, driver-specific state data at the end of the structure.
   <dt><code>domain</code>
   <dd>Identifies the activity domain of the state change
   <dt><code>pmstate</code>
   <dd>Identifies the new PM state
 </dl>
</p>
<p><b>Returned Value:</b>
   Zero (<code>OK</code>) means the event was successfully processed and that the driver is prepared for the PM state change.
   Non-zero means that the driver is not prepared to perform the tasks needed achieve this power setting and will cause the state change to be aborted.
   NOTE:  The <code>prepare()</code> method will also be called when reverting from lower back to higher power consumption modes (say because another driver refused a lower power state change).
   Drivers are not permitted to return non-zero values when reverting back to higher power
   consumption modes!
</p>

<h4><a name="pmnotify">6.5.3.1 <code>notify()</code></a></h4>
<p><b>Function Prototype:</b></p>
<ul><pre>
#include &lt;nuttx/power/pm.h&gt;
void (*notify)(FAR struct pm_callback_s *cb, int domain, enum pm_state_e pmstate);
</pre></ul>
<p><b>Description:</b>
  Notify the driver of new power state.
  This callback is called after all drivers have had the opportunity to prepare for the new power  state.
</p>
<p><b>Input Parameters:</b>
 <dl>
   <dt><code>cb</code>
   <dd>Returned to the driver.
   The driver version of the callback structure may include additional, driver-specific state data at the end of the structure.
   <dt><code>domain</code>
   <dd>Identifies the activity domain of the state change
   <dt><code>pmstate</code>
   <dd>Identifies the new PM state
 </dl>
</p>
<p><b>Returned Value:</b>
  None.
  The driver already agreed to transition to the low power consumption state when when it returned <code>OK</code> to the <code>prepare()</code> call.
</p>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
    <td>
      <h1><a name="apndxconfigs">Appendix A:  NuttX Configuration Settings</a></h1>
    </td>
  </tr>
</table>

<p>
  At one time, this section provided a list of all NuttX configuration variables.
  However, NuttX has since converted to use the <a href="https://bitbucket.org/nuttx/tools/src/master/kconfig-frontends/">kconfig-frontends</a> tools.
  Now, the NuttX configuration is determined by a self-documenting set of <code>Kconfig</code> files.
</p>
<p>
  The current NuttX configuration variables are also documented in separate, auto-generated configuration variable document.
  That configuration variable document is generated using the <code>kconfig2html</code> tool that can be found in the <code>nuttx/tools</code> directory.
  That tool analyzes the NuttX Kconfig files and generates excruciatingly boring HTML document.
</p>
<p>
  The latest boring configuration variable documentation can be regenerated at any time using that tool or, more appropriately, the wrapper script at <code>nuttx/tools/mkconfigvars.sh</code>.
  That script will generate the file <code>nuttx/Documentation/NuttXConfigVariables.html</code>.
<p>
  The version of <code>NuttXConfigVariables.html</code> for the last released version of NuttX can also be found <a href="http://nuttx.org/Documentation/NuttXConfigVariables.html">online</a>.
</p>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
    <td>
      <h1><a name="apndxtrademarks">Appendix B:  Trademarks</a></h1>
    </td>
  </tr>
</table>

  <li>ARM, ARM7 ARM7TDMI, ARM9, ARM920T, ARM926EJS, Cortex-M3 are trademarks of Advanced RISC Machines, Limited.</li>
  <li>Cygwin is a trademark of Red Hat, Incorporated.</li>
  <li>Linux is a registered trademark of Linus Torvalds.</li>
  <li>Eagle-100 is a trademark of <a href=" http://www.micromint.com/">Micromint USA, LLC</a>.
  <li>LPC2148 is a trademark of NXP Semiconductors.</li>
  <li>TI is a trade name of Texas Instruments Incorporated.</li>
  <li>UNIX is a registered trademark of The Open Group.</li>
  <li>VxWorks is a registered trademark of Wind River Systems, Incorporated.</li>
  <li>ZDS, ZNEO, Z16F, Z80, and Zilog are a registered trademark of Zilog, Inc.</li>

<p>
  NOTE: NuttX is <i>not</i> licensed to use the POSIX trademark.  NuttX uses the POSIX
  standard as a development guideline only.
</p>

</div>
</div>

</body>
</html>
