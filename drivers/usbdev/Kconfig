#
# For a description of the syntax of this configuration file,
# see the file kconfig-language.txt in the NuttX tools repository.
#

menuconfig USBDEV
	bool "USB Device Driver Support"
	default n
	---help---
		USB device drivers.  See also include/nuttx/usb/usbdev.h

if USBDEV

comment "USB Device Controller Driver Options"

config USBDEV_ISOCHRONOUS
	bool "Enable isochronous"
	default n
	---help---
		Build in extra support for isochronous endpoints

config USBDEV_DUALSPEED
	bool "Enable high and full speed"
	default n
	---help---
		Hardware handles high and full speed operation (USB 2.0)

choice
	prompt "Select USB device powered"
	default USBDEV_SELFPOWERED

config USBDEV_SELFPOWERED
	bool "Self powered"
	---help---
		Will cause USB features to indicate that the device is self-powered

config USBDEV_BUSPOWERED
	bool "Bus powered"
	---help---
		Will cause USB features to indicate that the device is not self-powered

endchoice

config USBDEV_MAXPOWER
	int "Maximum power consumption in mA"
	default 100
#	depends on USBDEV_BUSPOWERED
	---help---
		Maximum power consumption in mA.  This selection should only apply if
		the device is bus powered (USBDEV_BUSPOWERED).  It is, however, used
		unconditionally in several USB device drivers.

config USBDEV_DMA
	bool "Enable DMA methods"
	default n
	---help---
		Select this enable DMA-related methods in USB device controller driver
		interface.  These methods include the DMA buffer allocation methods:
		allobuffer() and freebuffer().

		The USB class driver allocates packet I/O buffers for data transfer by
		calling the driver allocbuffer() and freebuffer() methods.  Those methods
		are only available if USBDEV_DMA is defined in the system configuration.

config USBDEV_DMAMEMORY
bool "Board DMA Allocation Hooks"
	default n
	depends on USBDEV_DMA
	---help---
		The USB class driver allocates packet I/O buffers for data transfer by
		calling the driver allocbuffer() and freebuffer() methods.  Those methods
		are only available if USBDEV_DMA is defined in the system configuration.

		If USBDEV_DMAMEMORY is also defined in the NuttX configuration, then
		the driver implementations of the allocbuffer() and freebuffer()
		methods may use board-specific usbdev_dma_alloc() and usbdev_dma_free().
		If USBDEV_DMA and USBDEV_DMAMEMORY are both defined, then the board-
		specific logic must provide the functions usbdev_dma_alloc() and
		usbdev_dma_free(): usbdev_dma_alloc() will allocate DMA-capable
		memory of the specified size; usbdev_dma_free() is the corresponding
		function that will be called to free the DMA-capable memory.

config ARCH_USBDEV_STALLQUEUE
	bool
	default n
	---help---
		This option is set by the USB device controller driver (DCD)
		selection.  These selection means that the DCD can support
		queuing of stall requests.  By this, it is meant that, (1) the
		stall is not sent until all write requests preceding the stall
		request are sent, (2) the stall is sent, and then after the
		stall is cleared, (3) all write requests queued after the stall
		are sent.

		If the driver does not support this feature, that the class drivers
		will enable some hokey and inefficient delay logic to workaround
		the lack of queuing.

menuconfig USBDEV_TRACE
	bool "Enable USB tracing for debug"
	default n
	select HAVE_USBTRACE
	---help---
		Enables USB tracing for debug

if USBDEV_TRACE

config USBDEV_TRACE_NRECORDS
	int "Number of trace entries to remember"
	default 128
	---help---
		Number of trace entries to remember

config USBDEV_TRACE_STRINGS
	bool "Decode device controller events"
	default n
	depends on DEBUG_USB
	---help---
		If USBDEV_TRACE_STRINGS is defined, then the USB device controller
		driver must provide arrays of strings to support decoding of device-
		specific trace events.  These arrays of strings (and the type struct
		trace_msg_t) are defined in include/nuttx/usb/usbdev_trace.h:

		#ifdef CONFIG_USBDEV_TRACE_STRINGS
		extern const struct trace_msg_t g_usb_trace_strings_deverror[];
		extern const struct trace_msg_t g_usb_trace_strings_intdecode[];
		#endif

config USBDEV_TRACE_INITIALIDSET
	int "Initial enable bits"
	default 0
	---help---
		This is the set of initial USB features that are enabled at boot
		time.  See the event ID class bit definitions in
		include/nuttx/usbdev_trace.h.

endif # USBDEV_TRACE

menuconfig USBDEV_CUSTOM_TXFIFO_SIZE
	bool "Custom TX Fifo size"
	default n
	---help---
		Enables custom TX Fifo size

if USBDEV_CUSTOM_TXFIFO_SIZE

config USBDEV_EP0_TXFIFO_SIZE
	int "USBDEV_EP0_TXFIFO_SIZE"
	default 64

config USBDEV_EP1_TXFIFO_SIZE
	int "USBDEV_EP1_TXFIFO_SIZE"
	default 0

config USBDEV_EP2_TXFIFO_SIZE
	int "USBDEV_EP2_TXFIFO_SIZE"
	default 0

config USBDEV_EP3_TXFIFO_SIZE
	int "USBDEV_EP3_TXFIFO_SIZE"
	default 0

config USBDEV_EP4_TXFIFO_SIZE
	int "USBDEV_EP4_TXFIFO_SIZE"
	default 0

config USBDEV_EP5_TXFIFO_SIZE
	int "USBDEV_EP5_TXFIFO_SIZE"
	default 0

config USBDEV_EP6_TXFIFO_SIZE
	int "USBDEV_EP6_TXFIFO_SIZE"
	default 0

config USBDEV_EP7_TXFIFO_SIZE
	int "USBDEV_EP7_TXFIFO_SIZE"
	default 0

config USBDEV_EP8_TXFIFO_SIZE
	int "USBDEV_EP8_TXFIFO_SIZE"
	default 0

endif # USBDEV_CUSTOM_TXFIFO_SIZE

comment "USB Device Class Driver Options"

menuconfig USBDEV_COMPOSITE
	bool "USB composite device support"
	default n
	---help---
		Enables USB composite device support

if USBDEV_COMPOSITE

config COMPOSITE_IAD
	bool "Use Interface Associate Descriptor (IAD)"
	default n
	---help---
		If one of the members of the composite has multiple interfaces
		(such as CDC/ACM), then an Interface Association Descriptor (IAD)
		will be necessary.  Default:  IAD will be used automatically if
		needed.  It should not be necessary to set this.

config COMPOSITE_EP0MAXPACKET
	int "Max packet size for endpoint 0"
	default 64
	---help---
		Max packet size for endpoint 0

config COMPOSITE_VENDORID
	hex "Composite vendor ID"
	default 0x0000

config COMPOSITE_VENDORSTR
	string "Composite vendor ID"
	default "NuttX"
	---help---
		The vendor ID code/string

config COMPOSITE_PRODUCTID
	hex "Composite product id"
	default 0x0000

config COMPOSITE_PRODUCTSTR
	string "Composite product string"
	default "Composite device"
	---help---
		The product ID code/string

config COMPOSITE_BOARD_SERIALSTR
	bool "Enable board unique ID to composite serial string"
	default n
	select BOARD_USBDEV_SERIALSTR
	---help---
		Use board unique serial number to iSerialNumber in the device descriptor.

config COMPOSITE_SERIALSTR
	string "Composite serial string"
	default "001"
	depends on !COMPOSITE_BOARD_SERIALSTR
	---help---
		Device serial number string

config COMPOSITE_CONFIGSTR
	string "Configuration string"
	default "NuttX COMPOSITE config"
	---help---
		Configuration string

config COMPOSITE_VERSIONNO
	hex "Composite version number"
	default 0x1010
	---help---
		Interface version number.

config COMPOSITE_MSFT_OS_DESCRIPTORS
	bool "Add support for Microsoft OS Descriptors"
	default n
	---help---
		Microsoft Windows cannot always automatically determine appropriate
		drivers for different interfaces of a USB composite device. There is
		a vendor-specific mechanism called "Microsoft OS Descriptors" that
		allows the interface to provide further ID code to help with driver
		loading. See https://msdn.microsoft.com/en-us/windows/hardware/gg463179
		Enabling this feature in composite driver will pass these requests
		onwards to the interface drivers.

endif

config PL2303
	bool "Prolific PL2303 serial/USB converter emulation"
	default n
	select SERIAL_REMOVABLE
	---help---
		This logic emulates the Prolific PL2303 serial/USB converter

if PL2303

config PL2303_CONSOLE
	bool "PL2303 console device"
	default n
	---help---
		Register the USB device as /dev/console so that is will be used
		as the console device.

config PL2303_EPINTIN
	int "Interrupt IN endpoint number"
	default 1

config PL2303_EPBULKOUT
	int "Bulk OUT endpoint number"
	default 2

config PL2303_EPBULKIN
	int "Bulk IN endpoint number"
	default 3

config PL2303_EP0MAXPACKET
	int "Packet and request buffer sizes"
	default 64

config PL2303_NWRREQS
	int "Number of read requests that can be in flight"
	default 4
	---help---
		The number of read requests that can be in flight

config PL2303_NRDREQS
	int "Number of write requests that can be in flight"
	default 4
	---help---
		The number of write/read requests that can be in flight

config PL2303_BULKIN_REQLEN
	int "Size of one write request buffer"
	default 768 if USBDEV_DUALSPEED
	default 96  if !USBDEV_DUALSPEED
	---help---
		Ideally, the BULKOUT request size should *not* be the same size as
		the maxpacket size.  That is because IN transfers of exactly the
		maxpacket size will be followed by a NULL packet.  The BULKOUT,
		on the other hand, request buffer size is always the same as the
		maxpacket size.

		There is also no reason from PL2303_BULKIN_REQLEN to be greater
		than PL2303_TXBUFSIZE-1, since a request larger than the TX
		buffer can never be sent.

config PL2303_RXBUFSIZE
	int "Receive buffer size"
	default 513 if USBDEV_DUALSPEED
	default 257 if !USBDEV_DUALSPEED
	---help---
		Size of the serial receive buffers.  The actual amount of data that
		can be held in the buffer is this number minus one due to the way
		that the circular buffer is managed.  So an RX buffer size of 257
		will hold four full-speed, 64 byte packets; a buffer size of 513
		will hold one high-speed, 512 byte packet.

config PL2303_TXBUFSIZE
	int "Transmit buffer size"
	default 769 if USBDEV_DUALSPEED
	default 193 if !USBDEV_DUALSPEED
	---help---
		Size of the serial transmit buffers.  The actual amount of data that
		can be held in the buffer is this number minus one due to the way
		that the circular buffer is managed.  So a TX buffer size of 769
		will hold one request of size 768; a buffer size of 193 will hold
		two requests of size 96 bytes.

config PL2303_VENDORID
	hex "Vendor ID"
	default 0x067b

config PL2303_PRODUCTID
	hex "Product ID"
	default 0x2303

config PL2303_VENDORSTR
	string "Vendor string"
	default "NuttX"

config PL2303_BOARD_SERIALSTR
	bool "Enable board unique ID to PL2303 serial string"
	default n
	select BOARD_USBDEV_SERIALSTR
	---help---
		Use board unique serial number to iSerialNumber in the device descriptor.

config PL2303_PRODUCTSTR
	string "Product string"
	default "PL2303 Emulation"
endif

menuconfig CDCACM
	bool "USB Modem (CDC/ACM) support"
	default n
	select SERIAL_REMOVABLE
	---help---
		Enables USB Modem (CDC/ACM) support

if CDCACM

config CDCACM_CONSOLE
	bool "CDC/ACM console device"
	default n
	---help---
		Register the USB device as /dev/console so that is will be used
		as the console device.

config CDCACM_IFLOWCONTROL
	bool "CDC/ACM RTS flow control"
	default n
	select SERIAL_IFLOWCONTROL
	---help---
		Enable CDC/ACM RTS flow control

config CDCACM_OFLOWCONTROL
	bool "CDC/ACM CTS flow control"
	default n
	depends on EXPERIMENTAL
	select SERIAL_OFLOWCONTROL
	---help---
		Enable CDC/ACM CTS flow control

menuconfig CDCACM_COMPOSITE
	bool "CDC/ACM composite support"
	default n
	depends on USBDEV_COMPOSITE
	---help---
		Configure the CDC serial driver as part of a composite driver
		(only if USBDEV_COMPOSITE is also defined)

if !CDCACM_COMPOSITE

# In a composite device the EP0 config comes from the composite device
# and the EP-Number is configured dynamically via composite_initialize

config CDCACM_EP0MAXPACKET
	int "Endpoint 0 max packet size"
	default 64
	---help---
		Endpoint 0 max packet size. Default 64.

config CDCACM_EPINTIN
	int "Interrupt IN endpoint number"
	default 1
	---help---
		The logical 7-bit address of a hardware endpoint that supports
		interrupt IN operation.  Default 1.

endif

config CDCACM_EPINTIN_FSSIZE
	int "Interrupt IN full speed MAXPACKET size"
	default 64
	---help---
		Max package size for the interrupt IN endpoint if full speed mode.
		Default 64.

if USBDEV_DUALSPEED

config CDCACM_EPINTIN_HSSIZE
	int "Interrupt IN high speed MAXPACKET size"
	default 64
	---help---
		Max package size for the interrupt IN endpoint if high speed mode.
		Default 64.

endif # USBDEV_DUALSPEED

if !CDCACM_COMPOSITE

# In a composite device the EP-Number is configured dynamically via
# composite_initialize

config CDCACM_EPBULKOUT
	int "Bulk OUT endpoint number"
	default 3
	---help---
		The logical 7-bit address of a hardware endpoint that supports
		bulk OUT operation.  Default: 3

endif

config CDCACM_EPBULKOUT_FSSIZE
	int "Bulk OUT full speed  MAXPACKET size"
	default 64
	---help---
		Max package size for the bulk OUT endpoint if full speed mode.
		Default 64.

if USBDEV_DUALSPEED

config CDCACM_EPBULKOUT_HSSIZE
	int "Bulk OUT out high speed  MAXPACKET size"
	default 512
	---help---
		Max package size for the bulk OUT endpoint if high speed mode.
		Default 512.

endif # USBDEV_DUALSPEED

if !CDCACM_COMPOSITE

# In a composite device the EP-Number is configured dynamically via
# composite_initialize

config CDCACM_EPBULKIN
	int "Bulk IN endpoint number"
	default 2
	---help---
		The logical 7-bit address of a hardware endpoint that supports
		bulk IN operation.  Default: 2

endif

config CDCACM_EPBULKIN_FSSIZE
	int "Bulk IN full speed  MAXPACKET size"
	default 64
	---help---
		Max package size for the bulk IN endpoint if full speed mode.
		Default 64.

if USBDEV_DUALSPEED

config CDCACM_EPBULKIN_HSSIZE
	int "Bulk IN high speed  MAXPACKET size"
	default 512
	---help---
		Max package size for the bulk IN endpoint if high speed mode.
		Default 512.

endif # USBDEV_DUALSPEED

config CDCACM_NRDREQS
	int "Number of read requests that can be in flight"
	default 4
	---help---
		The number of read requests that can be in flight

config CDCACM_NWRREQS
	int "Number of write requests that can be in flight"
	default 4
	---help---
		The number of write/read requests that can be in flight

config CDCACM_BULKIN_REQLEN
	int "Size of one write request buffer"
	default 768 if USBDEV_DUALSPEED
	default 96  if !USBDEV_DUALSPEED
	---help---
		Ideally, the BULKOUT request size should *not* be the same size as
		the maxpacket size.  That is because IN transfers of exactly the
		maxpacket size will be followed by a NULL packet.  The BULKOUT,
		on the other hand, request buffer size is always the same as the
		maxpacket size.

		There is also no reason from CDCACM_BULKIN_REQLEN to be greater
		than CDCACM_TXBUFSIZE-1, since a request larger than the TX
		buffer can never be sent.

config CDCACM_RXBUFSIZE
	int "Receive buffer size"
	default 513 if USBDEV_DUALSPEED
	default 257 if !USBDEV_DUALSPEED
	---help---
		Size of the serial receive buffers.  The actual amount of data that
		can be held in the buffer is this number minus one due to the way
		that the circular buffer is managed.  So an RX buffer size of 257
		will hold four full-speed, 64 byte packets; a buffer size of 513
		will hold one high-speed, 512 byte packet.

config CDCACM_TXBUFSIZE
	int "Transmit buffer size"
	default 769 if USBDEV_DUALSPEED
	default 193 if !USBDEV_DUALSPEED
	---help---
		Size of the serial transmit buffers.  The actual amount of data that
		can be held in the buffer is this number minus one due to the way
		that the circular buffer is managed.  So a TX buffer size of 769
		will hold one request of size 768; a buffer size of 193 will hold
		two requests of size 96 bytes.

if !CDCACM_COMPOSITE

# In a composite device the Vendor- and Product-ID is given by the composite
# device

config CDCACM_VENDORID
	hex "Vendor ID"
	default 0x0525
	---help---
		The vendor ID code/string.  Default 0x0525 and "NuttX"
		0x0525 is the Netchip vendor and should not be used in any
		products.  This default VID was selected for compatibility with
		the Linux CDC ACM default VID.

config CDCACM_PRODUCTID
	hex "Product ID"
	default 0xa4a7
	---help---
		The product ID code/string. Default 0xa4a7 and "CDC/ACM Serial"
		0xa4a7 was selected for compatibility with the Linux CDC ACM
		default PID.

config CDCACM_VENDORSTR
	string "Vendor string"
	default "NuttX"

config CDCACM_PRODUCTSTR
	string "Product string"
	default "CDC/ACM Serial"

config CDCACM_BOARD_SERIALSTR
	bool "Enable board unique ID to CDC/ACM serial string"
	default n
	select BOARD_USBDEV_SERIALSTR
	---help---
		Use board unique serial number to iSerialNumber in the device descriptor.

endif # !CDCACM_COMPOSITE
endif # CDCACM

menuconfig USBADB
	bool "USB Android Debug Bridge (ADB) support"
	default n
	---help---
		Enables USB Android Debug Bridge (ADB) support

if USBADB

menuconfig USBADB_COMPOSITE
	bool "USBADB composite support"
	default n
	depends on USBDEV_COMPOSITE
	---help---
		Configure the ADB driver as part of a composite driver
		(only if USBDEV_COMPOSITE is also defined)

if !USBADB_COMPOSITE

# In a composite device the EP0 config comes from the composite device
# and the EP-Number is configured dynamically via composite_initialize

config USBADB_EP0MAXPACKET
	int "Endpoint 0 max packet size"
	default 64
	---help---
		Endpoint 0 max packet size. Default 64.

# In a composite device the EP-Numbers are configured dynamically via
# composite_initialize

config USBADB_EPBULKOUT
	int "Bulk OUT endpoint number"
	default 1
	---help---
		The logical 7-bit address of a hardware endpoint that supports
		bulk OUT operation.  Default: 3

config USBADB_EPBULKIN
	int "Bulk IN endpoint number"
	default 2
	---help---
		The logical 7-bit address of a hardware endpoint that supports
		bulk IN operation.  Default: 2
endif

config USBADB_EPBULKOUT_FSSIZE
	int "Bulk OUT full speed  MAXPACKET size"
	default 64
	---help---
		Max package size for the bulk OUT endpoint if full speed mode.
		Default 64.

if USBDEV_DUALSPEED

config USBADB_EPBULKOUT_HSSIZE
	int "Bulk OUT out high speed  MAXPACKET size"
	default 512
	---help---
		Max package size for the bulk OUT endpoint if high speed mode.
		Default 512.

endif # USBDEV_DUALSPEED

config USBADB_EPBULKIN_FSSIZE
	int "Bulk IN full speed  MAXPACKET size"
	default 64
	---help---
		Max package size for the bulk IN endpoint if full speed mode.
		Default 64.

if USBDEV_DUALSPEED

config USBADB_EPBULKIN_HSSIZE
	int "Bulk IN high speed  MAXPACKET size"
	default 512
	---help---
		Max package size for the bulk IN endpoint if high speed mode.
		Default 512.

endif # USBDEV_DUALSPEED

config USBADB_NRDREQS
	int "Number of read requests that can be in flight"
	default 4
	---help---
		The number of read requests that can be in flight

config USBADB_NWRREQS
	int "Number of write requests that can be in flight"
	default 4
	---help---
		The number of write/read requests that can be in flight

if !USBADB_COMPOSITE

config USBADB_VENDORID
	hex "Vendor ID"
	default 0x18d1
	---help---
		The vendor ID code/string. Default is Google Inc.

config USBADB_PRODUCTID
	hex "Product ID"
	default 0x4e11
	---help---
		The product ID code/string. Default is Nexus One.

config USBADB_VENDORSTR
	string "Vendor string"
	default "NuttX"

config USBADB_PRODUCTSTR
	string "Product string"
	default "Debug Bridge"

config USBADB_BOARD_SERIALSTR
	bool "Enable board unique ID to USBADB serial string"
	default n
	select BOARD_USBDEV_SERIALSTR
	---help---
		Use board unique serial number to iSerialNumber in the device descriptor.

config USBADB_SERIALSTR
	string "Serial string"
	default "1234"
	depends on !USBADB_BOARD_SERIALSTR

endif # !USBADB_COMPOSITE

config USBADB_CONFIGSTR
	string "Configuration descriptor string"
	default "ADB Config"

config USBADB_INTERFACESTR
	string "Interface descriptor string"
	default "ADB Interface"

config USBADB_NPOLLWAITERS
	int "Number of ADB poll waiters"
	default 1
	---help---
		Maximum number of threads that can be waiting on poll().

endif # USBADB

menuconfig USBMSC
	bool "USB Mass storage class device"
	default n
	---help---
		References:
		"Universal Serial Bus Mass Storage Class, Specification Overview,"
		Revision 1.2,  USB Implementer's Forum, June 23, 2003.

		"Universal Serial Bus Mass Storage Class, Bulk-Only Transport,"
		Revision 1.0, USB Implementer's Forum, September 31, 1999.

		"SCSI Primary Commands - 3 (SPC-3),"  American National Standard
		for Information Technology, May 4, 2005

		"SCSI Primary Commands - 4 (SPC-4),"  American National Standard
		for Information Technology, July 19, 2008

		"SCSI Block Commands -2 (SBC-2)," American National Standard
		for Information Technology, November 13, 2004

		"SCSI Multimedia Commands - 3 (MMC-3),"  American National Standard
		for Information Technology, November 12, 2001

if USBMSC

config USBMSC_COMPOSITE
	bool "Mass storage composite support"
	default n
	depends on USBDEV_COMPOSITE
	---help---
		Configure the mass storage driver as part of a composite driver
		(only if USBDEV_COMPOSITE is also defined)

if !USBMSC_COMPOSITE

# In a composite device the EP-Number and STR-Number is configured
# dynamically via composite_initialize

config USBMSC_EP0MAXPACKET
	int "Max packet size for endpoint 0"
	default 64
	---help---
		Max packet size for endpoint 0

config USBMSC_EPBULKOUT
	int "Bulk OUT endpoint number"
	default 2
	---help---
		The logical 7-bit address of a hardware endpoints that support
		bulk OUT and IN operations

config USBMSC_EPBULKIN
	int "Bulk IN endpoint number"
	default 3
	---help---
		The logical 7-bit address of a hardware endpoints that support
		bulk OUT and IN operations

endif

config USBMSC_NWRREQS
	int "The number of write requests that can be in flight"
	default 4
	---help---
		The number of write/read requests that can be in flight

config USBMSC_NRDREQS
	int "The number of read requests that can be in flight"
	default 4
	---help---
		The number of write/read requests that can be in flight

config USBMSC_WRMULTIPLE
	bool "Write multiple blocks at once if possible"
	default n
	---help---
		Store multiple blocks and write them in a single request.  This
		speeds up the writing significantly with eMMC devices, for example,
		because writing 512 bytes may be as fast as writing the complete
		SUPER_PAGE_SIZE (see extended CSD [225] bits 0-3), which may be up
		to 64Kb.  Real-life example with different block sizes, using the
		dd command with argument bs=512, bs=8k (USBMSC_NWRREQS = 4, and 16):
		512b: 470 kb/s, 8k: 5.3 Mb/s.  This is more than a tenfold increase
		in the throughput.  Without this option enabled, the block driver's
		block size is always used, which is usually 512 bytes.

config USBMSC_BULKINREQLEN
	int "Bulk IN request size"
	default 512 if USBDEV_DUALSPEED
	default 64  if !USBDEV_DUALSPEED
	---help---
		The size of the buffer in each WRITE request.  This value should to be
		at least as large as the endpoint maxpacket size .  Most DCDs can divide
		a large request buffer down and enqueue the smaller, outgoing packets
		for better performance.  So, ideally, the size of write request buffer
		should be the size of one block device sector which is, often, 512
		bytes.  The default, however, is the minimum size of 512 or 64 bytes
		(depending upon if dual speed operation is supported or not).

config USBMSC_BULKOUTREQLEN
	int "Bulk OUT request size"
	default 512 if USBDEV_DUALSPEED
	default 64  if !USBDEV_DUALSPEED
	---help---
		The size of the buffer in each READ request.  This value should to be
		at least as large as the endpoint maxpacket size.  Most DCDs will return
		the completed READ request to the caller as each packet is received.
		Therefore, there is no benefit in increasing the size of this buffer
		beyond the maximum size of one packet.  Default:  512 or 64 bytes
		(depending upon if dual speed operation is supported or not).

if USBMSC_COMPOSITE

config USBMSC_IFNOBASE
	int "Mass storage interface number"
	default 0
	---help---
		With composite USB drivers, the interface is not guaranteed to be zero
		but rather, may vary according to the order in which the devices are
		declared in the board_composite_connect() -function. This function may
		be found in the corresponding board file. This index number may need to
		be adjusted to match the proper interface number.

endif

if !USBMSC_COMPOSITE

# In a composite device the Vendor- and Product-IDs are handled by the
# composite device

config USBMSC_VENDORID
	hex "Mass storage Vendor ID"
	default 0x584e
	---help---
		The vendor ID (VID).  The value here is bogus.  You should not use
		it in any commercial products!  You must go through the proper
		channels to request a vendor ID for your company if you do not
		already have one!

config USBMSC_VENDORSTR
	string "Mass storage vendor string"
	default "NuttX"
	---help---
		The vendor ID code/string

config USBMSC_PRODUCTID
	hex "Mass storage Product ID"
	default 0x5342
	---help---
		The product ID (PID).

config USBMSC_PRODUCTSTR
	string "Mass storage product string"
	default "Mass Storage"

config USBMSC_BOARD_SERIALSTR
	bool "Enable board unique ID to mass storage serial string"
	default n
	select BOARD_USBDEV_SERIALSTR
	---help---
		Use board unique serial number to iSerialNumber in the device descriptor.

endif # !USBMSC_COMPOSITE

config USBMSC_VERSIONNO
	hex "USB MSC Version Number"
	default 0x399

config USBMSC_REMOVABLE
	bool "Mass storage removable"
	default n
	---help---
		Select if the media is removable
		USB Composite Device Configuration

config USBMSC_SCSI_PRIO
	int "USBMSC SCSI daemon priority"
	default 128
	---help---
		Priority of the SCSI kernel thread.  This must be a relatively high
		priority so that the SCSI daemon can be response to USB block driver
		accesses.

config USBMSC_SCSI_STACKSIZE
	int "USBMSC SCSI daemon stack size"
	default DEFAULT_TASK_STACKSIZE
	---help---
		Stack size used with the SCSI kernel thread.  The default value
		is not tuned.

config USBMSC_NOT_STALL_BULKEP
	bool "Not stall USBMSC bulk endpoints for workaround"
	default n
	---help---
		Not stall USBMSC bulk endpoints in some conditions.
		Because RP2040 usbdev driver cannot handle stalling/resuming bulk
		endpoints well, this workaround is required.

endif

menuconfig RNDIS
	bool "RNDIS Ethernet-over-USB"
	default n
	---help---
		References:
		- "MS-RNDIS: Remote Network Driver Interface Specification (RNDIS)
		   Protocol"
		- "Remote NDIS To USB Mapping"

		This option may required CONFIG_NETDEV_LATEINIT=y otherwise, the
		power-up initialization may call the non-existent up_netinitialize().
		This option is not automatically selected because it may be that
		you have an additional network device that requires the early
		up_netinitialize() call.

if RNDIS

config RNDIS_NWRREQS
	int "The number of write requests that can be in flight"
	default 4 if NET_TCP_WRITE_BUFFERS
	default 2 if !NET_TCP_WRITE_BUFFERS
	---help---
		The number of write/read requests that can be in flight

config RNDIS_COMPOSITE
	bool "RNDIS composite support"
	default n
	depends on USBDEV_COMPOSITE
	---help---
		Configure the RNDIS driver as part of a composite driver
		(only if USBDEV_COMPOSITE is also defined)

if !RNDIS_COMPOSITE

config RNDIS_VENDORID
	hex "RNDIS Vendor ID"
	default 0x584e
	---help---
		The vendor ID (VID).  The value here is bogus.  You should not use
		it in any commercial products!  You must go through the proper
		channels to request a vendor ID for your company if you do not
		already have one!

config RNDIS_VENDORSTR
	string "RNDIS vendor string"
	default "NuttX"
	---help---
		The vendor ID code/string

config RNDIS_PRODUCTID
	hex "RNDIS Product ID"
	default 0x5342
	---help---
		The product ID (PID).

config RNDIS_PRODUCTSTR
	string "RNDIS product string"
	default "RNDIS gadget"

config RNDIS_BOARD_SERIALSTR
	bool "Enable board unique ID to RNDIS serial string"
	default n
	select BOARD_USBDEV_SERIALSTR
	---help---
		Use board unique serial number to iSerialNumber in the device descriptor.

config RNDIS_SERIALSTR
	string "RNDIS serial string"
	default "1234"
	depends on !RNDIS_BOARD_SERIALSTR

config RNDIS_VERSIONNO
	hex "RNDIS Version Number"
	default 0x0001

endif # !RNDIS_COMPOSITE

config RNDIS_EPBULKIN
	int "RNDIS bulk in endpoint number"
	default 1

config RNDIS_EPBULKOUT
	int "RNDIS bulk out endpoint number"
	default 2

config RNDIS_EPINTIN
	int "RNDIS interrupt in endpoint number"
	default 3

endif # RNDIS

menuconfig DFU
	bool "DFU Device Firmware Upgrade"
	default n
	---help---
		References:
		  - "Universal Serial Bus Device Class Specification for Device
		     Firmware Upgrade, Version 1.1, Aug 5, 2004"

		This driver implements the application-part of DFU protocol. It enables
		a host application to send DFU_DETACH request and to cause the device
		to reboot into a bootloader mode.

if DFU

config DFU_MSFT_OS_DESCRIPTORS
	bool "Microsoft OS descriptor support"
	default n
	depends on COMPOSITE_MSFT_OS_DESCRIPTORS
	---help---
		Enabling this option will cause the DFU driver to return "WINUSB" as
		the compatible ID of the DFU interface. This will automatically load
		the appropriate driver for use with e.g. libusb and dfu-util.
		Note that as of 2018 there are some issues with libusb and
		composite devices, you may need a patched version:
		https://sourceforge.net/p/libusb/mailman/message/36304399/

config DFU_INTERFACE_NAME
	string "DFU interface string"
	default "DFU interface"
	---help---
		String to assign as a name for the DFU interface.

if DFU_MSFT_OS_DESCRIPTORS

config DFU_INTERFACE_GUID
	string "DFU interface GUID"
	default "{8FE6D4D7-49DD-41E7-9486-49AFC6BFE475}"
	---help---
		DeviceInterfaceGUID to use for DFU interface in Microsoft OS descriptors.
		Actual value does not matter for libusb, but if using WinUSB API directly
		you can request your device by this GUID.

endif # DFU_MSFT_OS_DESCRIPTORS
endif # DFU

menuconfig NET_CDCECM
	bool "CDC-ECM Ethernet-over-USB"
	default n
	select NETDEVICES
	select NET
	select NET_ETHERNET
	---help---
		References:
		- "Universal Serial Bus - Communications Class - Subclass
		   Specification for Ethernet Control Model Devices,
		   Revision 1.2, February 9, 2007"

		This option may require CONFIG_NETDEV_LATEINIT=y, otherwise the
		power-up initialization may call the non-existent up_netinitialize().
		This option is not automatically selected because it may be that
		you have an additional network device that requires the early
		up_netinitialize() call.

if NET_CDCECM

menuconfig CDCECM_COMPOSITE
	bool "CDC/ECM composite support"
	default n
	depends on USBDEV_COMPOSITE
	---help---
		Configure the CDC Ethernet Control Model driver as part of a
		composite driver (only if USBDEV_COMPOSITE is also defined)

if !CDCECM_COMPOSITE

# In a composite device the EP0 config comes from the composite device
# and the EP-Number is configured dynamically via composite_initialize

config CDCECM_EP0MAXPACKET
	int "Endpoint 0 max packet size"
	default 64
	---help---
		Endpoint 0 max packet size. Default 64.

config CDCECM_EPINTIN
	int "Interrupt IN endpoint number"
	default 1
	---help---
		The logical 7-bit address of a hardware endpoint that supports
		interrupt IN operation.  Default 1.

endif # !CDCECM_COMPOSITE

config CDCECM_EPINTIN_FSSIZE
	int "Interrupt IN full speed MAXPACKET size"
	default 16
	---help---
		Max package size for the interrupt IN endpoint if full speed mode.
		Default 16.

if USBDEV_DUALSPEED

config CDCECM_EPINTIN_HSSIZE
	int "Interrupt IN high speed MAXPACKET size"
	default 64
	---help---
		Max package size for the interrupt IN endpoint if high speed mode.
		Default 64.

endif # USBDEV_DUALSPEED

if !CDCECM_COMPOSITE

# In a composite device the EP-Number is configured dynamically via
# composite_initialize

config CDCECM_EPBULKOUT
	int "Bulk OUT endpoint number"
	default 5
	---help---
		The logical 7-bit address of a hardware endpoint that supports
		bulk OUT operation.  Default: 5

endif # !CDCECM_COMPOSITE

config CDCECM_EPBULKOUT_FSSIZE
	int "Bulk OUT full speed  MAXPACKET size"
	default 64
	---help---
		Max package size for the bulk OUT endpoint if full speed mode.
		Default 64.

if USBDEV_DUALSPEED

config CDCECM_EPBULKOUT_HSSIZE
	int "Bulk OUT out high speed  MAXPACKET size"
	default 512
	---help---
		Max package size for the bulk OUT endpoint if high speed mode.
		Default 512.

endif # USBDEV_DUALSPEED

if !CDCECM_COMPOSITE

# In a composite device the EP-Number is configured dynamically via
# composite_initialize

config CDCECM_EPBULKIN
	int "Bulk IN endpoint number"
	default 2
	---help---
		The logical 7-bit address of a hardware endpoint that supports
		bulk IN operation.  Default: 2

endif # !CDCECM_COMPOSITE

config CDCECM_EPBULKIN_FSSIZE
	int "Bulk IN full speed  MAXPACKET size"
	default 64
	---help---
		Max package size for the bulk IN endpoint if full speed mode.
		Default 64.

if USBDEV_DUALSPEED

config CDCECM_EPBULKIN_HSSIZE
	int "Bulk IN high speed  MAXPACKET size"
	default 512
	---help---
		Max package size for the bulk IN endpoint if high speed mode.
		Default 512.

endif # USBDEV_DUALSPEED

if !CDCECM_COMPOSITE

# In a composite device the Vendor- and Product-ID is given by the composite
# device

config CDCECM_VENDORID
	hex "Vendor ID"
	default 0x0525
	---help---
		The vendor ID code/string.  Default 0x0525 and "NuttX"
		0x0525 is the Netchip vendor and should not be used in any
		products.  This default VID was selected for compatibility with
		the Linux CDC ECM default VID.

config CDCECM_PRODUCTID
	hex "Product ID"
	default 0xa4a2
	---help---
		The product ID code/string. Default 0xa4a2 and "CDC/ECM Ethernet"
		0xa4a2 was selected for compatibility with the Linux CDC ECM
		default PID.

config CDCECM_VENDORSTR
	string "Vendor string"
	default "NuttX"

config CDCECM_PRODUCTSTR
	string "Product string"
	default "CDC/ECM Ethernet"

config CDCECM_BOARD_SERIALSTR
	bool "Enable board unique ID to CDC/ECM serial string"
	default n
	select BOARD_USBDEV_SERIALSTR
	---help---
		Use board unique serial number to iSerialNumber in the device descriptor.

endif # !CDCECM_COMPOSITE
endif # CDCECM

endif # USBDEV
