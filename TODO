NuttX TODO List
^^^^^^^^^^^^^^^

o Task/Scheduler
- When a tasks exits, shouldn't all of its child pthreads also be terminated?
- Should task_delete() cause atexit() function to be called?
- Implement sys/mman.h and functions
- Implement sys/wait.h and functions
- Implement priority inheritance
- Consider implementing wait, waitpid, waitid.  At present, a parent has
  no information about child tasks.
- Several APIs do not set errno.  Need to review all APIs.

o Memory Managment
- Add an option to free all memory allocated by a task when the task exits.
  This is probably not be worth the overhead for a deeply embedded system.
- Current logic adapts size_t for 16-bit address machines vs. 32-bit address
  machines.  But a small memory option should also be provided so that
  the small offset option can be used with 32-bit machines that have small
  RAM memories (like the lpc2148)

o Signals
- 'Standard' signals and signal actions are not supported.

o pthreads
- pthread_cancel():  Should implement cancellation points and pthread_testcancel()

o C++ Support
- Need to call static constructors

o Network
- Did not implement send() and sendto() timeouts.  Option is setable via setsockopt,
  but is not implemented.
- netutils/webserver netutils/telnetd (and maybe others) are seriously broken.
  Need to be re-written to use listen() and accept()
- Should implement SOCK_RAW
- listen() and accept() are untested.
- accept() and recvfrom() need to return connection address
- Performance Improvements (uIP is not very fast):
- Improve performance by queing TX operations
  Add simple buffer management.  CONFIG_NET_BUFFERS
  (1) On write, queue buffer for output get a new buffer for the socket (waiting if
      nececcesary
  (2) Copy buffer structure into uip_driver_structure when driver requests write
      data
- Improve performance by stimulating the driver to accept new TX data before the
  next polling interval.

  Add a txail callback into driver to eliminate send delays.  Since we want to
  support multiple network devices, this means we will have to add some infrastructure
  to map to device.
- Break uip_interrupt() (in uip.c) into several functions.
- uIP polling issues:
  (1) uIP expects a single driver to poll at a 500ms interval (dm90x0 currently
      polls a 5sec).
  (2) Current logic will not support multiple ethernet drivers.  Each driver should
      poll on TCP connections connect on the network supported by the driver; UDP
      polling should respond with TX data only if the UDP packet is intended for the
      the network supported by the driver.
  (3) If there were multiple drivers, polling would occur at double the rate.
- TCP Bug:
  When TCP data is received with no read in place, it appears that uIP ACKs the data
  even though it was not taken accepted.  We must either (1) buffer incoming data, or
  (2) not ACK it so that it will be re-sent.

o USB
- Implement USB device support
- Implement USB bulk device

o Libraries
- sscanf() and lib_vsprintf() do not support floating point values.
- The definition of environ in stdlib.h is bogus and will not work as it should.  This
  is because the underlying representation of the environment is not an arry of pointers.

o File system
- Add chmod(), truncate().
- FAT32: long file names

o Documentation
- Document fs/ & driver/ logic
- Document C-library APIs

o Build system
- Some names under arch are still incorrect.  These should be processor architecture
  names:  pjrc-8051 should be 805x
- configs/pjrc-8051 should be configs/pjrc-87c52
- Dependencies do not work correctly under configs/<board>/src (same as arch/<arch>/src/board).

o Applications & Tests

o C5471

o DM320
- It seems that when a lot of debug statements are added, the system no
  longer boots.  There could be some issue with the bootloader or with
  the programming of the SDRAM MMU regions.

o LPC214x
- Finish bringup
- Add MMC and USB support

o pjrc-8052 / MCS51
- Current status:
  - Basic OS task management seems OK
  - Fails when interrupts enabled.  The stack pointer is around 0x6e
    before the failure occurs.  It looks like some issue when the
    stack pointer moves from the directly to indirectly addressable
    region (0x80 boundary).
  - Work on the 8052 is temporarily on hold
- Use timer 0 as system timer.  Timer 2 is needed for second UART.
  Logic is implemented, but there needs to be a system configuration
  to change the ticks-per-second value to match the timer interrupt
  rate
- During build, there are several integer overflows reported:
  gmtime_r.c aroud lines 184 and 185
  clock_initialize.c at line 107
  pthread_create.c at 330
  sighand.c at 225 and 244

